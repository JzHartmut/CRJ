/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "InspcJ2c/CmdExecuter_Inspc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "InspcJ2c/CmdConsumer_ifc_Inspc.h"  //reference-association: cmdConsumerMtbl
#include "InspcJ2c/Comm_Inspc.h"  //reference-association: comm
#include "Ipc/InterProcessComm.h"  //reference-association: ipcMtbl
#include "Jc/PrintStreamJc.h"  //reference-association: out
#include "Jc/SystemJc.h"  //reference-association: SystemJc


/* J2C: Forward declaration of struct ***********************************************/


/* J2C: Method-table-references *********************************************************/
#ifndef CmdConsumer_ifc_InspcMTBDEF
  #define CmdConsumer_ifc_InspcMTBDEF
  typedef struct CmdConsumer_ifc_InspcMTB_t { struct Mtbl_CmdConsumer_ifc_Inspc_t const* mtbl; struct CmdConsumer_ifc_Inspc_t* ref; } CmdConsumer_ifc_InspcMTB;
#endif

#ifndef InterProcessCommMTBDEF
  #define InterProcessCommMTBDEF
  typedef struct InterProcessCommMTB_t { struct Mtbl_InterProcessComm_t const* mtbl; struct InterProcessComm_t* ref; } InterProcessCommMTB;
#endif



const char sign_Mtbl_CmdExecuter_Inspc[] = "CmdExecuter_Inspc"; //to mark method tables of all implementations

typedef struct MtblDef_CmdExecuter_Inspc_t { Mtbl_CmdExecuter_Inspc mtbl; MtblHeadJc end; } MtblDef_CmdExecuter_Inspc;
 extern MtblDef_CmdExecuter_Inspc const mtblCmdExecuter_Inspc;

/*Constructor */
struct CmdExecuter_Inspc_t* ctorO_CmdExecuter_Inspc(ObjectJc* othis, struct CmdConsumer_ifc_Inspc_t* commandConsumer, ThCxt* _thCxt)
{ CmdExecuter_Inspc_s* ythis = (CmdExecuter_Inspc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_CmdExecuter_Inspc");
  checkConsistence_ObjectJc(othis, sizeof(CmdExecuter_Inspc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_CmdExecuter_Inspc_s, sizeof(CmdExecuter_Inspc_s));  
  //j2c: Initialize all class variables:
  {
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->datagramCmd.base.object), sizeof(ythis->datagramCmd), 0); 
      ctorO_Datagram_InspcDataExchangeAccess_Inspc(/*static*/&(ythis->datagramCmd.base.object), _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->infoCmd.base.object), sizeof(ythis->infoCmd), 0); 
      ctorO_Info_InspcDataExchangeAccess_Inspc(/*static*/&(ythis->infoCmd.base.object), _thCxt);
    ythis->maxNrofAnswerBytes = 1400;
    /*J2C: newArray*/
      init_ObjectJc(&ythis->bufferAnswerData.head.object, sizeof_ARRAYJc(int8, 1500), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->bufferAnswerData.head.object, 1500, sizeof(int8), null, 0);//J2C: constructor for embedded array;
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->myAnswerData.base.object), sizeof(ythis->myAnswerData), 0); 
      ctorO_iY_Datagram_InspcDataExchangeAccess_Inspc(/*static*/&(ythis->myAnswerData.base.object), (struct int8_Y_t*)(&( ythis->bufferAnswerData)), _thCxt);
  }
  { 
    
    ythis->cmdConsumer = commandConsumer;
  }
  STACKTRC_LEAVE;
  return ythis;
}


void completeConstruction_CmdExecuter_Inspc_F(CmdExecuter_Inspc_s* ythis, struct Comm_Inspc_t* outer, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("completeConstruction_CmdExecuter_Inspc_F");
  
  { 
    
    ythis->comm = outer;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void completeConstruction_CmdExecuter_Inspc(CmdExecuter_Inspc_s* ythis, struct Comm_Inspc_t* outer, ThCxt* _thCxt)
{ Mtbl_CmdExecuter_Inspc const* mtbl = (Mtbl_CmdExecuter_Inspc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_CmdExecuter_Inspc);
  mtbl->completeConstruction(ythis, outer, _thCxt);
}

bool executeCmd_CmdExecuter_Inspc_F(CmdExecuter_Inspc_s* ythis, int8_Y* buffer, int32 nrofBytesReceived, ThCxt* _thCxt)
{ Mtbl_CmdExecuter_Inspc const* mtthis = (Mtbl_CmdExecuter_Inspc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_CmdExecuter_Inspc);
  
  STACKTRC_TENTRY("executeCmd_CmdExecuter_Inspc_F");
  
  { 
    int32 nEntrant; 
    bool bOk = true; 
    int32 nrofBytesProcessed = 0; 
    int32 nrofBytesTelg = 0; 
    int32 partLength = 0; 
    int32 maxNrofBytesAnswerPart = 0; 
    int32 nrofBytesAnswerPart = 0; 
    CmdConsumer_ifc_InspcMTB cmdConsumerMtbl;   /**/
    
    
    assignData_iYi_ByteDataAccessJc_F(& ((ythis->datagramCmd).base.super), buffer, nrofBytesReceived, _thCxt);
    nEntrant = getEntrant_Datagram_InspcDataExchangeAccess_Inspc(& (ythis->datagramCmd), _thCxt);
    bOk = true;
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    ythis->nrofBytesAnswer = 0;
    SETMTBJc(cmdConsumerMtbl, ythis->cmdConsumer, CmdConsumer_ifc_Inspc);
    removeChildren_ByteDataAccessJc(& ((ythis->myAnswerData).base.super), _thCxt);//String test = myAnswerData.toString();
    
    if(nEntrant < 0) 
    { //:a negative number: It is an entrant, the telegram has the common head.
      
      int32 seqNr; 
      int32 encryption; 
      int32 nrofAnswer; 
      
      
      nrofBytesTelg = getLengthDatagram_Datagram_InspcDataExchangeAccess_Inspc(& (ythis->datagramCmd), _thCxt);
      nrofBytesProcessed = sizeofHead_Datagram_InspcDataExchangeAccess_Inspc;
      ythis->useTelgHead = true;//
      
      seqNr = getSeqnr_Datagram_InspcDataExchangeAccess_Inspc(& (ythis->datagramCmd), _thCxt);
      encryption = getEncryption_Datagram_InspcDataExchangeAccess_Inspc(& (ythis->datagramCmd), _thCxt);
      setHead_Datagram_InspcDataExchangeAccess_Inspc(& (ythis->myAnswerData), nEntrant, seqNr, encryption, _thCxt);
      ythis->nrofBytesAnswer = sizeofHead_Datagram_InspcDataExchangeAccess_Inspc;
      
      while(bOk && nrofBytesTelg >= (nrofBytesProcessed + sizeofHead_Info_InspcDataExchangeAccess_Inspc))
        { //:The next telg Part will be found after the processed part.
          
          
          addChild_ByteDataAccessJc(& ((ythis->datagramCmd).base.super), & ((ythis->infoCmd).base.super), _thCxt);
          partLength = getLenInfo_Info_InspcDataExchangeAccess_Inspc(& (ythis->infoCmd), _thCxt);
          if(partLength >= sizeofHead_Info_InspcDataExchangeAccess_Inspc && partLength <= (nrofBytesTelg - nrofBytesProcessed)) 
          { //:valid head data.
            
            bool lastPart; 
            
            
            lastPart = (nrofBytesProcessed + partLength) == nrofBytesTelg;
            maxNrofBytesAnswerPart = ythis->maxNrofAnswerBytes - ythis->nrofBytesAnswer;//execute:
            
            TRY
            { 
              
              nrofBytesAnswerPart = cmdConsumerMtbl.mtbl->executeMonitorCmd(&(( (cmdConsumerMtbl.ref))->base.object), & (ythis->infoCmd), & (ythis->myAnswerData), maxNrofBytesAnswerPart, _thCxt);
            }_TRY
            CATCH(IllegalArgumentException, exc)
            
              { 
                
                nrofBytesAnswerPart = 0;//TODO send a nack
                
              }
            CATCH(UnsupportedEncodingException, exc)
            
              { 
                
                nrofBytesAnswerPart = 0;//TODO send a nack
                
              }
            END_TRY
          }
          else 
          { //:invalid head data
            
            
            bOk = false;
            ythis->ctFailedTelgPart += 1;
          }
          nrofBytesProcessed += partLength;
        }
      nrofAnswer = getLengthTotal_ByteDataAccessJc(& ((ythis->myAnswerData).base.super), _thCxt);
      if(nrofAnswer > sizeofHead_Datagram_InspcDataExchangeAccess_Inspc) 
      { //:more as the head:
        
        
        mtthis->AnswerComm_ifc_Inspc.txAnswer(&((& ((* (ythis)).base.AnswerComm_ifc_Inspc))->base.object), nrofAnswer, true, _thCxt);
      }
    }
    else 
    { //:a positive number: The telegram hasn't the commmon head ,,DataExchangeTelgHead_Inspc,,, it is one command.
      //:It is the old style of communication, exclusively used until 2010-0216.
      
      int32 nrofAnswer; 
      
      
      ythis->useTelgHead = false;//dummy head with 2 empty information units.
      
      setHead_Datagram_InspcDataExchangeAccess_Inspc(& (ythis->myAnswerData), 0, 0x80000, 0, _thCxt);
      setLengthDatagram_Datagram_InspcDataExchangeAccess_Inspc(& (ythis->myAnswerData), 8, _thCxt);
      assignData_iYi_ByteDataAccessJc_F(& ((ythis->infoCmd).base.super), buffer, nrofBytesReceived, _thCxt);
      setBigEndian_ByteDataAccessJc_F(& ((ythis->infoCmd).base.super), true, _thCxt);
      maxNrofBytesAnswerPart = 1400;
      TRY
      { 
        
        nrofBytesAnswerPart = cmdConsumerMtbl.mtbl->executeMonitorCmd(&(( (cmdConsumerMtbl.ref))->base.object), & (ythis->infoCmd), & (ythis->myAnswerData), maxNrofBytesAnswerPart, _thCxt);
      }_TRY
      CATCH(IllegalArgumentException, exc)
      
        { 
          
          nrofBytesAnswerPart = 0;//TODO send a nack
          
        }
      CATCH(UnsupportedEncodingException, exc)
      
        { 
          
          nrofBytesAnswerPart = 0;//TODO send a nack
          
        }
      END_TRY
      nrofAnswer = getLengthTotal_ByteDataAccessJc(& ((ythis->myAnswerData).base.super), _thCxt);
      if(nrofAnswer > sizeofHead_Datagram_InspcDataExchangeAccess_Inspc) 
      { //:more as the head:
        
        
        mtthis->AnswerComm_ifc_Inspc.txAnswer(&((& ((* (ythis)).base.AnswerComm_ifc_Inspc))->base.object), nrofAnswer, true, _thCxt);
      }
    }
    { STACKTRC_LEAVE;
      return bOk;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool executeCmd_CmdExecuter_Inspc(CmdExecuter_Inspc_s* ythis, int8_Y* buffer, int32 nrofBytesReceived, ThCxt* _thCxt)
{ Mtbl_CmdExecuter_Inspc const* mtbl = (Mtbl_CmdExecuter_Inspc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_CmdExecuter_Inspc);
  return mtbl->executeCmd(ythis, buffer, nrofBytesReceived, _thCxt);
}


/**Send the current answer datagram as answer.*/
int32 txAnswer_ib_CmdExecuter_Inspc_F(ObjectJc* ithis, int32 nrofAnswerBytesPart, bool bLastTelg, ThCxt* _thCxt)
{ CmdExecuter_Inspc_s* ythis = (CmdExecuter_Inspc_s*)ithis;
  
  STACKTRC_TENTRY("txAnswer_ib_CmdExecuter_Inspc_F");
  
  { 
    int32 ret = 0; 
    
    
    /*no initvalue*/
    if(ythis->useTelgHead) 
    { 
      
      setLengthDatagram_Datagram_InspcDataExchangeAccess_Inspc(& (ythis->myAnswerData), nrofAnswerBytesPart, _thCxt);
    }//ythis->answer.nrofSentBytes = txAnswerRawData_Comm_Inspc(ythis, &ythis->answer.myAnswerData, ythis->answer.nrofAnswerBytes, &ythis->myAnswerAddress);
    
    ythis->nrofBytesAnswer = nrofAnswerBytesPart;
    if(!ythis->useTelgHead || ythis->nrofBytesAnswer > sizeofHead_Datagram_InspcDataExchangeAccess_Inspc) 
    { 
      InterProcessCommMTB ipcMtbl;   /**/
      
      
      if(bLastTelg && ythis->useTelgHead) 
      { 
        
        markAnswerNrLast_Datagram_InspcDataExchangeAccess_Inspc(& (ythis->myAnswerData), _thCxt);//mark as last telg
        
      }//send:
      
      SETMTBJc(ipcMtbl, ythis->comm->ipc, InterProcessComm);
      ythis->nrofSentBytes = ipcMtbl.mtbl->send(&(( (ipcMtbl.ref))->base.object), buildFromArrayX_MemC(&((struct int8_Y_t*)(&( ythis->bufferAnswerData)))->head) , ythis->nrofBytesAnswer, ythis->comm->myAnswerAddress);
      if(ythis->nrofSentBytes < 0) 
      { 
        
        if(ythis->comm->bEnablePrintfOnComm) 
        { 
          
          print_z_PrintStreamJc(REFJc(out_SystemJc), "\nError InterProcessComm ", _thCxt);
        }
        ret = -2;
      }
      else 
      { 
        
        if(bLastTelg) 
        { 
          
          ret = 0;
        }
        else 
        { //:prepare the next telg:
          
          
          incrAnswerNr_Datagram_InspcDataExchangeAccess_Inspc(& (ythis->myAnswerData), _thCxt);
          ythis->nrofBytesAnswer = sizeofHead_Datagram_InspcDataExchangeAccess_Inspc;
          ret = sizeofHead_Datagram_InspcDataExchangeAccess_Inspc - ythis->nrofBytesAnswer;
        }
      }
      /**/
      if(ythis->comm->bEnablePrintfOnComm) 
      { 
        
        print_z_PrintStreamJc(REFJc(out_SystemJc), "<", _thCxt);
      }
    }
    else 
    { //:nothing to sent.
      
      
      ret = sizeofHead_Datagram_InspcDataExchangeAccess_Inspc - ythis->nrofBytesAnswer;
    }
    { STACKTRC_LEAVE;
      return ret;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 txAnswer_ib_CmdExecuter_Inspc(ObjectJc* ithis, int32 nrofAnswerBytesPart, bool bLastTelg, ThCxt* _thCxt)
{ Mtbl_AnswerComm_ifc_Inspc const* mtbl = (Mtbl_AnswerComm_ifc_Inspc const*)getMtbl_ObjectJc(ithis, sign_Mtbl_AnswerComm_ifc_Inspc);
  return mtbl->txAnswer(ithis, nrofAnswerBytesPart, bLastTelg, _thCxt);
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_CmdExecuter_Inspc mtblCmdExecuter_Inspc = {
{ { sign_Mtbl_CmdExecuter_Inspc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((2 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, completeConstruction_CmdExecuter_Inspc_F //completeConstruction
, executeCmd_CmdExecuter_Inspc_F //executeCmd
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
  /**J2C: Mtbl-interfaces of CmdExecuter_Inspc: */
, { { sign_Mtbl_AnswerComm_ifc_Inspc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((1 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , txAnswer_ib_CmdExecuter_Inspc_F //txAnswer
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_CmdExecuter_Inspc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_CmdExecuter_Inspc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_CmdExecuter_Inspc, ObjectJc) }
   }
 };

 extern struct ClassJc_t const reflection_AnswerComm_ifc_Inspc_s;
 static struct ifcClasses_CmdExecuter_Inspc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }interfaces_CmdExecuter_Inspc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_AnswerComm_ifc_Inspc_s, OFFSET_Mtbl(Mtbl_CmdExecuter_Inspc, AnswerComm_ifc_Inspc) }
  }
};

extern struct ClassJc_t const reflection_CmdExecuter_Inspc_s;
extern struct ClassJc_t const reflection_CmdConsumer_ifc_Inspc_s;
extern struct ClassJc_t const reflection_Comm_Inspc_s;
extern struct ClassJc_t const reflection_Datagram_InspcDataExchangeAccess_Inspc_s;
extern struct ClassJc_t const reflection_Info_InspcDataExchangeAccess_Inspc_s;
const struct Reflection_Fields_CmdExecuter_Inspc_s_t
{ ObjectArrayJc head; FieldJc data[11];
} reflection_Fields_CmdExecuter_Inspc_s =
{ CONST_ObjectArrayJc(FieldJc, 11, OBJTYPE_FieldJc, null, &reflection_Fields_CmdExecuter_Inspc_s)
, {
     { "datagramCmd"
    , 0 //nrofArrayElements
    , &reflection_Datagram_InspcDataExchangeAccess_Inspc_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((CmdExecuter_Inspc_s*)(0x1000))->datagramCmd) - (int32)(CmdExecuter_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_CmdExecuter_Inspc_s
    }
   , { "infoCmd"
    , 0 //nrofArrayElements
    , &reflection_Info_InspcDataExchangeAccess_Inspc_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((CmdExecuter_Inspc_s*)(0x1000))->infoCmd) - (int32)(CmdExecuter_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_CmdExecuter_Inspc_s
    }
   , { "cmdConsumer"
    , 0 //nrofArrayElements
    , &reflection_CmdConsumer_ifc_Inspc_s
    , kReference_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((CmdExecuter_Inspc_s*)(0x1000))->cmdConsumer) - (int32)(CmdExecuter_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_CmdExecuter_Inspc_s
    }
   , { "maxNrofAnswerBytes"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((CmdExecuter_Inspc_s*)(0x1000))->maxNrofAnswerBytes) - (int32)(CmdExecuter_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_CmdExecuter_Inspc_s
    }
   , { "nrofBytesAnswer"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((CmdExecuter_Inspc_s*)(0x1000))->nrofBytesAnswer) - (int32)(CmdExecuter_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_CmdExecuter_Inspc_s
    }
   , { "nrofSentBytes"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((CmdExecuter_Inspc_s*)(0x1000))->nrofSentBytes) - (int32)(CmdExecuter_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_CmdExecuter_Inspc_s
    }
   , { "ctFailedTelgPart"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((CmdExecuter_Inspc_s*)(0x1000))->ctFailedTelgPart) - (int32)(CmdExecuter_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_CmdExecuter_Inspc_s
    }
   , { "comm"
    , 0 //nrofArrayElements
    , &reflection_Comm_Inspc_s
    , kReference_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((CmdExecuter_Inspc_s*)(0x1000))->comm) - (int32)(CmdExecuter_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_CmdExecuter_Inspc_s
    }
   , { "bufferAnswerData"
    , 1500 //nrofArrayElements
    , REFLECTION_int8
    , 1 << kBitPrimitiv_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |kEmbeddedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((CmdExecuter_Inspc_s*)(0x1000))->bufferAnswerData) - (int32)(CmdExecuter_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_CmdExecuter_Inspc_s
    }
   , { "myAnswerData"
    , 0 //nrofArrayElements
    , &reflection_Datagram_InspcDataExchangeAccess_Inspc_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((CmdExecuter_Inspc_s*)(0x1000))->myAnswerData) - (int32)(CmdExecuter_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_CmdExecuter_Inspc_s
    }
   , { "useTelgHead"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((CmdExecuter_Inspc_s*)(0x1000))->useTelgHead) - (int32)(CmdExecuter_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_CmdExecuter_Inspc_s
    }
} };
const ClassJc reflection_CmdExecuter_Inspc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "CmdExecuter_Inspc_s"
, (int16)((int32)(&((CmdExecuter_Inspc_s*)(0x1000))->base.object) - (int32)(CmdExecuter_Inspc_s*)0x1000)
, sizeof(CmdExecuter_Inspc_s)
, (FieldJcArray const*)&reflection_Fields_CmdExecuter_Inspc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_CmdExecuter_Inspc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_CmdExecuter_Inspc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblCmdExecuter_Inspc.mtbl.head
};
