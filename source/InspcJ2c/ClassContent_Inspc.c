/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "InspcJ2c/ClassContent_Inspc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "Fwc/fw_Exception.h"  //reference-association: ExceptionJc
#include "InspcJ2c/AnswerComm_ifc_Inspc.h"  //reference-association: answerCommMtbl
#include "InspcJ2c/SearchElement_Inspc.h"  //reference-association: SearchElement_Inspc_s
#include "Jc/PrintStreamJc.h"  //reference-association: out
#include "Jc/ReflectionJc.h"  //reference-association: MemAccessArrayDebugJc
#include "Jc/StringJc.h"  //embedded type in class data
#include "Jc/SystemJc.h"  //reference-association: SystemJc
#include "Jc/ReflMemAccessJc.h"  //embedded type in class data
#include "os_time.h"  //reference-association: OS_TimeStamp


/* J2C: Forward declaration of struct ***********************************************/
struct InspcDataInfo_Inspc_t;


/* J2C: Method-table-references *********************************************************/
#ifndef AnswerComm_ifc_InspcMTBDEF
  #define AnswerComm_ifc_InspcMTBDEF
  typedef struct AnswerComm_ifc_InspcMTB_t { struct Mtbl_AnswerComm_ifc_Inspc_t const* mtbl; struct AnswerComm_ifc_Inspc_t* ref; } AnswerComm_ifc_InspcMTB;
#endif


/**Implements the commands to get fields and values from data and sets values.
@author Hartmut Schorrig



*/


const char sign_Mtbl_ClassContent_Inspc[] = "ClassContent_Inspc"; //to mark method tables of all implementations

typedef struct MtblDef_ClassContent_Inspc_t { Mtbl_ClassContent_Inspc mtbl; MtblHeadJc end; } MtblDef_ClassContent_Inspc;
 extern MtblDef_ClassContent_Inspc const mtblClassContent_Inspc;

/*Constructor */
struct ClassContent_Inspc_t* ctorO_ClassContent_Inspc(ObjectJc* othis, ThCxt* _thCxt)
{ ClassContent_Inspc_s* ythis = (ClassContent_Inspc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_ClassContent_Inspc");
  checkConsistence_ObjectJc(othis, sizeof(ClassContent_Inspc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_ClassContent_Inspc_s, sizeof(ClassContent_Inspc_s));  
  //j2c: Initialize all class variables:
  {
    ythis->nrofAnswerBytes = 0;
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->answerItem.base.object), sizeof(ythis->answerItem), 0); 
      ctorO_Info_InspcDataExchangeAccess_Inspc(/*static*/&(ythis->answerItem.base.object), _thCxt);
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&ythis->uArray.sb.base.object, sizeof(StringBuilderJc) + 64 - 4, 0);
      ctorO_I_StringBuilderJc(&ythis->uArray.sb.base.object, 64, _thCxt);
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&ythis->uValue.sb.base.object, sizeof(StringBuilderJc) + 160 - 4, 0);
      ctorO_I_StringBuilderJc(&ythis->uValue.sb.base.object, 160, _thCxt);
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&ythis->uAnswer.sb.base.object, sizeof(StringBuilderJc) + 200 - 4, 0);
      ctorO_I_StringBuilderJc(&ythis->uAnswer.sb.base.object, 200, _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->test.base.object), sizeof(ythis->test), 0); 
      ctorO_InspcDataInfo_Inspc(/*static*/&(ythis->test.base.object), _thCxt);
    /*J2C: newArray*/
      init_ObjectJc(&ythis->registeredDataAccess.head.object, sizeof_ARRAYJc(InspcDataInfo_Inspc_s, 1024), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->registeredDataAccess.head.object, 1024, sizeof(InspcDataInfo_Inspc_s), null, 0);//J2C: constructor for embedded array;
  }
  { 
    
    ythis->debugRemoteAccess = getSingleton_MemAccessArrayDebugJc();
    { int32 ii; 
      for(ii = 0; ii < ythis->registeredDataAccess.head.length; ++ii)
        { 
          
          //J2C: constructor for embedded element-ObjectJc
          init_ObjectJc(&(ythis->registeredDataAccess.data[ii].base.object), sizeof(ythis->registeredDataAccess.data[ii]), 0); 
          ctorO_InspcDataInfo_Inspc(/*static*/&(ythis->registeredDataAccess.data[ii].base.object), _thCxt);
        }//TODO: Java2C-problem because different array annotations ...
        
    }//TODO: searchTrc should be used an onw instanc with idx!!!
    
  }
  STACKTRC_LEAVE;
  return ythis;
}



/**Sets the Object which is the root for all data.*/
void setRootObject_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct ObjectJc_t* rootObj, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setRootObject_ClassContent_Inspc");
  
  { 
    
    ythis->rootObj = rootObj;
  }
  STACKTRC_LEAVE;
}


/**sets all aggregations which are unknown on constuctor. */
void setAnswerComm_XX_ClassContent_Inspc(ObjectJc* ithis, struct AnswerComm_ifc_Inspc_t* answerComm, ThCxt* _thCxt)
{ ClassContent_Inspc_s* ythis = (ClassContent_Inspc_s*)ithis;
  
  STACKTRC_TENTRY("setAnswerComm_XX_ClassContent_Inspc");
  
  { 
    
    ythis->answerComm = answerComm;
  }
  STACKTRC_LEAVE;
}

int32 executeMonitorCmd_XXXXi_ClassContent_Inspc(ObjectJc* ithis, struct Info_InspcDataExchangeAccess_Inspc_t* cmd, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ ClassContent_Inspc_s* ythis = (ClassContent_Inspc_s*)ithis;
  
  STACKTRC_TENTRY("executeMonitorCmd_XXXXi_ClassContent_Inspc");
  
  { 
    int32 nOrder;   /*Switch to the cmd execution. */
    int32 nCmd; 
    
    
    nOrder = getOrder_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    nCmd = getCmd_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    ythis->nrofAnswerBytes = sizeofHead_Datagram_InspcDataExchangeAccess_Inspc;
    switch(nCmd){
      case kGetFields_Info_InspcDataExchangeAccess_Inspc: cmdGetFields_ClassContent_Inspc(ythis, cmd, answer, maxNrofAnswerBytes, _thCxt);break;
      case kGetValueByPath_Info_InspcDataExchangeAccess_Inspc: cmdGetValueByPath_ClassContent_Inspc(ythis, cmd, answer, maxNrofAnswerBytes, _thCxt);break;
      case kSetValueByPath_Info_InspcDataExchangeAccess_Inspc: cmdSetValueByPath_ClassContent_Inspc(ythis, cmd, answer, maxNrofAnswerBytes, _thCxt);break;
      case kGetAddressByPath_Info_InspcDataExchangeAccess_Inspc: cmdGetAddressByPath_ClassContent_Inspc(ythis, cmd, answer, maxNrofAnswerBytes, _thCxt);break;
      case kRegisterRepeat_Info_InspcDataExchangeAccess_Inspc: cmdRegisterRepeat_ClassContent_Inspc(ythis, cmd, answer, maxNrofAnswerBytes, _thCxt);break;
      case kGetValueByIndex_Info_InspcDataExchangeAccess_Inspc: cmdGetValueByIndex_ClassContent_Inspc(ythis, cmd, answer, maxNrofAnswerBytes, _thCxt);break;
      default: 
      { 
        
        /**Unknown command - answer is: kFailedCommand.*/
        ythis->nrofAnswerBytes += sizeofHead_Info_InspcDataExchangeAccess_Inspc;
        addChild_ByteDataAccessJc(& ((* (answer)).base.super), & ((ythis->answerItem).base.super), _thCxt);
        setInfoHead_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), sizeofHead_Info_InspcDataExchangeAccess_Inspc, kFailedCommand_Info_InspcDataExchangeAccess_Inspc, nOrder, _thCxt);
      }
    }/*switch*/;//switch
    
    { STACKTRC_LEAVE;
      return 0;
    }//nrofAnswerBytes;
    
  }
  STACKTRC_LEAVE;
}

int32 cmdGetFields_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct Info_InspcDataExchangeAccess_Inspc_t* cmd, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdGetFields_ClassContent_Inspc");
  
  { //:this.maxNrofAnswerBytes = maxNrofAnswerBytes;
    //:this.answerP = answer;
    
    int32 ixFieldStart = 0; 
    StringJc sVariablePath = NULL_StringJc;   /**/
    struct ClassJc_t const* clazz = null; 
    bool bQuestCollectionSize = 0; 
    int32 idxCollectionQuest = 0; 
    int32 nCmd = 0; 
    int32 nrofBytesCmd; 
    
    
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    ythis->nrofAnswerBytes = sizeofHead_Datagram_InspcDataExchangeAccess_Inspc;
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    nCmd = getCmd_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    nrofBytesCmd = getLenInfo_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    TRY
    { 
      
      sVariablePath = getChildString_ByteDataAccessJc(& ((* (cmd)).base.super), nrofBytesCmd - 8, _thCxt)/*J2C:non-persistent*/;
    }_TRY
    CATCH(UnsupportedEncodingException, exc)
    
      { 
        
        sVariablePath = z_StringJc("")/*J2C:non-persistent*/;
      }
    END_TRY
    ixFieldStart = 0;
    /**Check whether its a question to collection size: */
    idxCollectionQuest = indexOf_s_StringJc(sVariablePath, s0_StringJc("<?>"));
    if(idxCollectionQuest < 0) 
    { 
      
      idxCollectionQuest = indexOf_s_StringJc(sVariablePath, s0_StringJc("[?]"));
    }
    if(idxCollectionQuest >= 0) 
    { 
      
      bQuestCollectionSize = true;
      sVariablePath = substring_StringJc(sVariablePath, 0, idxCollectionQuest, _thCxt)/*J2C:non-persistent*/;
    }
    else 
    { 
      
      bQuestCollectionSize = false;
    }
    TRY
    { 
      struct FieldJc_t const* field = null; 
      MemSegmJc memObj = { 0 }; 
      int32 memSegment = 0; 
      bool found = 0; 
      int32 modifiers = 0; 
      
      
      /*no initvalue*/
      
      //J2C: constructor for embedded element
      INIT_MemSegmJc(/*static*/memObj);
      memSegment = 0;
      /*no initvalue*/
      /*no initvalue*/
      if(length_StringJc(sVariablePath) == 0 || equals_StringJc(sVariablePath, s0_StringJc("."))) 
      { 
        
        /**root path: */
        found = true;
        clazz = getClass_ClassJc(/*static*/ythis->rootObj);//the main class itself contains some pointer yet.
        
        field = null;
        bQuestCollectionSize = false;//not at root level
        
        modifiers = 0;
        setAddrSegm_MemSegmJc(memObj, ythis->rootObj, 0);
      }
      else 
      { 
        int32 idx = 0;   /*not the root path, search the obj started from static_cast<ObjectJc*>(this) //targets[0]: */
        int32 idxP[1];   /**/
        struct FieldJc_t const* fieldP[1];   /**/
        
        
        /*no initvalue*/
        
        
        /**Search the field in its object, the referenced instance of the field is requested: */
        set_MemSegmJc(memObj, searchObject_SearchElement_Inspc(/*static*/sVariablePath, ythis->rootObj, &fieldP[0], &idxP[0], _thCxt));
        idx = idxP[0];
        field = fieldP[0];
        found = obj_MemSegmJc(memObj) != null;
        if(found) 
        { 
          
          /**Field is found. */
          modifiers = getModifiers_FieldJc(field);
          if(isCollection_ModifierJc(/*static*/modifiers) && (idx < 0 || (isStaticArray_ModifierJc(/*static*/modifiers) && idx >= getStaticArraySize_FieldJc(field)))) 
          { 
            
            bQuestCollectionSize = true;
            clazz = null;
          }
          else 
          { 
            
            /**normal Object: */
            TRY
            { 
              struct ClassJc_t const* retClazz[1];   /*Gets the real class of the field. */
              
              
              
              getObjAndClass_FieldJc(field, memObj, &retClazz[0], "I", idx);//index -1: if it is a container, no class is returned
              
              bQuestCollectionSize = false;//the clazz may be null
              
              clazz = retClazz[0];
              found = (clazz != null);//getFields with non acknowledge answer if it is a null-reference.
              
            }_TRY
            CATCH(RuntimeException, exc)
            
              { 
                
                clazz = null;
                bQuestCollectionSize = true;//Exception, no clazz info, but it may be a collection size quest.
                
              }
            END_TRY
          }
        }
        else 
        { //:The requested field isn't found, faulty path
          
          
          clazz = null;
          modifiers = 0;
        }
      }
      if(found) 
      { 
        int32 nOrderNr;   /*The field describes the last found field, the obj is the associated instance*/
        
        
        nOrderNr = getOrder_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
        if(bQuestCollectionSize) 
        { //:the size of an container is requested:
          
          int32 nSize; 
          bool hasSubstructure; 
          StringJc name; 
          int32 lengthAnswer; 
          int32 lengthAnswer4; 
          StringJc sAnswer;   /**/
          
          
          nSize = getArraylength_FieldJc(field, memObj);
          hasSubstructure = (modifiers & mPrimitiv_Modifier_reflectJc) == 0;
          setLength_StringBuilderJc(& (ythis->uAnswer.sb), 0, _thCxt);
          
            ( append_C_StringBuilderJc(& (ythis->uAnswer.sb), '[', _thCxt)
            , append_I_StringBuilderJc(& (ythis->uAnswer.sb), nSize, _thCxt)
            , append_z_StringBuilderJc(& (ythis->uAnswer.sb), "]:", _thCxt)
            );
          name = z_StringJc(getName_FieldJc(field))/*J2C:non-persistent*/;
          append_s_StringBuilderJc(& (ythis->uAnswer.sb), name, _thCxt);
          if(hasSubstructure) 
          { 
            
            append_z_StringBuilderJc(& (ythis->uAnswer.sb), "...", _thCxt);
          }//the GUI will expand it to some nodes, one per element.
          
          lengthAnswer = length_StringBuilderJc(& (ythis->uAnswer.sb));
          lengthAnswer4 = (lengthAnswer + 3) / 4 * 4;
          if(lengthAnswer4 > lengthAnswer) 
          { 
            
            append_s_StringBuilderJc(& (ythis->uAnswer.sb), substring_StringJc(zI_StringJc("\0\0\0",3), 0, lengthAnswer4 - lengthAnswer, _thCxt), _thCxt);//fill rest with 0
            
          }//adds the answer to the telegram:
          
          addChild_ByteDataAccessJc(& ((* (answer)).base.super), & ((ythis->answerItem).base.super), _thCxt);
          setInfoHead_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), lengthAnswer4 + sizeofHead_Info_InspcDataExchangeAccess_Inspc, kAnswerFieldMethod_Info_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);
          sAnswer = toStringNonPersist_StringBuilderJc(& ((ythis->uAnswer.sb).base.object), _thCxt)/*J2C:non-persistent*/;
          addChildString_S_ByteDataAccessJc(& ((ythis->answerItem).base.super), sAnswer, _thCxt);//
          
        }
        else if(clazz != null) 
        { //:not a question to collection size, but real clazz found:
          //:show the fields:
          
          FieldJc_Y const* fields;   /*Gets the fields of the real class of the found reference-field.*/
          
          
          if(obj_MemSegmJc(memObj) != null && segment_MemSegmJc(/*static*/memObj) == 0) 
          { 
            struct ClassJc_t const* outerObj;   /*Check whether an outer class exists. */
            
            
            outerObj = getEnclosingClass_ClassJc(clazz);
            if(outerObj != null) 
            { 
              
              evaluateFieldGetFields_XXSFdiiii_ClassContent_Inspc(ythis, answer, s0_StringJc("_outer"), outerObj, 0, 0, nOrderNr, maxNrofAnswerBytes, _thCxt);
            }
          }
          fields = getDeclaredFields_ClassJc(clazz);
          if(fields != null) 
          { 
            int32 ii; 
            
            
            ii = ixFieldStart;
            if(ii < 0) 
            { 
              
              ii = 0;
            }
            { int32 ixField; 
              for(ixField = 0; ixField < fields->head.length; ++ixField)
                { 
                  
                  /**Generates one entry per field in the answer telegram. */
                  evaluateFieldGetFields_XXFdii_ClassContent_Inspc(ythis, answer, & (fields->data[ixField]), nOrderNr, maxNrofAnswerBytes, _thCxt);
                }
            }
          }
        }
      }
    }_TRY
    CATCH(Exception, exc)
    
      { 
        
        /**Unexpected ...*/
        println_z_PrintStreamJc(REFJc(out_SystemJc), "ClassContent-getFields - unexpected:", _thCxt);
        printStackTrace_ExceptionJc(exc, _thCxt);
      }
    END_TRY
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

void evaluateFieldGetFields_XXFdii_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, struct FieldJc_t const* field, int32 orderNr, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("evaluateFieldGetFields_XXFdii_ClassContent_Inspc");
  
  { //:FieldJc field = new FieldJc(fieldP);   //regard container types
    
    StringJc name; 
    struct ClassJc_t const* typeField; 
    int32 modifiers; 
    int32 staticArraySize; 
    
    
    name = z_StringJc(getName_FieldJc(field))/*J2C:non-persistent*/;
    typeField = getType_FieldJc(field);
    modifiers = getModifiers_FieldJc(field);
    staticArraySize = getStaticArraySize_FieldJc(field);
    evaluateFieldGetFields_XXSFdiiii_ClassContent_Inspc(ythis, answer, name, typeField, modifiers, staticArraySize, orderNr, maxNrofAnswerBytes, _thCxt);
  }
  STACKTRC_LEAVE;
}

void evaluateFieldGetFields_XXSFdiiii_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, StringJc name, struct ClassJc_t const* typeField, int32 modifiers, int32 staticArraySize, int32 orderNr, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("evaluateFieldGetFields_XXSFdiiii_ClassContent_Inspc");
  
  { 
    int32 modifContainertype; 
    bool hasSubstructure; 
    StringJc type; 
    int32 lengthName; 
    int32 lengthType; 
    
    
    modifContainertype = modifiers & m_Containertype_Modifier_reflectJc;
    hasSubstructure = (modifiers & mPrimitiv_Modifier_reflectJc) == 0 || (modifContainertype != 0);
    type = z_StringJc(typeField == null ? "unknown" : getName_ClassJc(typeField))/*J2C:non-persistent*/;
    lengthName = length_StringJc(name);
    lengthType = length_StringJc(type);
    setLength_StringBuilderJc(& (ythis->uArray.sb), 0, _thCxt);
    if(modifContainertype == kUML_LinkedList_Modifier_reflectJc) 
    { 
      
      append_z_StringBuilderJc(& (ythis->uArray.sb), "[?]:LinkedList", _thCxt);
    }
    else if(modifContainertype == kUML_ArrayList_Modifier_reflectJc) 
    { 
      
      append_z_StringBuilderJc(& (ythis->uArray.sb), "[?]:ArrayList", _thCxt);
    }
    else if(modifContainertype == kStaticArray_Modifier_reflectJc) 
    { 
      
      
        ( append_C_StringBuilderJc(& (ythis->uArray.sb), '[', _thCxt)
        , append_I_StringBuilderJc(& (ythis->uArray.sb), staticArraySize, _thCxt)
        , append_C_StringBuilderJc(& (ythis->uArray.sb), ']', _thCxt)
        );
    }
    else if(modifContainertype != 0) 
    { 
      
      append_z_StringBuilderJc(& (ythis->uArray.sb), "[?]:TODO-containerType", _thCxt);
    }
    
    { 
      int32 lengthArray; 
      int32 lengthValue; 
      int32 lengthAnswer;   /*calculate the length of the answer before writing. */
      int32 lengthAnswer4; 
      
      
      setLength_StringBuilderJc(& (ythis->uValue.sb), 0, _thCxt);
      lengthArray = length_StringBuilderJc(& (ythis->uArray.sb));
      lengthValue = length_StringBuilderJc(& (ythis->uValue.sb));
      lengthAnswer = sizeofHead_Info_InspcDataExchangeAccess_Inspc + lengthName + 1 + lengthType + lengthArray + lengthValue + (hasSubstructure ? 3 : 0);
      lengthAnswer4 = (lengthAnswer + 3) / 4 * 4;
      if((ythis->nrofAnswerBytes + lengthAnswer4) > maxNrofAnswerBytes) 
      { 
        AnswerComm_ifc_InspcMTB answerCommMtbl;   /*The information doesn't fit in the datagram: Send the last one and clear it.*/
        
        
        SETMTBJc(answerCommMtbl, ythis->answerComm, AnswerComm_ifc_Inspc);
        answerCommMtbl.mtbl->txAnswer(&(( (answerCommMtbl.ref))->base.object), ythis->nrofAnswerBytes, false, _thCxt);
        ythis->nrofAnswerBytes = sizeofHead_Datagram_InspcDataExchangeAccess_Inspc;
        removeChildren_ByteDataAccessJc(& ((* (answer)).base.super), _thCxt);
        incrAnswerNr_Datagram_InspcDataExchangeAccess_Inspc(answer, _thCxt);
      }
      
      { 
        StringJc sAnswerAdd;   /*sAnswer contains one entry for the telegram*/
        
        
        setLength_StringBuilderJc(& (ythis->uAnswer.sb), 0, _thCxt);
        append_s_StringBuilderJc(& (ythis->uAnswer.sb), name, _thCxt);
        append_u_StringBuilderJc(& (ythis->uAnswer.sb), & (ythis->uArray.sb), _thCxt);
        append_C_StringBuilderJc(& (ythis->uAnswer.sb), ':', _thCxt);
        append_s_StringBuilderJc(& (ythis->uAnswer.sb), type, _thCxt);
        if(lengthValue > 0) 
        { 
          
          append_C_StringBuilderJc(& (ythis->uAnswer.sb), '=', _thCxt);
          append_u_StringBuilderJc(& (ythis->uAnswer.sb), & (ythis->uValue.sb), _thCxt);
        }
        if(hasSubstructure) 
        { //:answerItem->data [answerPos] = '*';
          //:answerPos +=1;
          
          
          append_z_StringBuilderJc(& (ythis->uAnswer.sb), "...", _thCxt);
        }
        ASSERT(/*static*/length_StringBuilderJc(& (ythis->uAnswer.sb)) + sizeofHead_Info_InspcDataExchangeAccess_Inspc == lengthAnswer);//should be the same.
        
        if(lengthAnswer4 > lengthAnswer) 
        { 
          
          append_s_StringBuilderJc(& (ythis->uAnswer.sb), substring_StringJc(zI_StringJc("\0\0\0",3), 0, lengthAnswer4 - lengthAnswer, _thCxt), _thCxt);//fill rest with 0
          
        }
        addChild_ByteDataAccessJc(& ((* (answer)).base.super), & ((ythis->answerItem).base.super), _thCxt);
        sAnswerAdd = toStringNonPersist_StringBuilderJc(& ((ythis->uAnswer.sb).base.object), _thCxt)/*J2C:non-persistent*/;
        addChildString_S_ByteDataAccessJc(& ((ythis->answerItem).base.super), sAnswerAdd, _thCxt);//Prepare the answer item for this field:
        
        setInfoHead_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), lengthAnswer4, kAnswerFieldMethod_Info_InspcDataExchangeAccess_Inspc, orderNr, _thCxt);
        ythis->nrofAnswerBytes += lengthAnswer4;
      }
    }
  }
  STACKTRC_LEAVE;
}

int32 cmdGetValueByPath_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct Info_InspcDataExchangeAccess_Inspc_t* cmd, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdGetValueByPath_ClassContent_Inspc");
  
  { 
    int32 nrofBytesCmd; 
    StringJc sVariablePath;   /**/
    
    
    nrofBytesCmd = getLenInfo_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    sVariablePath = getChildString_ByteDataAccessJc(& ((* (cmd)).base.super), nrofBytesCmd - sizeofHead_Info_InspcDataExchangeAccess_Inspc, _thCxt)/*J2C:non-persistent*/;
    getSetValueByPath_ClassContent_Inspc(ythis, cmd, null, answer, sVariablePath, maxNrofAnswerBytes, _thCxt);
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

int32 cmdSetValueByPath_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct Info_InspcDataExchangeAccess_Inspc_t* cmd, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdSetValueByPath_ClassContent_Inspc");
  
  { 
    int32 nrofBytesCmd; 
    SetValue_InspcDataExchangeAccess_Inspc_s setValue = { 0 };   /**/
    int32 nrofBytesPath; 
    StringJc sVariablePath;   /**/
    
    
    nrofBytesCmd = getLenInfo_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    
    //J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(setValue.base.object), sizeof(setValue), 0); 
    ctorO_SetValue_InspcDataExchangeAccess_Inspc(/*static*/&(setValue.base.object), _thCxt);
    addChild_ByteDataAccessJc(& ((* (cmd)).base.super), & ((setValue).base.super), _thCxt);
    nrofBytesPath = nrofBytesCmd - sizeofHead_Info_InspcDataExchangeAccess_Inspc - sizeofElement_SetValue_InspcDataExchangeAccess_Inspc;
    sVariablePath = getChildString_ByteDataAccessJc(& ((* (cmd)).base.super), nrofBytesPath, _thCxt)/*J2C:non-persistent*/;
    getSetValueByPath_ClassContent_Inspc(ythis, cmd, & (setValue), answer, sVariablePath, maxNrofAnswerBytes, _thCxt);
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

int32 getSetValueByPath_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct Info_InspcDataExchangeAccess_Inspc_t* cmd, struct SetValue_InspcDataExchangeAccess_Inspc_t* accSetValue, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, StringJc sVariablePath, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getSetValueByPath_ClassContent_Inspc");
  
  { 
    int32 nOrderNr; 
    struct FieldJc_t const* theField = null;   /**/
    struct FieldJc_t const* theFieldP[1];   /**/
    MemSegmJc theObject = { 0 }; 
    int32 memSegment = 0;   /**/
    int32 idxOutput = 0; 
    int32 maxIdxOutput = 1200; 
    
    
    nOrderNr = getOrder_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    theField = null;
    
    
    //J2C: constructor for embedded element
    INIT_MemSegmJc(/*static*/theObject);
    memSegment = 0;
    idxOutput = 0;
    maxIdxOutput = 1200;
    TRY
    { 
      int32 idx = 0; 
      int32 idxP[1];   /**/
      
      
      /*no initvalue*/
      
      set_MemSegmJc(theObject, searchObject_SearchElement_Inspc(/*static*/sVariablePath, ythis->rootObj, &theFieldP[0], &idxP[0], _thCxt));
      theField = theFieldP[0];
      idx = idxP[0];
      if(obj_MemSegmJc(theObject) != null && theField != null) 
      { 
        int32 nBytesItem; 
        
        
        addChild_ByteDataAccessJc(& ((* (answer)).base.super), & ((ythis->answerItem).base.super), _thCxt);
        getSetValue_ClassContent_Inspc(ythis, theField, idx, theObject, accSetValue, maxNrofAnswerBytes, _thCxt);
        nBytesItem = getLength_ByteDataAccessJc(& ((ythis->answerItem).base.super), _thCxt);
        setInfoHead_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), nBytesItem, kAnswerValue_Info_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);
      }
    }_TRY
    CATCH(Exception, exc)
    
      { 
        
        /**Unexpected ...*/
        println_z_PrintStreamJc(REFJc(out_SystemJc), "ClassContent-getValueByPath - unexpected:", _thCxt);
        printStackTrace_ExceptionJc(exc, _thCxt);
      }
    END_TRY
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the value if accSetValue is not null, fills the {@link #answerItem} with the read value.*/
bool getSetValue_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct FieldJc_t const* theField, int32 idx, MemSegmJc theObject, struct SetValue_InspcDataExchangeAccess_Inspc_t* accSetValue, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getSetValue_ClassContent_Inspc");
  
  { 
    struct ClassJc_t const* type; 
    int32 modifier; 
    StringJc sValue = NULL_StringJc; 
    bool bOk = 0; 
    int32 actLenTelg; 
    int32 restLen; 
    int32 nType = 0; 
    
    
    type = getType_FieldJc(theField);
    modifier = getModifiers_FieldJc(theField);
    sValue = null_StringJc/*J2C:non-persistent*/;
    /*no initvalue*/
    actLenTelg = getLengthTotal_ByteDataAccessJc(& ((ythis->answerItem).base.super), _thCxt);
    restLen = maxNrofAnswerBytes - actLenTelg;
    /*no initvalue*/
    if(isPrimitive_ClassJc(type)) 
    { 
      StringJc sType; 
      char cType; 
      
      
      sType = z_StringJc(getName_ClassJc(type))/*J2C:non-persistent*/;
      cType = charAt_StringJc(sType, 0);
      switch(cType){
        case 'v': 
        case 'i': 
        { //:int
          
          
          bOk = restLen >= 5;
          if(bOk) 
          { 
            int32 value = 0; 
            
            
            /*no initvalue*/
            if(accSetValue != null) 
            { 
              int32 setValue; 
              
              
              setValue = getInt_SetValue_InspcDataExchangeAccess_Inspc(accSetValue, _thCxt);
              value = setInt_FieldJc(theField, theObject, setValue, "I", idx);
            }
            else 
            { 
              
              value = getInt_FieldJc(theField, theObject, "I", idx);
            }
            nType = kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int32_ClassJc;
            addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, nType, _thCxt);//Set the number of char-bytes in 1 byte
            
            addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 4, value, _thCxt);
            sValue = null_StringJc/*J2C:non-persistent*/;
          }
        }break;
        case 'c': 
        { //:int
          
          
          bOk = restLen >= 3;
          if(bOk) 
          { 
            char value = 0; 
            
            
            /*no initvalue*/
            if(accSetValue != null) 
            { 
              char setValue; 
              
              
              setValue = (char)getByte_SetValue_InspcDataExchangeAccess_Inspc(accSetValue, _thCxt);
              value = setChar_FieldJc(theField, theObject, setValue, "I", idx);
            }
            else 
            { 
              
              value = getChar_FieldJc(theField, theObject, "I", idx);
            }
            nType = kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc;
            addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, nType, _thCxt);//Set the number of char-bytes in 1 byte
            
            addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 2, (int16)value, _thCxt);
            sValue = null_StringJc/*J2C:non-persistent*/;
          }
        }break;
        case 's': 
        { //:short
          
          
          bOk = restLen >= 3;
          if(bOk) 
          { 
            int32 value = 0; 
            
            
            /*no initvalue*/
            if(accSetValue != null) 
            { 
              int16 setValue; 
              
              
              setValue = getShort_SetValue_InspcDataExchangeAccess_Inspc(accSetValue, _thCxt);
              value = setShort_FieldJc(theField, theObject, setValue, "I", idx);
            }
            else 
            { 
              
              value = getShort_FieldJc(theField, theObject, "I", idx);
            }
            nType = kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc;
            addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, nType, _thCxt);//Set the number of char-bytes in 1 byte
            
            addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 2, value, _thCxt);
            sValue = null_StringJc/*J2C:non-persistent*/;
          }
        }break;
        case 'l': 
        { //:long, it is int64
          
          
          bOk = restLen >= 5;//TODO 9
          
          if(bOk) 
          { 
            int64 value; 
            
            
            value = getInt64_FieldJc(theField, theObject, "I", idx);
            nType = kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int32_ClassJc;
            addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, nType, _thCxt);//64);  //Set the number of char-bytes in 1 byte
            
            addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 4, value, _thCxt);//8
            
            sValue = null_StringJc/*J2C:non-persistent*/;
          }
        }break;
        case 'f': 
        { //:float
          
          
          bOk = restLen >= 5;
          if(bOk) 
          { 
            float valuef = 0; 
            int32 value; 
            
            
            /*no initvalue*/
            if(accSetValue != null) 
            { 
              float setValue; 
              
              
              setValue = (float)getDouble_SetValue_InspcDataExchangeAccess_Inspc(accSetValue, _thCxt);
              valuef = setFloat_FieldJc(theField, theObject, setValue, "I", idx);
            }
            else 
            { 
              
              valuef = getFloat_FieldJc(theField, theObject, "I", idx);
            }
            value = floatToRawIntBits_FloatJc(/*static*/valuef);
            nType = kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_float_ClassJc;
            addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, nType, _thCxt);//Set the number of char-bytes in 1 byte
            
            addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 4, value, _thCxt);
            sValue = null_StringJc/*J2C:non-persistent*/;
          }
        }break;
        case 'd': 
        { //:double  TODO 'd'
          
          
          bOk = restLen >= 9;
          if(bOk) 
          { 
            double fvalue = 0; 
            bool fixme = true; 
            
            
            /*no initvalue*/
            if(accSetValue != null) 
            { 
              double setValue; 
              
              
              setValue = getDouble_SetValue_InspcDataExchangeAccess_Inspc(accSetValue, _thCxt);
              fvalue = setDouble_FieldJc(theField, theObject, setValue, "I", idx);
            }
            else 
            { 
              
              fvalue = getDouble_FieldJc(theField, theObject, "I", idx);
            }
            fixme = true;
            if(fixme) 
            { 
              int32 value; 
              
              
              value = floatToRawIntBits_FloatJc(/*static*/(float)fvalue);
              nType = kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_float_ClassJc;
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, nType, _thCxt);//Set the number of char-bytes in 1 byte
              
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 4, value, _thCxt);
            }
            else 
            { 
              int64 value; 
              
              
              value = doubleToLongBits_DoubleJc(/*static*/fvalue);
              nType = kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_double_ClassJc;
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, nType, _thCxt);//Set the number of char-bytes in 1 byte
              
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 8, value, _thCxt);
            }
            sValue = null_StringJc/*J2C:non-persistent*/;
          }
        }break;
        case 'b': switch(charAt_StringJc(sType, 1)){
          case 'o': 
          { //:boolean
            
            
            bOk = restLen >= 3;
            if(bOk) 
            { 
              bool value = 0; 
              int32 value1; 
              
              
              /*no initvalue*/
              if(accSetValue != null) 
              { 
                bool setValue; 
                
                
                setValue = getShort_SetValue_InspcDataExchangeAccess_Inspc(accSetValue, _thCxt) != 0;
                value = setBoolean_FieldJc(theField, theObject, setValue, "I", idx);
              }
              else 
              { 
                
                value = getBoolean_FieldJc(theField, theObject, "I", idx);
              }
              value1 = value ? 1 : 0;
              nType = kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc;
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, nType, _thCxt);//Set the number of char-bytes in 1 byte
              
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 2, value1, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;
            }
          }break;
          case 'y': 
          { //:byte
            
            
            bOk = restLen >= 3;
            if(bOk) 
            { 
              int16 value; 
              
              
              value = getByte_FieldJc(theField, theObject, "I", idx);
              nType = kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc;
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, nType, _thCxt);//Set the number of char-bytes in 1 byte
              
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 2, value, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;
            }
          }break;
          case 'i': 
          { //:bitfield
            
            
            bOk = restLen >= 3;
            if(bOk) 
            { 
              int16 value = 0; 
              
              
              /*no initvalue*/
              if(accSetValue != null) 
              { 
                int16 setValue; 
                
                
                setValue = getShort_SetValue_InspcDataExchangeAccess_Inspc(accSetValue, _thCxt);
                value = setBitfield_FieldJc(theField, theObject, setValue, "I", idx);
              }
              else 
              { 
                
                value = getBitfield_FieldJc(theField, theObject, "I", idx);
              }
              nType = kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc;
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, nType, _thCxt);//Set the number of char-bytes in 1 byte
              
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 2, value, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;
            }
          }break;
          default: 
          { 
            
            bOk = restLen >= 1;
            if(bOk) 
            { 
              
              nType = kTypeNoValue_InspcDataExchangeAccess_Inspc;
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, nType, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;//"?unknownPrimitiveType?";
              
            }
          }
        }/*switch*/;break;
        default: 
        { 
          
          bOk = restLen >= 1;
          if(bOk) 
          { 
            
            nType = kTypeNoValue_InspcDataExchangeAccess_Inspc;
            addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, nType, _thCxt);
            sValue = null_StringJc/*J2C:non-persistent*/;//"?unknownPrimType?";
            
          }
        }
      }/*switch*/;//switch
      
    }
    else 
    { //:it is a complex type, not a numeric.
      
      StringJc _persistring2_1=NULL_StringJc; //J2C: temporary persistent Strings
      
      sValue = _persistring2_1 = persist_StringJc(getString_FieldJc(theField, theObject, "I", idx))/*J2C:non-persistent*/;
      bOk = true;
      activateGC_ObjectJc(PTR_StringJc(_persistring2_1), null, _thCxt);
    }
    if(sValue.ptr__!= null) 
    { 
      int32 zValue; 
      
      
      zValue = length_StringJc(sValue);
      if(zValue > maxNrOfChars_InspcDataExchangeAccess_Inspc) 
      { 
        
        zValue = maxNrOfChars_InspcDataExchangeAccess_Inspc;
        sValue = substring_StringJc(sValue, 0, zValue, _thCxt)/*J2C:non-persistent*/;
      }
      bOk = restLen >= zValue + 1;
      if(bOk) 
      { 
        int32 zInfo; 
        
        
        zInfo = zValue + 1 + sizeofHead_Info_InspcDataExchangeAccess_Inspc;
        nType = zValue;
        addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, nType, _thCxt);//Set the number of char-bytes in 1 byte
        
        addChildString_S_ByteDataAccessJc(& ((ythis->answerItem).base.super), sValue, _thCxt);//Set the character String after them.
        
      }
    }
    /*MemSegmJc adr;*/
    { STACKTRC_LEAVE;
      return bOk;
    }
  }
  STACKTRC_LEAVE;
}

int32 cmdGetAddressByPath_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct Info_InspcDataExchangeAccess_Inspc_t* cmd, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdGetAddressByPath_ClassContent_Inspc");
  
  { 
    int32 nrofBytesCmd; 
    int32 nrofBytesPath; 
    StringJc sVariablePath;   /**/
    int32 nOrderNr; 
    struct FieldJc_t const* theField = null;   /**/
    struct FieldJc_t const* theFieldP[1];   /**/
    MemSegmJc theObject = { 0 }; 
    StringJc sValue = NULL_StringJc;   /**/
    int32 memSegment = 0; 
    int32 idxOutput = 0; 
    int32 maxIdxOutput = 1200; 
    
    
    nrofBytesCmd = getLenInfo_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    nrofBytesPath = nrofBytesCmd - sizeofHead_Info_InspcDataExchangeAccess_Inspc;
    sVariablePath = getChildString_ByteDataAccessJc(& ((* (cmd)).base.super), nrofBytesPath, _thCxt)/*J2C:non-persistent*/;
    nOrderNr = getOrder_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    theField = null;
    
    
    //J2C: constructor for embedded element
    INIT_MemSegmJc(/*static*/theObject);
    /*no initvalue*/
    memSegment = 0;
    idxOutput = 0;
    maxIdxOutput = 1200;
    TRY
    { 
      int32 idx = 0; 
      int32 idxP[1];   /**/
      
      
      /*no initvalue*/
      
      set_MemSegmJc(theObject, searchObject_SearchElement_Inspc(/*static*/sVariablePath, ythis->rootObj, &theFieldP[0], &idxP[0], _thCxt));
      theField = theFieldP[0];
      idx = idxP[0];
      addChild_ByteDataAccessJc(& ((* (answer)).base.super), & ((ythis->answerItem).base.super), _thCxt);
      setInfoHead_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), 0, kAnswerValue_Info_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);
      if(obj_MemSegmJc(theObject) != null && theField != null) 
      { 
        int32 addr; 
        
        
        addr = getMemoryIdent_FieldJc(theField, theObject, "I", idxP[0]);
        addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, kReferenceAddr_InspcDataExchangeAccess_Inspc, _thCxt);//Set the number of char-bytes in 1 byte
        
        addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 4, addr, _thCxt);
      }
      else 
      { 
        
        setCmd_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), kFailedValue_Info_InspcDataExchangeAccess_Inspc, _thCxt);
      }
      setLength_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), getLength_ByteDataAccessJc(& ((ythis->answerItem).base.super), _thCxt), _thCxt);//the length of the answerItems in byte.
      
    }_TRY
    CATCH(Exception, exc)
    
      { 
        
        /**Unexpected ...*/
        println_z_PrintStreamJc(REFJc(out_SystemJc), "ClassContent-getValueByPath - unexpected:", _thCxt);
        printStackTrace_ExceptionJc(exc, _thCxt);
      }
    END_TRY
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

int32 cmdRegisterRepeat_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct Info_InspcDataExchangeAccess_Inspc_t* cmd, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdRegisterRepeat_ClassContent_Inspc");
  
  { 
    int32 nrofBytesCmd; 
    int32 nrofBytesPath; 
    StringJc sVariablePath;   /**/
    int32 nOrderNr; 
    struct FieldJc_t const* theField = null;   /**/
    struct FieldJc_t const* theFieldP[1];   /**/
    MemSegmJc theObject = { 0 }; 
    StringJc sValue = NULL_StringJc;   /**/
    int32 memSegment = 0; 
    int32 idxOutput = 0; 
    int32 maxIdxOutput = 1200; 
    
    
    nrofBytesCmd = getLenInfo_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    nrofBytesPath = nrofBytesCmd - sizeofHead_Info_InspcDataExchangeAccess_Inspc;
    sVariablePath = getChildString_ByteDataAccessJc(& ((* (cmd)).base.super), nrofBytesPath, _thCxt)/*J2C:non-persistent*/;
    nOrderNr = getOrder_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    theField = null;
    
    
    //J2C: constructor for embedded element
    INIT_MemSegmJc(/*static*/theObject);
    /*no initvalue*/
    memSegment = 0;
    idxOutput = 0;
    maxIdxOutput = 1200;
    TRY
    { 
      int32 idx = 0; 
      int32 idxP[1];   /**/
      
      
      /*no initvalue*/
      
      set_MemSegmJc(theObject, searchObject_SearchElement_Inspc(/*static*/sVariablePath, ythis->rootObj, &theFieldP[0], &idxP[0], _thCxt));
      theField = theFieldP[0];
      idx = idxP[0];
      addChild_ByteDataAccessJc(& ((* (answer)).base.super), & ((ythis->answerItem).base.super), _thCxt);
      setInfoHead_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), 0, kAnswerRegisterRepeat_Info_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);
      if(obj_MemSegmJc(theObject) != null && theField != null) 
      { 
        struct ClassJc_t const* type; 
        int32 modifier; 
        int32 addr; 
        int32 ixReg = 0; 
        struct InspcDataInfo_Inspc_t* freeOrder = null; 
        int32 currentTime; 
        int32 ixRegLast = 0;   /*Search a free position in the static array: */
        int32 diffLast = 0; 
        int32 ixAnswer; 
        
        
        type = getType_FieldJc(theField);
        modifier = getModifiers_FieldJc(theField);
        addr = getMemoryIdent_FieldJc(theField, theObject, "I", idxP[0]);
        ixReg = 0;
        freeOrder = null;
        currentTime = os_getSeconds();
        ixRegLast = 0;
        diffLast = 0;
        
        while(freeOrder == null && ixReg < ythis->registeredDataAccess.head.length)
          { 
            struct InspcDataInfo_Inspc_t* order; 
            int32 lastUsed; 
            
            
            order = & (ythis->registeredDataAccess.data[ixReg]);
            lastUsed = currentTime - order->lastUsed;
            if((lastUsed) > 3600) 
            { 
              
              freeOrder = order;
            }
            else 
            { 
              
              if(lastUsed > diffLast) 
              { 
                
                diffLast = lastUsed;
                ixRegLast = ixReg;
              }
              ixReg += 1;
            }
          }
        if(freeOrder == null) 
        { //:no registerItem found which is older than 1 our:
          
          
          ixReg = ixRegLast;//get the oldest one.
          
          freeOrder = & (ythis->registeredDataAccess.data[ixReg]);
        }
        freeOrder->lastUsed = currentTime;
        freeOrder->addrValue = theField;
        set_MemSegmJc(freeOrder->addr, theObject);//freeOrder.timeout_millisec = 5000;  //after 5 seconds, forget it.
        
        freeOrder->check += 1;//change it to detect old requests at same index.
        
        ixAnswer = ixReg | (freeOrder->check << 12);
        addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 4, ixAnswer, _thCxt);
        getSetValue_ClassContent_Inspc(ythis, theField, idx, theObject, null, maxNrofAnswerBytes, _thCxt);
        setLength_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), getLength_ByteDataAccessJc(& ((ythis->answerItem).base.super), _thCxt), _thCxt);//the length of the answerItems in byte.
        
      }
      else 
      { 
        
        setCmd_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), kFailedPath_Info_InspcDataExchangeAccess_Inspc, _thCxt);
      }
      setLength_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), getLength_ByteDataAccessJc(& ((ythis->answerItem).base.super), _thCxt), _thCxt);//the length of the answerItems in byte.
      
    }_TRY
    CATCH(Exception, exc)
    
      { 
        
        /**Unexpected ...*/
        println_z_PrintStreamJc(REFJc(out_SystemJc), "ClassContent-getValueByPath - unexpected:", _thCxt);
        printStackTrace_ExceptionJc(exc, _thCxt);
      }
    END_TRY
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

int32 cmdGetValueByIndex_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct Info_InspcDataExchangeAccess_Inspc_t* cmd, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdGetValueByIndex_ClassContent_Inspc");
  
  { 
    int32 nrofVariable; 
    
    
    nrofVariable = (getLenInfo_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt) - sizeofHead_Info_InspcDataExchangeAccess_Inspc) / 4;
    TRY
    { 
      int32 idxOutput = 0; 
      int32 idx = 0; 
      bool bOk = true; 
      int32 nOrderNr; 
      int32 nBytesItem; 
      
      
      idxOutput = 0;
      /*no initvalue*/
      bOk = true;
      nOrderNr = getOrder_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
      addChild_ByteDataAccessJc(& ((* (answer)).base.super), & ((ythis->answerItem).base.super), _thCxt);///
      
      addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 4, 0, _thCxt);//TODO more as one telg.
      
      
      while(sufficingBytesForNextChild_ByteDataAccessJc(& ((* (cmd)).base.super), 4, _thCxt))
        { //:for(idx = 0; bOk && idx < nrofVariable; idx++)
          
          int32 idxReq; 
          int32 idxDataAccess; 
          int32 check; 
          struct InspcDataInfo_Inspc_t* order; 
          
          
          idxReq = (int32)getChildInteger_ByteDataAccessJc(& ((* (cmd)).base.super), 4, _thCxt);
          idxDataAccess = idxReq & 0xfff;
          check = (idxReq >> 12) & 0xfffff;
          order = & (ythis->registeredDataAccess.data[idxDataAccess]);
          if(check == order->check && order->addrValue != null) 
          { 
            
            getSetValue_ClassContent_Inspc(ythis, order->addrValue, 0, order->addr, null, maxNrofAnswerBytes, _thCxt);
          }
          else 
          { //:The ident is faulty. Any ident request should have its answer.
            
            
            addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, kTypeNoValue_InspcDataExchangeAccess_Inspc, _thCxt);
          }
        }//while
        
      nBytesItem = getLength_ByteDataAccessJc(& ((ythis->answerItem).base.super), _thCxt);
      setInfoHead_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), nBytesItem, kAnswerValueByIndex_Info_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);
    }_TRY
    CATCH(IllegalAccessException, exc)
    
      { 
        
        println_z_PrintStreamJc(REFJc(err_SystemJc), "ClassContent - cmdGetValueByIndex; Unexpected IllegalAccessException", _thCxt);
      }
    END_TRY
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

void stop_ClassContent_Inspc(ClassContent_Inspc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("stop_ClassContent_Inspc");
  
  { 
    
    
  }
  STACKTRC_LEAVE;
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_ClassContent_Inspc mtblClassContent_Inspc = {
{ { sign_Mtbl_ClassContent_Inspc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
  /**J2C: Mtbl-interfaces of ClassContent_Inspc: */
, { { sign_Mtbl_CmdConsumer_ifc_Inspc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((2 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , executeMonitorCmd_XXXXi_ClassContent_Inspc //executeMonitorCmd
  , setAnswerComm_XX_ClassContent_Inspc //setAnswerComm
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern_C struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_ClassContent_Inspc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_ClassContent_Inspc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_ClassContent_Inspc, ObjectJc) }
   }
 };

 extern_C struct ClassJc_t const reflection_CmdConsumer_ifc_Inspc_s;
 static struct ifcClasses_ClassContent_Inspc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }interfaces_ClassContent_Inspc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_CmdConsumer_ifc_Inspc_s, OFFSET_Mtbl(Mtbl_ClassContent_Inspc, CmdConsumer_ifc_Inspc) }
  }
};

extern_C struct ClassJc_t const reflection_ClassContent_Inspc_s;
extern_C struct ClassJc_t const reflection_AnswerComm_ifc_Inspc_s;
extern_C struct ClassJc_t const reflection_Info_InspcDataExchangeAccess_Inspc_s;
extern_C struct ClassJc_t const reflection_InspcDataInfo_Inspc_s;
extern_C struct ClassJc_t const reflection_MemAccessArrayDebugJc;
extern_C struct ClassJc_t const reflection_ObjectJc;
extern_C struct ClassJc_t const reflection_StringBuilderJc;
const struct Reflection_Fields_ClassContent_Inspc_s_t
{ ObjectArrayJc head; FieldJc data[10];
} reflection_Fields_ClassContent_Inspc_s =
{ CONST_ObjectArrayJc(FieldJc, 10, OBJTYPE_FieldJc, null, &reflection_Fields_ClassContent_Inspc_s)
, {
     { "rootObj"
    , 0 //nrofArrayElements
    , &reflection_ObjectJc
    , kReference_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->rootObj) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "answerComm"
    , 0 //nrofArrayElements
    , &reflection_AnswerComm_ifc_Inspc_s
    , kReference_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->answerComm) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "debugRemoteAccess"
    , 0 //nrofArrayElements
    , &reflection_MemAccessArrayDebugJc
    , kReference_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->debugRemoteAccess) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "nrofAnswerBytes"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->nrofAnswerBytes) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "answerItem"
    , 0 //nrofArrayElements
    , &reflection_Info_InspcDataExchangeAccess_Inspc_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->answerItem) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "uArray"
    , 0 //nrofArrayElements
    , &reflection_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->uArray) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "uValue"
    , 0 //nrofArrayElements
    , &reflection_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->uValue) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "uAnswer"
    , 0 //nrofArrayElements
    , &reflection_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->uAnswer) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "test"
    , 0 //nrofArrayElements
    , &reflection_InspcDataInfo_Inspc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->test) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "registeredDataAccess"
    , 1024 //nrofArrayElements
    , &reflection_InspcDataInfo_Inspc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |kEmbeddedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->registeredDataAccess) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
} };
const ClassJc reflection_ClassContent_Inspc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "ClassContent_Inspc_s"
, (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->base.object) - (int32)(ClassContent_Inspc_s*)0x1000)
, sizeof(ClassContent_Inspc_s)
, (FieldJcArray const*)&reflection_Fields_ClassContent_Inspc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_ClassContent_Inspc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_ClassContent_Inspc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblClassContent_Inspc.mtbl.head
};
