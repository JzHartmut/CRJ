/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "InspcJ2c/ClassContent_Inspc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "Fwc/fw_Exception.h"  //reference-association: ExceptionJc
#include "InspcJ2c/AnswerComm_ifc_Inspc.h"  //reference-association: answerCommMtbl
#include "InspcJ2c/SearchElement_Inspc.h"  //reference-association: SearchElement_Inspc_s
#include "Jc/FileIoJc.h"  //reference-association: out
#include "Jc/ReflectionJc.h"  //reference-association: ClassJc
#include "Jc/StringJc.h"  //embedded type in class data
#include "Jc/SystemJc.h"  //reference-association: SystemJc
#include "Jc/ReflMemAccessJc.h"  //embedded type in class data


/* J2C: Forward declaration of struct ***********************************************/


/* J2C: Method-table-references *********************************************************/
#ifndef AnswerComm_ifc_InspcMTBDEF
  #define AnswerComm_ifc_InspcMTBDEF
  typedef struct AnswerComm_ifc_InspcMTB_t { struct Mtbl_AnswerComm_ifc_Inspc_t const* mtbl; struct AnswerComm_ifc_Inspc_t* ref; } AnswerComm_ifc_InspcMTB;
#endif


/**Implements the commands to get fields and values from data and sets values.
@author Hartmut Schorrig



*/


const char sign_Mtbl_ClassContent_Inspc[] = "ClassContent_Inspc"; //to mark method tables of all implementations

typedef struct MtblDef_ClassContent_Inspc_t { Mtbl_ClassContent_Inspc mtbl; MtblHeadJc end; } MtblDef_ClassContent_Inspc;
 extern MtblDef_ClassContent_Inspc const mtblClassContent_Inspc;

/*Constructor */
struct ClassContent_Inspc_t* ctorO_ClassContent_Inspc(ObjectJc* othis, ThCxt* _thCxt)
{ ClassContent_Inspc_s* ythis = (ClassContent_Inspc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_ClassContent_Inspc");
  checkConsistence_ObjectJc(othis, sizeof(ClassContent_Inspc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_ClassContent_Inspc_s, sizeof(ClassContent_Inspc_s));  
  //j2c: Initialize all class variables:
  {
    ythis->nrofAnswerBytes = 0;
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->answerItem.base.object), sizeof(ythis->answerItem), 0); 
      ctorO_Info_InspcDataExchangeAccess_Inspc(/*static*/&(ythis->answerItem.base.object), _thCxt);
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&ythis->uArray.sb.base.object, sizeof(StringBuilderJc) + 64 - 4, 0);
      ctorO_I_StringBuilderJc(&ythis->uArray.sb.base.object, 64, _thCxt);
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&ythis->uValue.sb.base.object, sizeof(StringBuilderJc) + 160 - 4, 0);
      ctorO_I_StringBuilderJc(&ythis->uValue.sb.base.object, 160, _thCxt);
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&ythis->uAnswer.sb.base.object, sizeof(StringBuilderJc) + 200 - 4, 0);
      ctorO_I_StringBuilderJc(&ythis->uAnswer.sb.base.object, 200, _thCxt);
  }
  { 
    
    
  }
  STACKTRC_LEAVE;
  return ythis;
}



/**Sets the Object which is the root for all data.*/
void setRootObject_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct ObjectJc_t* rootObj, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setRootObject_ClassContent_Inspc");
  
  { 
    
    ythis->rootObj = rootObj;
  }
  STACKTRC_LEAVE;
}


/**sets all aggregations which are unknown on constuctor. */
void setAnswerComm_XX_ClassContent_Inspc(ObjectJc* ithis, struct AnswerComm_ifc_Inspc_t* answerComm, ThCxt* _thCxt)
{ ClassContent_Inspc_s* ythis = (ClassContent_Inspc_s*)ithis;
  
  STACKTRC_TENTRY("setAnswerComm_XX_ClassContent_Inspc");
  
  { 
    
    ythis->answerComm = answerComm;
  }
  STACKTRC_LEAVE;
}

int32 executeMonitorCmd_XXXXi_ClassContent_Inspc(ObjectJc* ithis, struct Info_InspcDataExchangeAccess_Inspc_t* cmd, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ ClassContent_Inspc_s* ythis = (ClassContent_Inspc_s*)ithis;
  
  STACKTRC_TENTRY("executeMonitorCmd_XXXXi_ClassContent_Inspc");
  
  { 
    int32 nOrder;   /*Switch to the cmd execution. */
    int32 nCmd; 
    
    
    nOrder = getOrder_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    nCmd = getCmd_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    ythis->nrofAnswerBytes = sizeofHead_Datagram_InspcDataExchangeAccess_Inspc;
    switch(nCmd){
      case kGetFields_Info_InspcDataExchangeAccess_Inspc: cmdGetFields_ClassContent_Inspc(ythis, cmd, answer, maxNrofAnswerBytes, _thCxt);break;
      case kGetValueByPath_Info_InspcDataExchangeAccess_Inspc: cmdGetValueByPath_ClassContent_Inspc(ythis, cmd, answer, maxNrofAnswerBytes, _thCxt);break;
      case kSetValueByPath_Info_InspcDataExchangeAccess_Inspc: cmdSetValueByPath_ClassContent_Inspc(ythis, cmd, answer, maxNrofAnswerBytes, _thCxt);break;
      default: 
      { 
        
        /**Unknown command - answer is: kFailedCommand.*/
        ythis->nrofAnswerBytes += sizeofHead_Info_InspcDataExchangeAccess_Inspc;
        addChild_ByteDataAccessJc(& ((* (answer)).base.super), & ((ythis->answerItem).base.super), _thCxt);
        setInfoHead_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), sizeofHead_Info_InspcDataExchangeAccess_Inspc, kFailedCommand_Info_InspcDataExchangeAccess_Inspc, nOrder, _thCxt);
      }
    }/*switch*/;//switch
    
    { STACKTRC_LEAVE;
      return 0;
    }//nrofAnswerBytes;
    
  }
  STACKTRC_LEAVE;
}

int32 cmdGetFields_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct Info_InspcDataExchangeAccess_Inspc_t* cmd, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdGetFields_ClassContent_Inspc");
  
  { 
    int32 ixFieldStart = 0; 
    StringJc sVariablePath = NULL_StringJc;   /**/
    struct ClassJc_t const* clazz = null; 
    bool bQuestCollectionSize = 0; 
    int32 idxCollectionQuest = 0; 
    int32 nCmd = 0; 
    int32 nrofBytesCmd; 
    
    
    ythis->maxNrofAnswerBytes = maxNrofAnswerBytes;
    ythis->answer = answer;
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    ythis->nrofAnswerBytes = sizeofHead_Datagram_InspcDataExchangeAccess_Inspc;
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    nCmd = getCmd_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    nrofBytesCmd = getLenInfo_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    TRY
    { 
      
      sVariablePath = getChildString_ByteDataAccessJc(& ((* (cmd)).base.super), nrofBytesCmd - 8, _thCxt)/*J2C:non-persistent*/;
    }_TRY
    CATCH(UnsupportedEncodingException, exc)
    
      { 
        
        sVariablePath = z_StringJc("")/*J2C:non-persistent*/;
      }
    END_TRY
    ixFieldStart = 0;
    /**Check whether its a question to collection size: */
    idxCollectionQuest = indexOf_s_StringJc(sVariablePath, s0_StringJc("<?>"));
    if(idxCollectionQuest < 0) 
    { 
      
      idxCollectionQuest = indexOf_s_StringJc(sVariablePath, s0_StringJc("[?]"));
    }
    if(idxCollectionQuest >= 0) 
    { 
      
      bQuestCollectionSize = true;
      sVariablePath = substring_StringJc(sVariablePath, 0, idxCollectionQuest, _thCxt)/*J2C:non-persistent*/;
    }
    else 
    { 
      
      bQuestCollectionSize = false;
    }
    TRY
    { 
      struct FieldJc_t const* field = null; 
      MemSegmJc memObj = { 0 }; 
      int32 memSegment = 0; 
      bool found = 0; 
      int32 modifiers = 0; 
      
      
      /*no initvalue*/
      
      //J2C: constructor for embedded element
      INIT_MemSegmJc(/*static*/memObj);
      memSegment = 0;
      /*no initvalue*/
      /*no initvalue*/
      if(length_StringJc(sVariablePath) == 0 || equals_StringJc(sVariablePath, s0_StringJc("."))) 
      { 
        
        /**root path: */
        found = true;
        clazz = getClass_ClassJc(/*static*/ythis->rootObj);//the main class itself contains some pointer yet.
        
        field = null;
        bQuestCollectionSize = false;//not at root level
        
        modifiers = 0;
        setAddrSegm_MemSegmJc(memObj, ythis->rootObj, 0);
      }
      else 
      { 
        int32 idx = 0;   /*not the root path, search the obj started from static_cast<ObjectJc*>(this) //targets[0]: */
        int32 idxP[1];   /**/
        struct FieldJc_t const* fieldP[1];   /**/
        
        
        /*no initvalue*/
        
        
        /**Search the field in its object, the referenced instance of the field is requested: */
        set_MemSegmJc(memObj, searchObject_SearchElement_Inspc(/*static*/sVariablePath, ythis->rootObj, &fieldP[0], &idxP[0], _thCxt));
        idx = idxP[0];
        field = fieldP[0];
        found = obj_MemSegmJc(memObj) != null;
        if(found) 
        { 
          
          /**Field is found. */
          modifiers = getModifiers_FieldJc(field);
          if(isCollection_ModifierJc(/*static*/modifiers) && (idx < 0 || (isStaticArray_ModifierJc(/*static*/modifiers) && idx >= getStaticArraySize_FieldJc(field)))) 
          { 
            
            bQuestCollectionSize = true;
            clazz = null;
          }
          else 
          { 
            
            /**normal Object: */
            TRY
            { 
              struct ClassJc_t const* retClazz[1];   /*Gets the real class of the field. */
              
              
              
              getObjAndClass_FieldJc(field, memObj, &retClazz[0], "I", idx);//index -1: if it is a container, no class is returned
              
              bQuestCollectionSize = false;//the clazz may be null
              
              clazz = retClazz[0];
              found = (clazz != null);//getFields with non acknowledge answer if it is a null-reference.
              
            }_TRY
            CATCH(RuntimeException, exc)
            
              { 
                
                clazz = null;
                bQuestCollectionSize = true;//Exception, no clazz info, but it may be a collection size quest.
                
              }
            END_TRY
          }
        }
        else 
        { //:The requested field isn't found, faulty path
          
          
          clazz = null;
          modifiers = 0;
        }
      }
      if(found) 
      { 
        int32 nOrderNr;   /*The field describes the last found field, the obj is the associated instance*/
        
        
        nOrderNr = getOrder_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
        if(bQuestCollectionSize) 
        { //:the size of an container is requested:
          
          int32 nSize; 
          bool hasSubstructure; 
          StringJc name; 
          int32 lengthAnswer; 
          int32 lengthAnswer4; 
          StringJc sAnswer;   /**/
          
          
          nSize = getArraylength_FieldJc(field, memObj);
          hasSubstructure = (modifiers & mPrimitiv_Modifier_reflectJc) == 0;
          setLength_StringBuilderJc(& (ythis->uAnswer.sb), 0, _thCxt);
          
            ( append_C_StringBuilderJc(& (ythis->uAnswer.sb), '[', _thCxt)
            , append_I_StringBuilderJc(& (ythis->uAnswer.sb), nSize, _thCxt)
            , append_z_StringBuilderJc(& (ythis->uAnswer.sb), "]:", _thCxt)
            );
          name = z_StringJc(getName_FieldJc(field))/*J2C:non-persistent*/;
          append_s_StringBuilderJc(& (ythis->uAnswer.sb), name, _thCxt);
          if(hasSubstructure) 
          { 
            
            append_z_StringBuilderJc(& (ythis->uAnswer.sb), "...", _thCxt);
          }//the GUI will expand it to some nodes, one per element.
          
          lengthAnswer = length_StringBuilderJc(& (ythis->uAnswer.sb));
          lengthAnswer4 = (lengthAnswer + 3) / 4 * 4;
          if(lengthAnswer4 > lengthAnswer) 
          { 
            
            append_s_StringBuilderJc(& (ythis->uAnswer.sb), substring_StringJc(zI_StringJc("\0\0\0",3), 0, lengthAnswer4 - lengthAnswer, _thCxt), _thCxt);//fill rest with 0
            
          }//adds the answer to the telegram:
          
          addChild_ByteDataAccessJc(& ((* (answer)).base.super), & ((ythis->answerItem).base.super), _thCxt);
          setInfoHead_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), lengthAnswer4 + sizeofHead_Info_InspcDataExchangeAccess_Inspc, kAnswerFieldMethod_Info_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);
          sAnswer = toStringNonPersist_StringBuilderJc(& ((ythis->uAnswer.sb).base.object), _thCxt)/*J2C:non-persistent*/;
          addChildString_S_ByteDataAccessJc(& ((ythis->answerItem).base.super), sAnswer, _thCxt);//
          
        }
        else if(clazz != null) 
        { //:not a question to collection size, but real clazz found:
          //:show the fields:
          
          FieldJc_Y const* fields;   /*Gets the fields of the real class of the found reference-field.*/
          
          
          if(obj_MemSegmJc(memObj) != null && segment_MemSegmJc(/*static*/memObj) == 0) 
          { 
            struct ClassJc_t const* outerObj;   /*Check whether an outer class exists. */
            
            
            outerObj = getEnclosingClass_ClassJc(clazz);
            if(outerObj != null) 
            { 
              
              evaluateFieldGetFields_SFdiii_ClassContent_Inspc(ythis, s0_StringJc("_outer"), outerObj, 0, 0, nOrderNr, _thCxt);
            }
          }
          fields = getDeclaredFields_ClassJc(clazz);
          if(fields != null) 
          { 
            int32 ii; 
            
            
            ii = ixFieldStart;
            if(ii < 0) 
            { 
              
              ii = 0;
            }
            { int32 ixField; 
              for(ixField = 0; ixField < fields->head.length; ++ixField)
                { 
                  
                  /**Generates one entry per field in the answer telegram. */
                  evaluateFieldGetFields_Fdi_ClassContent_Inspc(ythis, & (fields->data[ixField]), nOrderNr, _thCxt);
                }
            }
          }
        }
      }
    }_TRY
    CATCH(Exception, exc)
    
      { 
        
        /**Unexpected ...*/
        println_z_PrintStreamJc(REFJc(out_SystemJc), "ClassContent-getFields - unexpected:", _thCxt);
        printStackTrace_ExceptionJc(exc, _thCxt);
      }
    END_TRY
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

void evaluateFieldGetFields_Fdi_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct FieldJc_t const* field, int32 orderNr, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("evaluateFieldGetFields_Fdi_ClassContent_Inspc");
  
  { //:FieldJc field = new FieldJc(fieldP);   //regard container types
    
    StringJc name; 
    struct ClassJc_t const* typeField; 
    int32 modifiers; 
    int32 staticArraySize; 
    
    
    name = z_StringJc(getName_FieldJc(field))/*J2C:non-persistent*/;
    typeField = getType_FieldJc(field);
    modifiers = getModifiers_FieldJc(field);
    staticArraySize = getStaticArraySize_FieldJc(field);
    evaluateFieldGetFields_SFdiii_ClassContent_Inspc(ythis, name, typeField, modifiers, staticArraySize, orderNr, _thCxt);
  }
  STACKTRC_LEAVE;
}

void evaluateFieldGetFields_SFdiii_ClassContent_Inspc(ClassContent_Inspc_s* ythis, StringJc name, struct ClassJc_t const* typeField, int32 modifiers, int32 staticArraySize, int32 orderNr, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("evaluateFieldGetFields_SFdiii_ClassContent_Inspc");
  
  { 
    int32 modifContainertype; 
    bool hasSubstructure; 
    StringJc type; 
    int32 lengthName; 
    int32 lengthType; 
    
    
    modifContainertype = modifiers & m_Containertype_Modifier_reflectJc;
    hasSubstructure = (modifiers & mPrimitiv_Modifier_reflectJc) == 0 || (modifContainertype != 0);
    type = z_StringJc(typeField == null ? "unknown" : getName_ClassJc(typeField))/*J2C:non-persistent*/;
    lengthName = length_StringJc(name);
    lengthType = length_StringJc(type);
    setLength_StringBuilderJc(& (ythis->uArray.sb), 0, _thCxt);
    if(modifContainertype == kUML_LinkedList_Modifier_reflectJc) 
    { 
      
      append_z_StringBuilderJc(& (ythis->uArray.sb), "[?]:LinkedList", _thCxt);
    }
    else if(modifContainertype == kUML_ArrayList_Modifier_reflectJc) 
    { 
      
      append_z_StringBuilderJc(& (ythis->uArray.sb), "[?]:ArrayList", _thCxt);
    }
    else if(modifContainertype == kStaticArray_Modifier_reflectJc) 
    { 
      
      
        ( append_C_StringBuilderJc(& (ythis->uArray.sb), '[', _thCxt)
        , append_I_StringBuilderJc(& (ythis->uArray.sb), staticArraySize, _thCxt)
        , append_C_StringBuilderJc(& (ythis->uArray.sb), ']', _thCxt)
        );
    }
    else if(modifContainertype != 0) 
    { 
      
      append_z_StringBuilderJc(& (ythis->uArray.sb), "[?]:TODO-containerType", _thCxt);
    }
    
    { 
      int32 lengthArray; 
      int32 lengthValue; 
      int32 lengthAnswer;   /*calculate the length of the answer before writing. */
      int32 lengthAnswer4; 
      
      
      setLength_StringBuilderJc(& (ythis->uValue.sb), 0, _thCxt);
      lengthArray = length_StringBuilderJc(& (ythis->uArray.sb));
      lengthValue = length_StringBuilderJc(& (ythis->uValue.sb));
      lengthAnswer = sizeofHead_Info_InspcDataExchangeAccess_Inspc + lengthName + 1 + lengthType + lengthArray + lengthValue + (hasSubstructure ? 3 : 0);
      lengthAnswer4 = (lengthAnswer + 3) / 4 * 4;
      if((ythis->nrofAnswerBytes + lengthAnswer4) > ythis->maxNrofAnswerBytes) 
      { 
        AnswerComm_ifc_InspcMTB answerCommMtbl;   /*The information doesn't fit in the datagram: Send the last one and clear it.*/
        
        
        SETMTBJc(answerCommMtbl, ythis->answerComm, AnswerComm_ifc_Inspc);
        answerCommMtbl.mtbl->txAnswer(&(( (answerCommMtbl.ref))->base.object), ythis->nrofAnswerBytes, false, _thCxt);
        ythis->nrofAnswerBytes = sizeofHead_Datagram_InspcDataExchangeAccess_Inspc;
        removeChildren_ByteDataAccessJc(& ((* (ythis->answer)).base.super), _thCxt);
        incrAnswerNr_Datagram_InspcDataExchangeAccess_Inspc(ythis->answer, _thCxt);
      }
      
      { 
        StringJc sAnswerAdd;   /*sAnswer contains one entry for the telegram*/
        
        
        setLength_StringBuilderJc(& (ythis->uAnswer.sb), 0, _thCxt);
        append_s_StringBuilderJc(& (ythis->uAnswer.sb), name, _thCxt);
        append_u_StringBuilderJc(& (ythis->uAnswer.sb), & (ythis->uArray.sb), _thCxt);
        append_C_StringBuilderJc(& (ythis->uAnswer.sb), ':', _thCxt);
        append_s_StringBuilderJc(& (ythis->uAnswer.sb), type, _thCxt);
        if(lengthValue > 0) 
        { 
          
          append_C_StringBuilderJc(& (ythis->uAnswer.sb), '=', _thCxt);
          append_u_StringBuilderJc(& (ythis->uAnswer.sb), & (ythis->uValue.sb), _thCxt);
        }
        if(hasSubstructure) 
        { //:answerItem->data [answerPos] = '*';
          //:answerPos +=1;
          
          
          append_z_StringBuilderJc(& (ythis->uAnswer.sb), "...", _thCxt);
        }
        ASSERT(/*static*/length_StringBuilderJc(& (ythis->uAnswer.sb)) + sizeofHead_Info_InspcDataExchangeAccess_Inspc == lengthAnswer);//should be the same.
        
        if(lengthAnswer4 > lengthAnswer) 
        { 
          
          append_s_StringBuilderJc(& (ythis->uAnswer.sb), substring_StringJc(zI_StringJc("\0\0\0",3), 0, lengthAnswer4 - lengthAnswer, _thCxt), _thCxt);//fill rest with 0
          
        }
        addChild_ByteDataAccessJc(& ((* (ythis->answer)).base.super), & ((ythis->answerItem).base.super), _thCxt);
        sAnswerAdd = toStringNonPersist_StringBuilderJc(& ((ythis->uAnswer.sb).base.object), _thCxt)/*J2C:non-persistent*/;
        addChildString_S_ByteDataAccessJc(& ((ythis->answerItem).base.super), sAnswerAdd, _thCxt);//Prepare the answer item for this field:
        
        setInfoHead_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), lengthAnswer4, kAnswerFieldMethod_Info_InspcDataExchangeAccess_Inspc, orderNr, _thCxt);
        ythis->nrofAnswerBytes += lengthAnswer4;
      }
    }
  }
  STACKTRC_LEAVE;
}

int32 cmdGetValueByPath_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct Info_InspcDataExchangeAccess_Inspc_t* cmd, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdGetValueByPath_ClassContent_Inspc");
  
  { 
    int32 nrofBytesCmd; 
    StringJc sVariablePath;   /**/
    
    
    nrofBytesCmd = getLenInfo_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    sVariablePath = getChildString_ByteDataAccessJc(& ((* (cmd)).base.super), nrofBytesCmd - sizeofHead_Info_InspcDataExchangeAccess_Inspc, _thCxt)/*J2C:non-persistent*/;
    getSetValueByPath_ClassContent_Inspc(ythis, cmd, null, answer, sVariablePath, _thCxt);
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

int32 cmdSetValueByPath_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct Info_InspcDataExchangeAccess_Inspc_t* cmd, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, int32 maxNrofAnswerBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("cmdSetValueByPath_ClassContent_Inspc");
  
  { 
    int32 nrofBytesCmd; 
    SetValue_InspcDataExchangeAccess_Inspc_s setValue = { 0 };   /**/
    int32 nrofBytesPath; 
    StringJc sVariablePath;   /**/
    
    
    nrofBytesCmd = getLenInfo_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    
    //J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(setValue.base.object), sizeof(setValue), 0); 
    ctorO_SetValue_InspcDataExchangeAccess_Inspc(/*static*/&(setValue.base.object), _thCxt);
    addChild_ByteDataAccessJc(& ((* (cmd)).base.super), & ((setValue).base.super), _thCxt);
    nrofBytesPath = nrofBytesCmd - sizeofHead_Info_InspcDataExchangeAccess_Inspc - sizeofElement_SetValue_InspcDataExchangeAccess_Inspc;
    sVariablePath = getChildString_ByteDataAccessJc(& ((* (cmd)).base.super), nrofBytesPath, _thCxt)/*J2C:non-persistent*/;
    getSetValueByPath_ClassContent_Inspc(ythis, cmd, & (setValue), answer, sVariablePath, _thCxt);
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

int32 getSetValueByPath_ClassContent_Inspc(ClassContent_Inspc_s* ythis, struct Info_InspcDataExchangeAccess_Inspc_t* cmd, struct SetValue_InspcDataExchangeAccess_Inspc_t* accSetValue, struct Datagram_InspcDataExchangeAccess_Inspc_t* answer, StringJc sVariablePath, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getSetValueByPath_ClassContent_Inspc");
  
  { 
    int32 nOrderNr; 
    struct FieldJc_t const* theField = null;   /**/
    struct FieldJc_t const* theFieldP[1];   /**/
    MemSegmJc theObject = { 0 }; 
    StringJc sValue = NULL_StringJc;   /**/
    int32 memSegment = 0; 
    int32 idxOutput = 0; 
    int32 maxIdxOutput = 1200; 
    
    
    nOrderNr = getOrder_Info_InspcDataExchangeAccess_Inspc(cmd, _thCxt);
    theField = null;
    
    
    //J2C: constructor for embedded element
    INIT_MemSegmJc(/*static*/theObject);
    /*no initvalue*/
    memSegment = 0;
    idxOutput = 0;
    maxIdxOutput = 1200;
    TRY
    { 
      int32 idx = 0; 
      int32 idxP[1];   /**/
      
      
      /*no initvalue*/
      
      set_MemSegmJc(theObject, searchObject_SearchElement_Inspc(/*static*/sVariablePath, ythis->rootObj, &theFieldP[0], &idxP[0], _thCxt));
      theField = theFieldP[0];
      idx = idxP[0];
      if(obj_MemSegmJc(theObject) != null && theField != null) 
      { 
        struct ClassJc_t const* type; 
        int32 modifier; 
        
        
        type = getType_FieldJc(theField);
        modifier = getModifiers_FieldJc(theField);
        addChild_ByteDataAccessJc(& ((* (answer)).base.super), & ((ythis->answerItem).base.super), _thCxt);
        setInfoHead_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), 0, kAnswerValue_Info_InspcDataExchangeAccess_Inspc, nOrderNr, _thCxt);
        if(isPrimitive_ClassJc(type)) 
        { 
          StringJc sType; 
          char cType; 
          
          
          sType = z_StringJc(getName_ClassJc(type))/*J2C:non-persistent*/;
          cType = charAt_StringJc(sType, 0);
          switch(cType){
            case 'v': 
            case 'i': 
            { //:int
              
              int32 value = 0; 
              
              
              /*no initvalue*/
              if(accSetValue != null) 
              { 
                int32 setValue; 
                
                
                setValue = getInt_SetValue_InspcDataExchangeAccess_Inspc(accSetValue, _thCxt);
                value = setInt_FieldJc(theField, theObject, setValue, "I", idx);
              }
              else 
              { 
                
                value = getInt_FieldJc(theField, theObject, "I", idx);
              }
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int32_ClassJc, _thCxt);//Set the number of char-bytes in 1 byte
              
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 4, value, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;
            }break;
            case 'c': 
            { //:int
              
              char value = 0; 
              
              
              /*no initvalue*/
              if(accSetValue != null) 
              { 
                char setValue; 
                
                
                setValue = (char)getByte_SetValue_InspcDataExchangeAccess_Inspc(accSetValue, _thCxt);
                value = setChar_FieldJc(theField, theObject, setValue, "I", idx);
              }
              else 
              { 
                
                value = getChar_FieldJc(theField, theObject, "I", idx);
              }
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc, _thCxt);//Set the number of char-bytes in 1 byte
              
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 2, (int16)value, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;
            }break;
            case 's': 
            { //:short
              
              int16 value; 
              
              
              value = getShort_FieldJc(theField, theObject, "I", idx);
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc, _thCxt);//Set the number of char-bytes in 1 byte
              
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 2, value, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;
            }break;
            case 'l': 
            { //:long, it is int64
              
              int64 value; 
              
              
              value = getInt64_FieldJc(theField, theObject, "I", idx);
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int_ClassJc, _thCxt);//64);  //Set the number of char-bytes in 1 byte
              
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 4, value, _thCxt);//8
              
              sValue = null_StringJc/*J2C:non-persistent*/;
            }break;
            case 'f': 
            { //:float
              
              float fvalue; 
              int32 value; 
              
              
              fvalue = getFloat_FieldJc(theField, theObject, "I", idx);
              value = floatToRawIntBits_FloatJc(/*static*/fvalue);
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_float_ClassJc, _thCxt);//Set the number of char-bytes in 1 byte
              
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 4, value, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;
            }break;
            case 'd': 
            { //:double
              
              double fvalue; 
              int64 value; 
              
              
              fvalue = getDouble_FieldJc(theField, theObject, "I", idx);
              value = doubleToLongBits_DoubleJc(/*static*/fvalue);
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int32_ClassJc, _thCxt);//Set the number of char-bytes in 1 byte
              
              addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 8, value, _thCxt);
              sValue = null_StringJc/*J2C:non-persistent*/;
            }break;
            case 'b': switch(charAt_StringJc(sType, 1)){
              case 'o': 
              { //:boolean
                
                bool value = 0; 
                int32 value1; 
                
                
                /*no initvalue*/
                if(accSetValue != null) 
                { 
                  bool setValue; 
                  
                  
                  setValue = getShort_SetValue_InspcDataExchangeAccess_Inspc(accSetValue, _thCxt) != 0;
                  value = setBoolean_FieldJc(theField, theObject, setValue, "I", idx);
                }
                else 
                { 
                  
                  value = getBoolean_FieldJc(theField, theObject, "I", idx);
                }
                value1 = value ? 1 : 0;
                addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc, _thCxt);//Set the number of char-bytes in 1 byte
                
                addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 2, value1, _thCxt);
                sValue = null_StringJc/*J2C:non-persistent*/;
              }break;
              case 'y': 
              { //:byte
                
                int16 value; 
                
                
                value = getByte_FieldJc(theField, theObject, "I", idx);
                addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc, _thCxt);//Set the number of char-bytes in 1 byte
                
                addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 2, value, _thCxt);
                sValue = null_StringJc/*J2C:non-persistent*/;
              }break;
              case 'i': 
              { //:bitfield
                
                int16 value; 
                
                
                value = getBitfield_FieldJc(theField, theObject, "I", idx);
                addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, kScalarTypes_InspcDataExchangeAccess_Inspc + REFLECTION_int16_ClassJc, _thCxt);//Set the number of char-bytes in 1 byte
                
                addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 2, value, _thCxt);
                sValue = null_StringJc/*J2C:non-persistent*/;
              }break;
              default: 
              { 
                
                sValue = z_StringJc("?unknownPrimitiveType?")/*J2C:non-persistent*/;
              }
            }/*switch*/;break;
            default: 
            { 
              
              sValue = z_StringJc("?unknownType?")/*J2C:non-persistent*/;
            }
          }/*switch*/;//switch
          
        }
        else 
        { //:it is a complex type, not a numeric.
          
          
          sValue = getString_FieldJc(theField, theObject, "I", idx)/*J2C:non-persistent*/;
        }
        if(sValue.ptr__!= null) 
        { 
          int32 zValue; 
          int32 zInfo; 
          
          
          zValue = length_StringJc(sValue);
          if(zValue > maxNrOfChars_InspcDataExchangeAccess_Inspc) 
          { 
            
            zValue = maxNrOfChars_InspcDataExchangeAccess_Inspc;
            sValue = substring_StringJc(sValue, 0, zValue, _thCxt)/*J2C:non-persistent*/;
          }
          zInfo = zValue + 1 + sizeofHead_Info_InspcDataExchangeAccess_Inspc;
          addChildInteger_ByteDataAccessJc(& ((ythis->answerItem).base.super), 1, zValue, _thCxt);//Set the number of char-bytes in 1 byte
          
          addChildString_S_ByteDataAccessJc(& ((ythis->answerItem).base.super), sValue, _thCxt);//Set the character String after them.
          
        }
        setLength_Info_InspcDataExchangeAccess_Inspc(& (ythis->answerItem), getLength_ByteDataAccessJc(& ((ythis->answerItem).base.super), _thCxt), _thCxt);//the length of the answerItems in byte.
        
      }
    }_TRY
    CATCH(Exception, exc)
    
      { 
        
        /**Unexpected ...*/
        println_z_PrintStreamJc(REFJc(out_SystemJc), "ClassContent-getValueByPath - unexpected:", _thCxt);
        printStackTrace_ExceptionJc(exc, _thCxt);
      }
    END_TRY
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

void stop_ClassContent_Inspc(ClassContent_Inspc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("stop_ClassContent_Inspc");
  
  { 
    
    
  }
  STACKTRC_LEAVE;
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_ClassContent_Inspc mtblClassContent_Inspc = {
{ { sign_Mtbl_ClassContent_Inspc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
  /**J2C: Mtbl-interfaces of ClassContent_Inspc: */
, { { sign_Mtbl_CmdConsumer_ifc_Inspc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((2 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , executeMonitorCmd_XXXXi_ClassContent_Inspc //executeMonitorCmd
  , setAnswerComm_XX_ClassContent_Inspc //setAnswerComm
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_ClassContent_Inspc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_ClassContent_Inspc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_ClassContent_Inspc, ObjectJc) }
   }
 };

 extern struct ClassJc_t const reflection_CmdConsumer_ifc_Inspc_s;
 static struct ifcClasses_ClassContent_Inspc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }interfaces_ClassContent_Inspc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_CmdConsumer_ifc_Inspc_s, OFFSET_Mtbl(Mtbl_ClassContent_Inspc, CmdConsumer_ifc_Inspc) }
  }
};

extern struct ClassJc_t const reflection_ClassContent_Inspc_s;
extern struct ClassJc_t const reflection_AnswerComm_ifc_Inspc_s;
extern struct ClassJc_t const reflection_Datagram_InspcDataExchangeAccess_Inspc_s;
extern struct ClassJc_t const reflection_Info_InspcDataExchangeAccess_Inspc_s;
extern struct ClassJc_t const reflection_MemAccessArrayDebugJc;
extern struct ClassJc_t const reflection_ObjectJc;
extern struct ClassJc_t const reflection_SearchTrc_SearchElement_Inspc_s;
extern struct ClassJc_t const reflection_StringBuilderJc;
const struct Reflection_Fields_ClassContent_Inspc_s_t
{ ObjectArrayJc head; FieldJc data[11];
} reflection_Fields_ClassContent_Inspc_s =
{ CONST_ObjectArrayJc(FieldJc, 11, OBJTYPE_FieldJc, null, &reflection_Fields_ClassContent_Inspc_s)
, {
     { "rootObj"
    , 0 //nrofArrayElements
    , &reflection_ObjectJc
    , kReference_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->rootObj) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "answerComm"
    , 0 //nrofArrayElements
    , &reflection_AnswerComm_ifc_Inspc_s
    , kReference_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->answerComm) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "debugRemoteAccess"
    , 0 //nrofArrayElements
    , &reflection_MemAccessArrayDebugJc
    , kReference_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->debugRemoteAccess) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "debugSearchTrc"
    , 0 //nrofArrayElements
    , &reflection_SearchTrc_SearchElement_Inspc_s
    , kEmbedded_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->debugSearchTrc) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "nrofAnswerBytes"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->nrofAnswerBytes) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "maxNrofAnswerBytes"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->maxNrofAnswerBytes) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "answer"
    , 0 //nrofArrayElements
    , &reflection_Datagram_InspcDataExchangeAccess_Inspc_s
    , kReference_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->answer) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "answerItem"
    , 0 //nrofArrayElements
    , &reflection_Info_InspcDataExchangeAccess_Inspc_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->answerItem) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "uArray"
    , 0 //nrofArrayElements
    , &reflection_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->uArray) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "uValue"
    , 0 //nrofArrayElements
    , &reflection_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->uValue) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
   , { "uAnswer"
    , 0 //nrofArrayElements
    , &reflection_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->uAnswer) - (int32)(ClassContent_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ClassContent_Inspc_s
    }
} };
const ClassJc reflection_ClassContent_Inspc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "ClassContent_Inspc_s"
, (int16)((int32)(&((ClassContent_Inspc_s*)(0x1000))->base.object) - (int32)(ClassContent_Inspc_s*)0x1000)
, sizeof(ClassContent_Inspc_s)
, (FieldJcArray const*)&reflection_Fields_ClassContent_Inspc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_ClassContent_Inspc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_ClassContent_Inspc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblClassContent_Inspc.mtbl.head
};
