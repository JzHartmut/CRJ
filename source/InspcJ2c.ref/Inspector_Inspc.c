/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "InspcJ2c/Inspector_Inspc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "Jc/StringJc.h"  //embedded type in class data


/* J2C: Forward declaration of struct ***********************************************/


const char sign_Mtbl_Inspector_Inspc[] = "Inspector_Inspc"; //to mark method tables of all implementations

typedef struct MtblDef_Inspector_Inspc_t { Mtbl_Inspector_Inspc mtbl; MtblHeadJc end; } MtblDef_Inspector_Inspc;
 extern MtblDef_Inspector_Inspc const mtblInspector_Inspc;

/*Constructor */
struct Inspector_Inspc_t* ctorO_Inspector_Inspc(ObjectJc* othis, StringJc commOwnAddr, ThCxt* _thCxt)
{ Inspector_Inspc_s* ythis = (Inspector_Inspc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_Inspector_Inspc");
  checkConsistence_ObjectJc(othis, sizeof(Inspector_Inspc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_Inspector_Inspc_s, sizeof(Inspector_Inspc_s));  
  //j2c: Initialize all class variables:
  {
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->classContent.base.object), sizeof(ythis->classContent), 0); 
      ctorO_ClassContent_Inspc(/*static*/&(ythis->classContent.base.object), _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->cmdExecuter.base.object), sizeof(ythis->cmdExecuter), 0); 
      ctorO_CmdExecuter_Inspc(/*static*/&(ythis->cmdExecuter.base.object), & ((ythis->classContent).base.CmdConsumer_ifc_Inspc), _thCxt);
  }
  { 
    
    //J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(ythis->comm.base.object), sizeof(ythis->comm), 0); 
    ctorO_Comm_Inspc(/*static*/&(ythis->comm.base.object), commOwnAddr, & (ythis->cmdExecuter), _thCxt);
    completeConstruction_CmdExecuter_Inspc_F(& (ythis->cmdExecuter), & (ythis->comm), _thCxt);
    setAnswerComm_XX_ClassContent_Inspc(&((& ((ythis->classContent).base.CmdConsumer_ifc_Inspc))->base.object), & ((ythis->cmdExecuter).base.AnswerComm_ifc_Inspc), _thCxt);
  }
  STACKTRC_LEAVE;
  return ythis;
}



/**Start the execution. */
void start_Inspector_Inspc_F(Inspector_Inspc_s* ythis, struct ObjectJc_t* rootObj, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("start_Inspector_Inspc_F");
  
  { 
    
    setRootObject_ClassContent_Inspc(& (ythis->classContent), rootObj, _thCxt);
    start_Comm_Inspc(& (ythis->comm), _thCxt);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void start_Inspector_Inspc(Inspector_Inspc_s* ythis, struct ObjectJc_t* rootObj, ThCxt* _thCxt)
{ Mtbl_Inspector_Inspc const* mtbl = (Mtbl_Inspector_Inspc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_Inspector_Inspc);
  mtbl->start(ythis, rootObj, _thCxt);
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_Inspector_Inspc mtblInspector_Inspc = {
{ { sign_Mtbl_Inspector_Inspc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((1 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, start_Inspector_Inspc_F //start
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_Inspector_Inspc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_Inspector_Inspc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_Inspector_Inspc, ObjectJc) }
   }
 };

extern struct ClassJc_t const reflection_Inspector_Inspc_s;
extern struct ClassJc_t const reflection_ClassContent_Inspc_s;
extern struct ClassJc_t const reflection_CmdExecuter_Inspc_s;
extern struct ClassJc_t const reflection_Comm_Inspc_s;
const struct Reflection_Fields_Inspector_Inspc_s_t
{ ObjectArrayJc head; FieldJc data[3];
} reflection_Fields_Inspector_Inspc_s =
{ CONST_ObjectArrayJc(FieldJc, 3, OBJTYPE_FieldJc, null, &reflection_Fields_Inspector_Inspc_s)
, {
     { "classContent"
    , 0 //nrofArrayElements
    , &reflection_ClassContent_Inspc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Inspector_Inspc_s*)(0x1000))->classContent) - (int32)(Inspector_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Inspector_Inspc_s
    }
   , { "cmdExecuter"
    , 0 //nrofArrayElements
    , &reflection_CmdExecuter_Inspc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Inspector_Inspc_s*)(0x1000))->cmdExecuter) - (int32)(Inspector_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Inspector_Inspc_s
    }
   , { "comm"
    , 0 //nrofArrayElements
    , &reflection_Comm_Inspc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Inspector_Inspc_s*)(0x1000))->comm) - (int32)(Inspector_Inspc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Inspector_Inspc_s
    }
} };
const ClassJc reflection_Inspector_Inspc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "Inspector_Inspc_s"
,  0 //position of ObjectJc
, sizeof(Inspector_Inspc_s)
, (FieldJcArray const*)&reflection_Fields_Inspector_Inspc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_Inspector_Inspc_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblInspector_Inspc.mtbl.head
};
