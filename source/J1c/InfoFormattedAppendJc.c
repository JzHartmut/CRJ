/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "J1c/InfoFormattedAppendJc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept


/* J2C: Forward declaration of struct ***********************************************/

/**Interface for a unique kind to add informations to a given StringFormatter instance.
See also {@link InfoAppend}.

@author Hartmut Schorrig

*/


const char sign_Mtbl_InfoFormattedAppendJc[] = "InfoFormattedAppendJc"; //to mark method tables of all implementations

StringJc version_InfoFormattedAppendJc = CONST_z_StringJc("2015-03-08");
/*J2C: dynamic call variant of the override-able method: */
void infoFormattedAppend_InfoFormattedAppendJc(ObjectJc* ithis, struct StringFormatterJc_t* u, ThCxt* _thCxt)
{ Mtbl_InfoFormattedAppendJc const* mtbl = (Mtbl_InfoFormattedAppendJc const*)getMtbl_ObjectJc(ithis, sign_Mtbl_InfoFormattedAppendJc);
  mtbl->infoFormattedAppend(ithis, u, _thCxt);
}

 extern_C struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_InfoFormattedAppendJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_InfoFormattedAppendJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, 0 /*J2C: no Mtbl*/ }
   }
 };

extern_C struct ClassJc_t const reflection_InfoFormattedAppendJc_s;
extern_C struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_InfoFormattedAppendJc_s_t
{ ObjectArrayJc head; FieldJc data[1];
} reflection_Fields_InfoFormattedAppendJc_s =
{ CONST_ObjectArrayJc(FieldJc, 1, OBJTYPE_FieldJc, null, &reflection_Fields_InfoFormattedAppendJc_s)
, {
     { "version"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&version_InfoFormattedAppendJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&version_InfoFormattedAppendJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_InfoFormattedAppendJc_s
    }
} };
const ClassJc reflection_InfoFormattedAppendJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "InfoFormattedAppendJc_s"
,  0 //position of ObjectJc
, sizeof(InfoFormattedAppendJc_s)
, (FieldJcArray const*)&reflection_Fields_InfoFormattedAppendJc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_InfoFormattedAppendJc_s //superclass
, null //interfaces
, 0    //modifiers
};

/**Helper for simple application in toString().
<pre>
(at)Override public String toString(){ return (new PrepareToString(this)).ret; }
</pre>
@author hartmut

*/


const char sign_Mtbl_PrepareToString_InfoFormattedAppendJc[] = "PrepareToString_InfoFormattedAppendJc"; //to mark method tables of all implementations

typedef struct MtblDef_PrepareToString_InfoFormattedAppendJc_t { Mtbl_PrepareToString_InfoFormattedAppendJc mtbl; MtblHeadJc end; } MtblDef_PrepareToString_InfoFormattedAppendJc;
 extern MtblDef_PrepareToString_InfoFormattedAppendJc const mtblPrepareToString_InfoFormattedAppendJc;


/**J2C: Reflections and Method-table *************************************************/
const MtblDef_PrepareToString_InfoFormattedAppendJc mtblPrepareToString_InfoFormattedAppendJc = {
{ { sign_Mtbl_PrepareToString_InfoFormattedAppendJc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern_C struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_PrepareToString_InfoFormattedAppendJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_PrepareToString_InfoFormattedAppendJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_PrepareToString_InfoFormattedAppendJc, ObjectJc) }
   }
 };

extern_C struct ClassJc_t const reflection_PrepareToString_InfoFormattedAppendJc_s;
extern_C struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_PrepareToString_InfoFormattedAppendJc_s_t
{ ObjectArrayJc head; FieldJc data[1];
} reflection_Fields_PrepareToString_InfoFormattedAppendJc_s =
{ CONST_ObjectArrayJc(FieldJc, 1, OBJTYPE_FieldJc, null, &reflection_Fields_PrepareToString_InfoFormattedAppendJc_s)
, {
     { "ret"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((PrepareToString_InfoFormattedAppendJc_s*)(0x1000))->ret) - (int32)(PrepareToString_InfoFormattedAppendJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_PrepareToString_InfoFormattedAppendJc_s
    }
} };
const ClassJc reflection_PrepareToString_InfoFormattedAppendJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "PrepareToString_In_ppendJc_s"
,  0 //position of ObjectJc
, sizeof(PrepareToString_InfoFormattedAppendJc_s)
, (FieldJcArray const*)&reflection_Fields_PrepareToString_InfoFormattedAppendJc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_PrepareToString_InfoFormattedAppendJc_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblPrepareToString_InfoFormattedAppendJc.mtbl.head
};
