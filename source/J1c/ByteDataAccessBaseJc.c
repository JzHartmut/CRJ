/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "J1c/ByteDataAccessBaseJc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "Jc/ArraysJc.h"  //reference-association: ArraysJc
#include "Jc/CharsetJc.h"  //reference-association: CharsetJc
#include "Jc/MathJc.h"  //reference-association: MathJc_s
#include "Jc/StringJc.h"  //embedded type in class data
#include "Jc/SystemJc.h"  //reference-association: FloatJc


/* J2C: Forward declaration of struct ***********************************************/

/**This class is the base class for ByteDataAccess. It works without dynamic methods proper for C usage.
All variables are package private because they should be changed only with methods of this class.
Only the derived Class {@link ByteDataAccess} uses the variables direct.
*/


const char sign_Mtbl_ByteDataAccessBaseJc[] = "ByteDataAccessBaseJc"; //to mark method tables of all implementations

StringJc sVersion_ByteDataAccessBaseJc = CONST_z_StringJc("2014-08-26");

/*Constructor */
struct ByteDataAccessBaseJc_t* ctorM_i_ByteDataAccessBaseJc(MemC mthis, int32 sizeHead, ThCxt* _thCxt)
{ ByteDataAccessBaseJc_s* thiz = PTR_MemC(mthis, ByteDataAccessBaseJc_s);  //reference casting to the real class.
  int sizeObj = size_MemC(mthis);
  STACKTRC_TENTRY("ctor_ByteDataAccessBaseJc");
  if(sizeof(ByteDataAccessBaseJc_s) > sizeObj) THROW_s0(IllegalArgumentException, "faut size", sizeObj);
  //j2c: Initialize all class variables:
  {
    thiz->charset = forNamez_CharsetJc(/*static*/"ISO-8859-1", _thCxt);
  }
  { 
    
    thiz->sizeHead = sizeHead;
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct ByteDataAccessBaseJc_t* ctorM_ii_ByteDataAccessBaseJc(MemC mthis, int32 sizeHead, int32 sizeData, ThCxt* _thCxt)
{ ByteDataAccessBaseJc_s* thiz = PTR_MemC(mthis, ByteDataAccessBaseJc_s);  //reference casting to the real class.
  int sizeObj = size_MemC(mthis);
  STACKTRC_TENTRY("ctor_ByteDataAccessBaseJc");
  if(sizeof(ByteDataAccessBaseJc_s) > sizeObj) THROW_s0(IllegalArgumentException, "faut size", sizeObj);
  //j2c: Initialize all class variables:
  {
    thiz->charset = forNamez_CharsetJc(/*static*/"ISO-8859-1", _thCxt);
  }
  { 
    
    thiz->sizeHead = sizeHead;
    thiz->idxBegin = 0;
    thiz->idxEnd = sizeData;
    thiz->idxCurrentChild = -1;/*to mark start.*/
    
    thiz->idxCurrentChildEnd = -1;
    CLEAR_REFJc(thiz->parent);
  }
  STACKTRC_LEAVE;
  return thiz;
}


void setCharset_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, StringJc value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setCharset_ByteDataAccessBaseJc");
  
  { 
    
    thiz->charset = forName_CharsetJc(/*static*/value, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Resets the view to the buffer*/
void clear_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 lengthData, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("clear_ByteDataAccessBaseJc");
  
  { 
    
    ASSERT(/*static*/thiz->sizeHead >= 0);
    thiz->bExpand = lengthData <= 0;/*expand if the data have no head.*/
    
    thiz->idxCurrentChild = -1;
    thiz->idxCurrentChildEnd = thiz->idxBegin + thiz->sizeHead;/*NOTE: problem in last version? The idxBegin ... idxEnd should be the number of given data.*/
    
    thiz->idxEnd = thiz->bExpand ? thiz->idxBegin + thiz->sizeHead : thiz->idxBegin + lengthData;
    
    { /*:@Java4C.Exclude*/
      
      
      if(thiz->idxEnd > thiz->data.value__) 
      { 
        StringJc msg = CONST_z_StringJc("not enough data bytes, requested="); 
        
        StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
        
        msg = 
          ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
          , append_z_StringBuilderJc(_stringBuilderThCxt, "not enough data bytes, requested=", _thCxt)
          , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->idxEnd, _thCxt)
          , append_z_StringBuilderJc(_stringBuilderThCxt, ", buffer-length=", _thCxt)
          , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->data.value__, _thCxt)
          , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
          )/*J2C:non-persistent*/;
        { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
      }
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 to 8 bytes inside the actual element as a long number,*/
int64 _getLong_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxInChild, int32 nrofBytesAndSign, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_getLong_ByteDataAccessBaseJc");
  
  { 
    int64 val = 0; 
    int32 idxStep = 0; 
    int32 idx = 0; 
    int32 nrofBytes = 0; 
    bool bSigned = 0; 
    int32 nByteCnt; 
    
    
    val = 0;
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    if(nrofBytesAndSign >= 0) 
    { 
      
      nrofBytes = nrofBytesAndSign;
      bSigned = false;
    }
    else 
    { 
      
      nrofBytes = -nrofBytesAndSign;
      bSigned = true;
    }
    if(thiz->bBigEndian) 
    { 
      
      idx = thiz->idxBegin + idxInChild;
      idxStep = 1;
    }
    else 
    { 
      
      idx = thiz->idxBegin + idxInChild + nrofBytes - 1;
      idxStep = -1;
    }
    nByteCnt = nrofBytes;
    do 
      { 
        
        val |= thiz->data.ptr__[idx] & 0xff;
        if(--nByteCnt <= 0) break;/*TRICKY: break in mid of loop, no shift operation.*/
        
        val <<= 8;
        idx += idxStep;
      }while(true);/*see break;*/
    
    if(bSigned) 
    { 
      int32 posSign; 
      int64 maskSign = 1; 
      
      
      posSign = (nrofBytes * 8) - 1;
      maskSign = 1 << posSign;
      if((val & maskSign) != 0) 
      { 
        int64 bitsSign = 0xffffffffffffffff; 
        
        
        bitsSign = 0xffffffffffffffff << (posSign);
        val |= bitsSign;/*supplement the rest bits of long with the sign value,it's negativ.*/
        
      }
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**sets the content of 1 to 8 bytes inside the actual element as a long number,*/
void _setLong_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nrofBytes, int64 val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_setLong_ByteDataAccessBaseJc");
  
  { 
    int32 idxStep = 0; 
    
    
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      idx = thiz->idxBegin + idx + nrofBytes - 1;
      idxStep = -1;
    }
    else 
    { 
      
      idx = thiz->idxBegin + idx;
      idxStep = 1;
    }
    do 
      { 
        
        thiz->data.ptr__[idx] = (int8)(val);
        if(--nrofBytes <= 0) break;
        val >>= 8;
        idx += idxStep;
      }while(true);/*see break;*/
    
  }
  STACKTRC_LEAVE;
}


/**Increments the idxEnd if a new child is added*/
void expand_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxCurrentChildEndNew, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("expand_ByteDataAccessBaseJc");
  
  { 
    
    if(thiz->bExpand) 
    { /*:do it only in expand mode*/
      
      
      thiz->idxEnd = idxCurrentChildEndNew;
    }
    ASSERT(/*static*/idxCurrentChildEndNew >= thiz->idxBegin + thiz->sizeHead);
    thiz->idxCurrentChildEnd = idxCurrentChildEndNew;
    if(REFJc(thiz->parent) != null) 
    { 
      
      expand_ByteDataAccessBaseJc(REFJc(thiz->parent), idxCurrentChildEndNew, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Assigns new data to this element at given index in data.*/
void assign_iYii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, PtrVal_int8 dataP, int32 lengthData, int32 index, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assign_iYii_ByteDataAccessBaseJc");
  
  { 
    
    ASSERT(/*static*/index >= 0 && thiz->sizeHead >= 0);
    thiz->data = dataP;
    thiz->idxBegin = index;
    CLEAR_REFJc(thiz->parent);
    clear_ByteDataAccessBaseJc(thiz, lengthData, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Returns the data buffer itself*/
PtrVal_int8 getData_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getData_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->data;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the head*/
int32 getLengthHead_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLengthHead_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->sizeHead;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the existing actual element.*/
int32 getLength_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLength_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->idxEnd - thiz->idxBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the data.*/
int32 getLengthTotal_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLengthTotal_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->idxEnd;
    }
  }
  STACKTRC_LEAVE;
}


/**returns the number number of bytes there are max available from position of the current child.*/
int32 getMaxNrofBytes_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getMaxNrofBytes_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->data.value__ - thiz->idxBegin;
    }
  }
  STACKTRC_LEAVE;
}

bool getBigEndian_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getBigEndian_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->bBigEndian;
    }
  }
  STACKTRC_LEAVE;
}


/**returns true if the given number of bytes is sufficing in the data from position of next child.*/
bool sufficingBytesForNextChild_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("sufficingBytesForNextChild_ByteDataAccessBaseJc");
  
  { 
    int32 maxNrofBytesChild; 
    
    
    maxNrofBytesChild = getMaxNrofBytesForNextChild_ByteDataAccessBaseJc(thiz, _thCxt);
    { STACKTRC_LEAVE;
      return nrofBytes < 0 ? false : maxNrofBytesChild >= nrofBytes;
    }
  }
  STACKTRC_LEAVE;
}


/**returns the number number of bytes there are max available from position of a next current child.*/
int32 getMaxNrofBytesForNextChild_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getMaxNrofBytesForNextChild_ByteDataAccessBaseJc");
  
  { 
    
    if(thiz->idxCurrentChildEnd < thiz->idxCurrentChild) { throw_s0Jc(ident_IllegalArgumentExceptionJc, "length of current child is undefined.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return thiz->idxEnd - thiz->idxCurrentChildEnd;
    }
  }
  STACKTRC_LEAVE;
}


/**adds a child Element after the current child or as first child after head.*/
bool addChild_XXi_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* child, int32 sizeChild, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChild_XXi_ByteDataAccessBaseJc");
  
  { 
    int32 sizeChild1 = 0;   /**/
    int32 idxEndNew; 
    
    
    child->bBigEndian = thiz->bBigEndian;
    child->bExpand = thiz->bExpand;
    setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, _thCxt);
    /*no initvalue*/
    if(sizeChild <= thiz->sizeHead) 
    { /*:especially -1, the size is unknown.*/
      
      
      if(thiz->bExpand) 
      { 
        
        sizeChild1 = -1;
      }/*initialize with specifyLength()*/
      
      else 
      { 
        
        sizeChild1 = thiz->idxEnd - thiz->idxCurrentChild;
      }/*the child fills the parent.*/
      
    }
    else 
    { 
      
      sizeChild1 = sizeChild;/*given size is valid.*/
      
    }
    assign_iYii_ByteDataAccessBaseJc(child, thiz->data, sizeChild1, thiz->idxCurrentChild, _thCxt);
    SETREFJc(child->parent, thiz, ByteDataAccessBaseJc_s);/*this.currentChild = child;*/
    
    idxEndNew = child->idxEnd > child->idxCurrentChildEnd ? child->idxEnd : child->idxCurrentChildEnd;
    expand_ByteDataAccessBaseJc(thiz, idxEndNew, _thCxt);
    { STACKTRC_LEAVE;
      return thiz->bExpand;
    }
  }
  STACKTRC_LEAVE;
}

bool addChild_XX_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* child, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChild_XX_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return addChild_XXi_ByteDataAccessBaseJc(thiz, child, -1, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

bool addChildAt_iXXi_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxChild, struct ByteDataAccessBaseJc_t* child, int32 sizeChild, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildAt_iXXi_ByteDataAccessBaseJc");
  
  { 
    int32 idxBegin; 
    
    
    child->data = thiz->data;
    idxBegin = thiz->idxBegin + idxChild;
    child->idxBegin = idxBegin;
    child->idxEnd = idxBegin + sizeChild;
    child->idxCurrentChild = idxBegin + child->sizeHead;
    child->idxCurrentChildEnd = -1;
    child->bBigEndian = thiz->bBigEndian;
    child->bExpand = thiz->bExpand;
    SETREFJc(child->parent, thiz, ByteDataAccessBaseJc_s);
    expand_ByteDataAccessBaseJc(thiz, child->idxEnd, _thCxt);
    { STACKTRC_LEAVE;
      return thiz->bExpand;
    }
  }
  STACKTRC_LEAVE;
}

bool addChildAt_iXX_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxChild, struct ByteDataAccessBaseJc_t* child, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildAt_iXX_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return addChildAt_iXXi_ByteDataAccessBaseJc(thiz, idxChild, child, child->sizeHead, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance, and sets the value as integer.*/
void addChildInteger_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, int64 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildInteger_ByteDataAccessBaseJc");
  
  { 
    
    setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, _thCxt);
    if(thiz->data.value__ < thiz->idxCurrentChild + nrofBytes) 
    { 
      StringJc msg = CONST_z_StringJc("data length to small:"); 
      
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      msg = 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "data length to small:", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->idxCurrentChild + nrofBytes), _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
      { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    _setLong_ByteDataAccessBaseJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, nrofBytes, value, _thCxt);
    expand_ByteDataAccessBaseJc(thiz, thiz->idxCurrentChild + nrofBytes, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance, and sets the value as integer.*/
void addChildFloat_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, float value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildFloat_ByteDataAccessBaseJc");
  
  { 
    
    setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, _thCxt);
    if(thiz->data.value__ < thiz->idxCurrentChild + 4) 
    { 
      StringJc msg = CONST_z_StringJc("data length to small:"); 
      
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      msg = 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "data length to small:", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->idxCurrentChild + 4), _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
      { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    setFloat_if_ByteDataAccessBaseJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, value);
    expand_ByteDataAccessBaseJc(thiz, thiz->idxCurrentChild + 4, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Adds a child with String value.*/
void addChildString_SSb_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, StringJc value, StringJc sEncoding, bool preventCtrlChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildString_SSb_ByteDataAccessBaseJc");
  
  { 
    int32 nrofBytes; 
    
    
    setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, _thCxt);
    nrofBytes = length_StringJc(value);
    if(thiz->data.value__ < thiz->idxCurrentChild + nrofBytes) 
    { 
      StringJc msg = CONST_z_StringJc("data length to small:"); 
      
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      msg = 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "data length to small:", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->idxCurrentChild + nrofBytes), _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
      { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    _setString_ByteDataAccessBaseJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, nrofBytes, value, sEncoding, preventCtrlChars, _thCxt);
    expand_ByteDataAccessBaseJc(thiz, thiz->idxCurrentChild + nrofBytes, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Adds a child with String value.*/
void addChildString_SS_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, StringJc valueCs, StringJc sEncoding, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildString_SS_ByteDataAccessBaseJc");
  
  { 
    int32 nrofBytes; 
    
    
    setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, _thCxt);
    nrofBytes = length_StringJc(valueCs);
    if(thiz->data.value__ < thiz->idxCurrentChild + nrofBytes) 
    { 
      StringJc msg = CONST_z_StringJc("data length to small:"); 
      
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      msg = 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "data length to small:", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->idxCurrentChild + nrofBytes), _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
      { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    { int32 ii; 
      for(ii = 0; ii < nrofBytes; ++ii)
        { 
          int8 charByte; 
          
          
          charByte = (int8)(charAt_StringJc(valueCs, ii));
          thiz->data.ptr__[thiz->idxCurrentChild + ii] = charByte;
        }
    }
    expand_ByteDataAccessBaseJc(thiz, thiz->idxCurrentChild + nrofBytes, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance, but returns the value as integer.*/
int64 getChildInteger_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildInteger_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    
    setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, _thCxt);
    if(!setIdxCurrentChildEnd_ByteDataAccessBaseJc(thiz, abs(/*static*/nrofBytes), _thCxt)) 
    { /*:NOTE: to read from idxInChild = 0, build the difference as shown:*/
      
      int64 value; 
      
      
      value = _getLong_ByteDataAccessBaseJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, nrofBytes, _thCxt);
      { STACKTRC_LEAVE;
        return value;
      }
    }
    else { throw_s0Jc(ident_RuntimeExceptionJc, "Not available in expand mode.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 float value without a child instance, but returns the value as integer.*/
float getChildFloat_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildFloat_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    
    setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, _thCxt);
    if(!setIdxCurrentChildEnd_ByteDataAccessBaseJc(thiz, 4, _thCxt)) 
    { /*:NOTE: to read from idxInChild = 0, build the difference as shown:*/
      
      int32 intRepresentation; 
      
      
      intRepresentation = (int32)_getLong_ByteDataAccessBaseJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, 4, _thCxt);
      { STACKTRC_LEAVE;
        return intBitsToFloat_FloatJc(/*static*/intRepresentation);
      }
    }
    else { throw_s0Jc(ident_RuntimeExceptionJc, "Not available in expand mode.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 double value without a child instance, but returns the value as integer.*/
double getChildDouble_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildDouble_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    
    setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, _thCxt);
    if(!setIdxCurrentChildEnd_ByteDataAccessBaseJc(thiz, 8, _thCxt)) 
    { /*:NOTE: to read from idxInChild = 0, build the difference as shown:*/
      
      int64 intRepresentation; 
      
      
      intRepresentation = _getLong_ByteDataAccessBaseJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, 8, _thCxt);
      { STACKTRC_LEAVE;
        return longBitsToDouble_DoubleJc(/*static*/intRepresentation);
      }
    }
    else { throw_s0Jc(ident_RuntimeExceptionJc, "Not available in expand mode.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}


/**Adds a child for a String value without a child instance, but returns the value as String.*/
StringJc getChildString_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildString_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    
    setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, _thCxt);
    if(!setIdxCurrentChildEnd_ByteDataAccessBaseJc(thiz, nrofBytes, _thCxt)) 
    { /*:NOTE: to read from idxInChild = 0, build the difference as shown:*/
      
      
      { STACKTRC_LEAVE;
        return getString_ByteDataAccessBaseJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, nrofBytes, _thCxt);
      }
    }
    else { throw_s0Jc(ident_RuntimeExceptionJc, "Not available in expand mode.  ", 0, &_thCxt->stacktraceThreadContext, __LINE__); return null_StringJc; };
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the Element data in the assigned buffer.*/
int32 getPositionInBuffer_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getPositionInBuffer_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->idxBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the current child in the assigned buffer.*/
int32 getPositionNextChildInBuffer_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getPositionNextChildInBuffer_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->idxCurrentChildEnd;
    }
  }
  STACKTRC_LEAVE;
}


/**copies the data from another references data into this data.*/
void copyDataFrom_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("copyDataFrom_ByteDataAccessBaseJc");
  
  { 
    int32 len; 
    
    
    len = getLength_ByteDataAccessBaseJc(src, _thCxt);
    if(thiz->data.value__ < len) 
    { 
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "copy, dst to small", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, len, _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }/*//TODO System.arraycopy(src.data,src.idxBegin,data,idxBegin,len);*/
    
  }
  STACKTRC_LEAVE;
}


/**copies some data to a int[], primarily to debug a content.*/
void copyData_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32_Y* dst, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("copyData_ByteDataAccessBaseJc");
  
  { 
    int32 idxMax; 
    int32 iDst = 0; 
    
    
    idxMax = thiz->idxEnd - thiz->idxBegin;
    if(idxMax / 4 > dst->head.length) idxMax = 4 * dst->head.length;
    iDst = 0;
    { int32 idx; 
      for(idx = 0; idx < idxMax; idx += 4)
        { 
          
          dst->data[iDst++] = (int32)_getLong_ByteDataAccessBaseJc(thiz, idx, 4, _thCxt);
        }
    }
  }
  STACKTRC_LEAVE;
}

bool assertNotExpandable_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assertNotExpandable_ByteDataAccessBaseJc");
  
  { 
    
    ASSERT(/*static*/thiz->idxCurrentChild > 0 && thiz->idxEnd > 0 && !thiz->bExpand);
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


/**sets the idxCurrentChild to the known idxCurrentChildEnd.*/
void setIdxtoNextCurrentChild_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIdxtoNextCurrentChild_ByteDataAccessBaseJc");
  
  { 
    
    if(thiz->idxCurrentChildEnd >= thiz->idxCurrentChild) 
    { /*:This is the standard case.*/
      /*:NOTE: idxCurrentChild = -1 is assert if no child is added before.*/
      
      
      thiz->idxCurrentChild = thiz->idxCurrentChildEnd;
    }
    else if(thiz->idxCurrentChildEnd == -2) 
    { }
    else 
    { 
      
      { throw_s0Jc(ident_RuntimeExceptionJc, "unexpected idxCurrentChildEnd", 0, &_thCxt->stacktraceThreadContext, __LINE__); };/*its a programming error.*/
      
    }
    thiz->idxCurrentChildEnd = -1;/*the child content is not checked, this index will be set if setLengthCurrentChildElement() is called.*/
    
  }
  STACKTRC_LEAVE;
}


/**Returns a String from the given position inside the actual element .*/
StringJc getString_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getString_ByteDataAccessBaseJc");
  
  { 
    int32 idxData; 
    int32 idxEnd1; 
    int32 len; 
    StringJc value = NULL_StringJc; 
    
    
    idxData = idx + thiz->idxBegin;
    idxEnd1 = idxData + nrofBytes;
    ASSERT(/*static*/idxEnd1 <= thiz->idxEnd && idxEnd1 <= thiz->data.value__);
    
    while(thiz->data.ptr__[--idxEnd1] == 0 && idxEnd1 > idxData)
      ;/*skip 0 character on end*/
      
    len = idxEnd1 + 1 - idxData;
    /*no initvalue*/
    value = new_mBYIIEncoding_StringJc(/*static*/thiz->data, idxData, len, thiz->charset, _thCxt)/*J2C:non-persistent*/;
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets a String to the the given position inside the actual element .*/
int32 setString_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nmax, StringJc ss, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setString_ByteDataAccessBaseJc");
  
  { 
    ByteStringJc byteRepresentation;   /*Use a */
    int32 len; 
    
    
    if(length_StringJc(ss) > nmax) 
    { 
      
      ss = substring_StringJc(ss, 0, nmax, _thCxt)/*J2C:non-persistent*/;
    }/*truncate.*/
    
    /*no initvalue*/
    TRY
    { 
      
      byteRepresentation = getBytesEncoding_StringJc(ss, s0_StringJc("ISO-8859-1"), _thCxt);
    }_TRY
    CATCH(UnsupportedEncodingException, e)
    
      { 
        
        byteRepresentation = null_OS_PtrValue;
      }
    END_TRY
    len = length_ByteStringJc(byteRepresentation);
    if(len > nmax) 
    { 
      
      len = nmax;
    }/*truncate.*/
    
    arraycopy_vm_SystemJc(/*static*/byteRepresentation, 0, thiz->data, thiz->idxBegin + idx, len, _thCxt);
    { STACKTRC_LEAVE;
      return len;
    }
  }
  STACKTRC_LEAVE;
}


/**sets the content inside the actual element with the character bytes from the given String.*/
void _setString_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nrofBytes, StringJc value, StringJc sEncoding, bool preventCtrlChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_setString_ByteDataAccessBaseJc");
  
  { 
    StringJc value1; 
    int32 idxData; 
    int32 idxEnd; 
    ByteStringJc chars;   /**/
    int32 srcLen; 
    
    
    value1 = length_StringJc(value) > nrofBytes ? substring_StringJc(value, 0, nrofBytes, _thCxt) : value/*J2C:non-persistent*/;
    idxData = idx + thiz->idxBegin;
    idxEnd = idxData + nrofBytes;
    /*no initvalue*/
    if(sEncoding.ptr__== null) 
    { 
      
      sEncoding = z_StringJc("ISO-8859-1")/*J2C:non-persistent*/;
    }
    chars = getBytesEncoding_StringJc(value, sEncoding, _thCxt);
    srcLen = length_ByteStringJc(chars);
    if(srcLen > nrofBytes) 
    { 
      
      srcLen = nrofBytes;
    }
    { int32 ii; 
      for(ii = 0; ii < srcLen; ++ii)
        { 
          int8 cc; 
          
          
          cc = ((/*J2C:cast% from ByteStringJc*/int8)(data_ByteStringJc(chars)[ii]));
          if(preventCtrlChars && cc < 0x20) 
          { 
            
            cc = ((/*J2C:cast% from int32*/int8)(0x3f));
          }/*'?' in ASCII*/
          
          thiz->data.ptr__[idxData++] = cc;
        }/*fill up the rest of the string with 0-chars.*/
        
    }
    
    while(idxData < idxEnd)
      { 
        
        thiz->data.ptr__[idxData++] = 0;
      }
  }
  STACKTRC_LEAVE;
}


/**Gets a float value from the content of 4 byte*/
float getFloat_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getFloat_i_ByteDataAccessBaseJc");
  
  { 
    int32 intRepresentation; 
    float value; 
    
    
    intRepresentation = getInt32_i_ByteDataAccessBaseJc(thiz, idx, _thCxt);
    value = intBitsToFloat_FloatJc(/*static*/intRepresentation);
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}

double getDouble_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getDouble_ByteDataAccessBaseJc");
  
  { 
    int64 intRepresentation; 
    
    
    intRepresentation = _getLong_ByteDataAccessBaseJc(thiz, idx, 8, _thCxt);
    { STACKTRC_LEAVE;
      return longBitsToDouble_DoubleJc(/*static*/intRepresentation);
    }
  }
  STACKTRC_LEAVE;
}

int64 getInt64_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt64_ByteDataAccessBaseJc");
  
  { 
    int32 nLo = 0; 
    int32 nHi = 0; 
    int64 val; 
    
    
    /*no initvalue*/
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      nLo = getInt32_i_ByteDataAccessBaseJc(thiz, idx, _thCxt);
      nHi = getInt32_i_ByteDataAccessBaseJc(thiz, idx + 4, _thCxt);
    }
    else 
    { 
      
      nLo = getInt32_i_ByteDataAccessBaseJc(thiz, idx + 4, _thCxt);
      nHi = getInt32_i_ByteDataAccessBaseJc(thiz, idx, _thCxt);
    }
    val = nHi << 32;
    val |= nLo & 0xffffffff;
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 4 bytes inside the actual element as a integer number between -2147483648 and 2147483647,*/
int32 getInt32_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt32_i_ByteDataAccessBaseJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      val = ((thiz->data.ptr__[thiz->idxBegin + idx]) << 24) | (((thiz->data.ptr__[thiz->idxBegin + idx + 1]) << 16) & 0xff0000) | (((thiz->data.ptr__[thiz->idxBegin + idx + 2]) << 8) & 0xff00) | (((thiz->data.ptr__[thiz->idxBegin + idx + 3])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    else 
    { 
      
      val = ((thiz->data.ptr__[thiz->idxBegin + idx + 3]) << 24) | (((thiz->data.ptr__[thiz->idxBegin + idx + 2]) << 16) & 0xff0000) | (((thiz->data.ptr__[thiz->idxBegin + idx + 1]) << 8) & 0xff00) | (((thiz->data.ptr__[thiz->idxBegin + idx])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint32_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint32_i_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return getInt32_i_ByteDataAccessBaseJc(thiz, idx, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 2 bytes as a positive nr between 0..65535, big-endian*/
int32 getUint16_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint16_i_ByteDataAccessBaseJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      val = (((thiz->data.ptr__[thiz->idxBegin + idx]) << 8) & 0xff00) | (((thiz->data.ptr__[thiz->idxBegin + idx + 1])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    else 
    { 
      
      val = (((thiz->data.ptr__[thiz->idxBegin + idx + 1]) << 8) & 0xff00) | (((thiz->data.ptr__[thiz->idxBegin + idx])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 2 bytes as a positive nr between 0..65535 inside the actual element.*/
int16 getInt16_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt16_i_ByteDataAccessBaseJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      val = (((thiz->data.ptr__[thiz->idxBegin + idx]) << 8) & 0xff00) | (((thiz->data.ptr__[thiz->idxBegin + idx + 1])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    else 
    { 
      
      val = (((thiz->data.ptr__[thiz->idxBegin + idx + 1]) << 8) & 0xff00) | (((thiz->data.ptr__[thiz->idxBegin + idx])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    { STACKTRC_LEAVE;
      return (int16)val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 bytes as ASCII*/
char getChar_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChar_ByteDataAccessBaseJc");
  
  { 
    char val = 0; 
    
    
    /*no initvalue*/
    val = (char)thiz->data.ptr__[thiz->idxBegin + idx];
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 bytes as a positive or negative nr between -128..127*/
int8 getInt8_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt8_i_ByteDataAccessBaseJc");
  
  { 
    int8 val = 0; 
    
    
    /*no initvalue*/
    val = thiz->data.ptr__[thiz->idxBegin + idx];
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 bytes as a positive or negative nr between -128..127*/
int32 getUint8_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint8_i_ByteDataAccessBaseJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    val = thiz->data.ptr__[thiz->idxBegin + idx] & 0xff;
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint32_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint32_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getUint16:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getUint32_i_ByteDataAccessBaseJc(thiz, idxBytes + 4 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt32_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt32_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getInt32:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getInt32_i_ByteDataAccessBaseJc(thiz, idxBytes + 4 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt16_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt16_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getInt16:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getInt16_i_ByteDataAccessBaseJc(thiz, idxBytes + 2 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt8_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt8_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getInt8:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getInt8_i_ByteDataAccessBaseJc(thiz, idxBytes + idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint16_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint16_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getUint16:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getUint16_i_ByteDataAccessBaseJc(thiz, idxBytes + 2 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint8_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint8_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getUint8:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getInt8_i_ByteDataAccessBaseJc(thiz, idxBytes + idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

float getFloat_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getFloat_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getFloat:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getFloat_i_ByteDataAccessBaseJc(thiz, idxBytes + 4 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 4 bytes as a integer number between -2147483648 and 2147483647,*/
void setInt32_ii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt32_ii_ByteDataAccessBaseJc");
  
  { 
    
    if(thiz->bBigEndian) 
    { 
      
      thiz->data.ptr__[thiz->idxBegin + idx] = (int8)((value >> 24) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx + 1] = (int8)((value >> 16) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx + 2] = (int8)((value >> 8) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx + 3] = (int8)(value & 0xff);
    }
    else 
    { 
      
      thiz->data.ptr__[thiz->idxBegin + idx + 3] = (int8)((value >> 24) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx + 2] = (int8)((value >> 16) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx + 1] = (int8)((value >> 8) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx] = (int8)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 4 bytes as a positive nr between 0..2pow32-1, big- or little-endian.*/
void setUint32_il_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int64 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setUint32_il_ByteDataAccessBaseJc");
  
  { /*:the same algorithm in source, but other action on machine level,*/
    /*:because value is long!*/
    
    
    if(thiz->bBigEndian) 
    { 
      
      thiz->data.ptr__[thiz->idxBegin + idx] = (int8)((value >> 24) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx + 1] = (int8)((value >> 16) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx + 2] = (int8)((value >> 8) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx + 3] = (int8)(value & 0xff);
    }
    else 
    { 
      
      thiz->data.ptr__[thiz->idxBegin + idx + 3] = (int8)((value >> 24) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx + 2] = (int8)((value >> 16) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx + 1] = (int8)((value >> 8) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx] = (int8)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 2 bytes from an integer between -32768..32768,*/
void setInt16_ii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt16_ii_ByteDataAccessBaseJc");
  
  { 
    
    if(thiz->bBigEndian) 
    { 
      
      thiz->data.ptr__[thiz->idxBegin + idx] = (int8)((value >> 8) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx + 1] = (int8)(value & 0xff);
    }
    else 
    { 
      
      thiz->data.ptr__[thiz->idxBegin + idx + 1] = (int8)((value >> 8) & 0xff);
      thiz->data.ptr__[thiz->idxBegin + idx] = (int8)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}

void throwexc_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, StringJc text, int32 idxArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("throwexc_ByteDataAccessBaseJc");
  
  { 
    StringJc textExc; 
    
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    textExc = 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_s_StringBuilderJc(_stringBuilderThCxt, text, _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, textExc, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
  }
  STACKTRC_LEAVE;
}


/**Increments the idxEnd and the idxCurrentChildEnd if a new child is added*/
void correctCurrentChildEnd_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxEndNew, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("correctCurrentChildEnd_ByteDataAccessBaseJc");
  
  { 
    
    if(thiz->idxEnd < idxEndNew) 
    { 
      
      thiz->idxEnd = idxEndNew;
    }
    if(thiz->idxCurrentChildEnd < idxEndNew) 
    { 
      
      thiz->idxCurrentChildEnd = idxEndNew;
    }
    if(REFJc(thiz->parent) != null) 
    { 
      
      correctCurrentChildEnd_ByteDataAccessBaseJc(REFJc(thiz->parent), idxEndNew, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**sets the idxCurrentChildEnd and idxEnd*/
bool setIdxCurrentChildEnd_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIdxCurrentChildEnd_ByteDataAccessBaseJc");
  
  { 
    
    if(thiz->bExpand) 
    { 
      
      if(thiz->data.value__ < thiz->idxCurrentChild + nrofBytes) 
      { 
        StringJc msg = CONST_z_StringJc("data length to small:"); 
        
        StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
        
        msg = 
          ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
          , append_z_StringBuilderJc(_stringBuilderThCxt, "data length to small:", _thCxt)
          , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->idxCurrentChild + nrofBytes), _thCxt)
          , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
          )/*J2C:non-persistent*/;
        { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    else 
    { 
      
      if(thiz->idxEnd < thiz->idxCurrentChildEnd) 
      { /*:not expand, but the nrof data are to few*/
        
        StringJc msg = CONST_z_StringJc("to few user data:"); 
        
        StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
        
        msg = 
          ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
          , append_z_StringBuilderJc(_stringBuilderThCxt, "to few user data:", _thCxt)
          , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->idxCurrentChild + nrofBytes), _thCxt)
          , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
          )/*J2C:non-persistent*/;
        { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    expand_ByteDataAccessBaseJc(thiz, thiz->idxCurrentChild + nrofBytes, _thCxt);/*also of all parents*/
    
    { STACKTRC_LEAVE;
      return thiz->bExpand;
    }
  }
  STACKTRC_LEAVE;
}


void finalize_ByteDataAccessBaseJc_F(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ STACKTRC_TENTRY("finalize_ByteDataAccessBaseJc_F");
  CLEAR_REFJc(thiz->parent);
  STACKTRC_LEAVE;
}


extern_C struct ClassJc_t const reflection_ByteDataAccessBaseJc_s;
extern_C struct ClassJc_t const reflection_ByteDataAccessBaseJc_s;
extern_C struct ClassJc_t const reflection_CharsetJc;
extern_C struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_ByteDataAccessBaseJc_s_t
{ ObjectArrayJc head; FieldJc data[11];
} reflection_Fields_ByteDataAccessBaseJc_s =
{ CONST_ObjectArrayJc(FieldJc, 11, OBJTYPE_FieldJc, null, &reflection_Fields_ByteDataAccessBaseJc_s)
, {
     { "sizeHead"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->sizeHead) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "data"
    , 0 //nrofArrayElements
    , REFLECTION_int8
    , 1 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kPtrVal_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->data) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "idxBegin"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->idxBegin) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "idxEnd"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->idxEnd) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "idxCurrentChild"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->idxCurrentChild) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "idxCurrentChildEnd"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->idxCurrentChildEnd) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "bExpand"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->bExpand) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "bBigEndian"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->bBigEndian) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "parent"
    , 0 //nrofArrayElements
    , &reflection_ByteDataAccessBaseJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->parent) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "charset"
    , 0 //nrofArrayElements
    , &reflection_CharsetJc
    , kReference_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->charset) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "sVersion"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&sVersion_ByteDataAccessBaseJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&sVersion_ByteDataAccessBaseJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_ByteDataAccessBaseJc_s
    }
} };
const ClassJc reflection_ByteDataAccessBaseJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "ByteDataAccessBaseJc_s"
,  0 //position of ObjectJc
, sizeof(ByteDataAccessBaseJc_s)
, (FieldJcArray const*)&reflection_Fields_ByteDataAccessBaseJc_s
, null //method
, null //superclass
, null //interfaces
, 0    //modifiers
};
