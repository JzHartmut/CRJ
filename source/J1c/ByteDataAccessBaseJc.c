/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "J1c/ByteDataAccessBaseJc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "Jc/ArraysJc.h"  //reference-association: ArraysJc
#include "Jc/AssertJc.h"  //reference-association: RetOrExceptionJc
#include "Jc/CharsetJc.h"  //reference-association: CharsetJc
#include "Jc/StringJc.h"  //embedded type in class data
#include "Jc/SystemJc.h"  //reference-association: FloatJc


/* J2C: Forward declaration of struct ***********************************************/

/**This class is a base class to control the access to binary data.
The binary data may typically used or produced from a part of software written in C or C++.
Therewith the binary data are struct-constructs. Another example - build of datagram structures.
<br>
This class is a base class which should be derived for user's necessities.
The methods {@link #getInt16(int)} etc. are protected. That should prevent erratic free accesses to data
on application level. A derived class of this class structures the software for byte data access.
<br><br>
It is able to support several kinds of structured data access:<ul>
<li>Simple C-like <code>struct</code> are adequate mapped with a simple derived class of this class,
using the protected commonly access methods like {@link #_getLong(int, int)} with predefined indexes
in special methods like getValueXyz().
<li>Complex <code>struct</code> with nested <code>struct</code> inside are mapped
with one derived class per <code>struct</code>, define one reference per nested struct
<li>Base <code>struct</code> inside a <code>struct</code> (inheritance in C) can be mapped with
extra derived classes for the base struct and usind the
{@link #assignCasted(ByteDataAccessBase, int, int)}-method.
<li>A pack of data with several struct may be mapped using the {@link #addChild(ByteDataAccessBase)}-method.
Thereby a parent should be defined, and the structs of the pack are children of this parent.
That structures need not be from the same type.
<li>packs of struct with parent are able to nesting, it is able to construct as a tree of pack of structures.
The parent of the pack is the tree node. It is likewise a XML tree.
The data may be also transformed to a XML data representation
or the data structure may be explained with a XML tree, but they are not
XML data straight.
</ul>
This application possibilities show a capable of development system to access binary data.
The other, hand made way was calculate with indices of the byte[idx] specially user programmed.
This class helps to make such complex index calculation needlessly.
One struct at C level corresponds with one derivated class of ByteDataAccessBase.
But last also a generation of the java code from C/C++-header files containing the structs is able to.
So the definition of byte positions are made only on one source. The C/C++ is primary thereby.

<br>
The UML structure of such an class in a environment may be shown with the
followed object model diagram, <br>
<code> <+>---> </code>is a composition,
<code> <>---> </code>is a aggregation, <code> <|---- </code>is a inherition.
<pre>
+-------------------------------+                 +----------+
| ByteDataAccessBase(sizeHead)  |----data-------->| byte[]   |
|-------------------------------|                 |          |
|- idxBegin:int                 |                 | d a t a  |
|- idxNextChild:int             |                 +----------+
+-------------+     |- idxEnd:int                   |
| derivated   |     |-------------------------------|<---------------+ a known parent
| user        |---|>|+ addChild(child)              |---parent-------+ set in addChild()
| classes     |     |+ addChildFloat()              |
+-------------+     |% getInt32()                   |----currChild---+
|                               |<---------------+
+-------------------------------+
</pre>

This class is the base class for ByteDataAccess. It works without dynamic methods proper for C usage.
All variables are package private because they should be changed only with methods of this class.
<br><br>
<h2>Initialization and instances</h2>
The root instance to access to data should be initialized with
<pre>
MyByteDataAccessRoot accessRoot = new MyByteDataAccessRoot();
//... invokes super.ByteDataAccessBase(lengthHead);
accessRoot.assign(myData, dataLength);
</pre>
Any instances which represents a sub structure in data can be created as re-useable instances, which can be added
as child of the root instance or as child of any already added child on demand:
<pre>
MySubStruct subStruct = new SubStruct();  //an instance for accessing
....
accessRoot.addChild(subStruct);         //adds on current position.
int value = subStruct.getValuexyz();    //now can access the data.
....  //later on code:
accessOther.addChild(subStruct);        //reuse the instance for access
int value = subStruct.getValueAbc();    //access other data.
</pre>
The instances of this derived class are helper to access to the data, they are not container for the data.
The data are stored in a <code>byte[]</code>-array


<br>
<h2>children, currentChild, addChild</h2>
Children are used to evaluate or write different data structures after a known structure.
The children may be from several derived types of this class.
With children and children inside children a tree of different data can be built or evaluated.
<ul>
<li>{@link #addChild(ByteDataAccessBase)}: adds a child with its head size
<li>{@link #addChild(ByteDataAccessBase, int)}: adds a child with a given length
<li>{@link #addChildEmpty(ByteDataAccessBase)}: adds a child with its head size for writing, set all data to 0.
<li>{@link #addChildEmpty(ByteDataAccessBase, int)}: same with given size of child.
<li>{@link #addChildFloat(float)}, {@link #addChildInteger(int, long)}: writes the value and increments the #ixChildEnd after it.
<li>{@link #addChildString(CharSequence)}, {@link #addChildString(CharSequence, String)}: writes the String.
<li>{@link #getChildFloat()}, {@link #getChildDouble()}, {@link #getChildInteger(int)}: reads the value at {@link #ixNextChild}
and increments the {@link #ixNextChild}.
<li>{@link #getChildString(int)} reads a String and increments the {@link #ixNextChild}
<li>{@link #addChildAt(int, ByteDataAccessBase)}, {@link #addChildAt(int, ByteDataAccessBase, int)}: Used if the byte structure
is known. Adds a child not at #ixNextChild but at the given position.
</ul>
Mechanism and indices see {@link #addChild(ByteDataAccessBase, int)}.


<h2>Expand, check</h2>
If an instance is set for read or change, a given number of valid data bytes are known. The instance is marked as 'non expandable', see
The data should be assigned with
<ul>
<li>{@link #assign(byte[], int)} with given length, not expandable
<li>{@link #assign(byte[], int, int)} at a defined position in the data usefull for special cases.
With the given length >= the sizehead of the {@link ByteDataAccessBase#ByteDataAccessBase(int)}
the internal flag {@link #bExpand} is set to false.
</ul>
If an instance is set for write, the maximal number of bytes is limited by the size of data (byte[]).
The data should be assigned with:
<ul>
<li>{@link #assignClear(byte[])} as empty instance, the data are cleared in its whole length.
<li>{@link #assign(byte[], int)} with 0 as length argument as instance which only knows the head data, but the data are not cleared.
</ul>
In both cases the internal flag {@link #bExpand} is set to true. It means that the {@link #ixEnd()} which is set initially to the {@link #sizeHead}
is increased if a child is added.
<br><br>
If an instance of this is set to non expandable,
an exception is thrown if a children is added after the given length. If an instance is designated as 'expandable' the end index
#ixEnd is increased by adding children till the length of data as its maximal value.
<br><br>
With the operations {@link #sufficingBytesForNextChild(int)} or {@link #getMaxNrofBytes()} it can be tested whether a child can be added
with its known length.
<br>

<h2>Examples</h2>
See
<ul>
<li>{@link org.vishia.byteData.test.TestByteDataAccessBase}
<li>{@link org.vishia.byteData.test.ExampleStringOrInt}
</ul>
*/


const char sign_Mtbl_ByteDataAccessBaseJc[] = "ByteDataAccessBaseJc"; //to mark method tables of all implementations

StringJc version_ByteDataAccessBaseJc = CONST_z_StringJc("2015-03-08");

/*Constructor */
struct ByteDataAccessBaseJc_t* ctorM_i_ByteDataAccessBaseJc(MemC mthis, int32 sizeHead, ThCxt* _thCxt)
{ ByteDataAccessBaseJc_s* thiz = PTR_MemC(mthis, ByteDataAccessBaseJc_s);  //reference casting to the real class.
  int sizeObj = size_MemC(mthis);
  STACKTRC_TENTRY("ctor_ByteDataAccessBaseJc");
  if(sizeof(ByteDataAccessBaseJc_s) > sizeObj) THROW_s0(IllegalArgumentException, "faut size", sizeObj);
  //j2c: Initialize all class variables:
  {
    thiz->bExc = true;
    thiz->charset = forNamez_CharsetJc(/*static*/"ISO-8859-1", _thCxt);
  }
  { 
    
    thiz->sizeHead = sizeHead;
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct ByteDataAccessBaseJc_t* ctorM_ii_ByteDataAccessBaseJc(MemC mthis, int32 sizeHead, int32 sizeData, ThCxt* _thCxt)
{ ByteDataAccessBaseJc_s* thiz = PTR_MemC(mthis, ByteDataAccessBaseJc_s);  //reference casting to the real class.
  int sizeObj = size_MemC(mthis);
  STACKTRC_TENTRY("ctor_ByteDataAccessBaseJc");
  if(sizeof(ByteDataAccessBaseJc_s) > sizeObj) THROW_s0(IllegalArgumentException, "faut size", sizeObj);
  //j2c: Initialize all class variables:
  {
    thiz->bExc = true;
    thiz->charset = forNamez_CharsetJc(/*static*/"ISO-8859-1", _thCxt);
  }
  { 
    
    ASSERT(/*static*/sizeHead >= 0);
    ASSERT(/*static*/sizeData > 0);
    thiz->sizeHead = sizeHead;
    thiz->ixBegin = 0;
    thiz->ixEnd = sizeData;
    thiz->bExpand = false;
    thiz->ixNextChild = sizeHead;
    CLEAR_REFJc(thiz->parent);
  }
  STACKTRC_LEAVE;
  return thiz;
}



/**Returns the content of 1 to 8 bytes inside the actual element as a long number,*/
int64 _getLong_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxInChild, int32 nrofBytesAndSign, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_getLong_ByteDataAccessBaseJc");
  
  { 
    int64 val = 0; 
    int32 idxStep = 0; 
    int32 idx = 0; 
    int32 nrofBytes = 0; 
    bool bSigned = 0; 
    int32 nByteCnt; 
    
    
    val = 0;
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    if(nrofBytesAndSign >= 0) 
    { 
      
      nrofBytes = nrofBytesAndSign;
      bSigned = false;
    }
    else 
    { 
      
      nrofBytes = -nrofBytesAndSign;
      bSigned = true;
    }
    if(thiz->bBigEndian) 
    { 
      
      idx = thiz->ixBegin + idxInChild;
      idxStep = 1;
    }
    else 
    { 
      
      idx = thiz->ixBegin + idxInChild + nrofBytes - 1;
      idxStep = -1;
    }
    nByteCnt = nrofBytes;
    do 
      { 
        
        val |= thiz->data.ref[idx] & 0xff;
        if(--nByteCnt <= 0) break;/*TRICKY: break in mid of loop, no shift operation.*/
        
        val <<= 8;
        idx += idxStep;
      }while(true);/*see break;*/
    
    if(bSigned) 
    { 
      int32 posSign; 
      int64 maskSign = 1; 
      
      
      posSign = (nrofBytes * 8) - 1;
      maskSign = 1 << posSign;
      if((val & maskSign) != 0) 
      { 
        int64 bitsSign = 0xffffffffffffffff; 
        
        
        bitsSign = 0xffffffffffffffff << (posSign);
        val |= bitsSign;/*supplement the rest bits of long with the sign value,it's negativ.*/
        
      }
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 to 4 bytes inside the actual element as a int number,*/
int32 _getInt_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxInChild, int32 nrofBytesAndSign, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_getInt_ByteDataAccessBaseJc");
  
  { 
    int32 val = 0; 
    int32 idxStep = 0; 
    int32 idx = 0; 
    int32 nrofBytes = 0; 
    bool bSigned = 0; 
    int32 nByteCnt; 
    
    
    val = 0;
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    if(nrofBytesAndSign >= 0) 
    { 
      
      nrofBytes = nrofBytesAndSign;
      bSigned = false;
    }
    else 
    { 
      
      nrofBytes = -nrofBytesAndSign;
      bSigned = true;
    }
    if(thiz->bBigEndian) 
    { 
      
      idx = thiz->ixBegin + idxInChild;
      idxStep = 1;
    }
    else 
    { 
      
      idx = thiz->ixBegin + idxInChild + nrofBytes - 1;
      idxStep = -1;
    }
    nByteCnt = nrofBytes;
    do 
      { 
        
        val |= thiz->data.ref[idx] & 0xff;
        if(--nByteCnt <= 0) break;/*TRICKY: break in mid of loop, no shift operation.*/
        
        val <<= 8;
        idx += idxStep;
      }while(true);/*see break;*/
    
    if(bSigned) 
    { 
      int32 posSign; 
      int64 maskSign = 1; 
      
      
      posSign = (nrofBytes * 8) - 1;
      maskSign = 1 << posSign;
      if((val & maskSign) != 0) 
      { 
        int64 bitsSign = 0xffffffffffffffff; 
        
        
        bitsSign = 0xffffffffffffffff << (posSign);
        val |= ((/*J2C:cast% from int64*/int32)(bitsSign));/*supplement the rest bits of long with the sign value,it's negativ.*/
        
      }
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**sets the content of 1 to 8 bytes inside the actual element as a long number,*/
void _setLong_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nrofBytes, int64 val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_setLong_ByteDataAccessBaseJc");
  
  { 
    int32 idx1 = 0; 
    int32 nrofBytes1; 
    int64 val1; 
    int32 idxStep = 0; 
    
    
    /*no initvalue*/
    nrofBytes1 = nrofBytes;
    val1 = val;
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      idx1 = thiz->ixBegin + idx + nrofBytes - 1;
      idxStep = -1;
    }
    else 
    { 
      
      idx1 = thiz->ixBegin + idx;
      idxStep = 1;
    }
    do 
      { 
        
        thiz->data.ref[idx1] = (int8)(val1);
        if(--nrofBytes1 <= 0) break;
        val1 >>= 8;
        idx1 += idxStep;
      }while(true);/*see break;*/
    
  }
  STACKTRC_LEAVE;
}


/**sets the content of 1 to 4 bytes inside the actual element as a long number,*/
void _setInt_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nrofBytes, int32 val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_setInt_ByteDataAccessBaseJc");
  
  { 
    int32 idx1 = 0; 
    int32 nrofBytes1; 
    int32 val1; 
    int32 idxStep = 0; 
    
    
    /*no initvalue*/
    nrofBytes1 = nrofBytes;
    val1 = val;
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      idx1 = thiz->ixBegin + idx + nrofBytes - 1;
      idxStep = -1;
    }
    else 
    { 
      
      idx1 = thiz->ixBegin + idx;
      idxStep = 1;
    }
    do 
      { 
        
        thiz->data.ref[idx1] = (int8)(val1);
        if(--nrofBytes1 <= 0) break;
        val1 >>= 8;
        idx1 += idxStep;
      }while(true);/*see break;*/
    
  }
  STACKTRC_LEAVE;
}


/**Increments the {@link #ixNextChild} and/or increments the ixEnd of this and all parents.*/
void _expand_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 ixNextChildNew, int32 ixEndNew, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_expand_ByteDataAccessBaseJc");
  
  { 
    
    ASSERT(/*static*/ixEndNew < 0 || ixEndNew >= thiz->ixBegin + thiz->sizeHead);
    if(ixEndNew > thiz->data.value__) 
    { 
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      { throw_sJc(ident_IllegalArgumentExceptionJc, 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "child long as data, data.length= ", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->data.value__, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, ", ixChildEndNew= ", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, ixEndNew, _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }
    if(thiz->bExpand) 
    { 
      
      if(thiz->ixEnd < ixEndNew) 
      { /*:do it only in expand mode*/
        
        
        thiz->ixEnd = ixEndNew;
      }
      if(thiz->ixEnd < ixNextChildNew) 
      { /*:If ixEnd is less because it is the old one.*/
        /*:do it only in expand mode*/
        
        
        thiz->ixEnd = ixNextChildNew;
      }
      if(REFJc(thiz->parent) != null) 
      { 
        
        _expand_ByteDataAccessBaseJc(REFJc(thiz->parent), thiz->ixEnd, thiz->ixEnd, _thCxt);/*all parents nextChild set to end of child, expand the parent if necessary.*/
        
      }
    }
    else 
    { /*:not in expand mode*/
      
      
      if(ixEndNew >= 0) 
      { /*:-1: don't use!*/
        
        
        thiz->ixEnd = ixEndNew;/*it is valid.*/
        
      }
      if(REFJc(thiz->parent) != null) 
      { 
        
        _expand_ByteDataAccessBaseJc(REFJc(thiz->parent), ixEndNew, -1, _thCxt);/*all parents nextChild set to end of child, don't change the parent's ixEnd!*/
        
      }
    }
    if(thiz->ixNextChild < ixNextChildNew) 
    { 
      
      if(ixNextChildNew > thiz->ixEnd) 
      { 
        StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
        
        { throw_sJc(ident_IllegalArgumentExceptionJc, 
          ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
          , append_z_StringBuilderJc(_stringBuilderThCxt, "next child pos after ixend = ", _thCxt)
          , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->ixEnd, _thCxt)
          , append_z_StringBuilderJc(_stringBuilderThCxt, ", ixNextChilNew= ", _thCxt)
          , append_I_StringBuilderJc(_stringBuilderThCxt, ixNextChildNew, _thCxt)
          , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
          ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
      }
      thiz->ixNextChild = ixNextChildNew;
    }
  }
  STACKTRC_LEAVE;
}


/**Assigns new data to this element at given index in data*/
void assign_iYii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, PtrVal_int8 dataP, int32 lengthData, int32 index, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assign_iYii_ByteDataAccessBaseJc");
  
  { 
    
    ASSERT(/*static*/index >= 0 && thiz->sizeHead >= 0);
    detach_ByteDataAccessBaseJc(thiz, _thCxt);
    thiz->data = dataP;
    thiz->ixBegin = index;
    CLEAR_REFJc(thiz->parent);
    CLEAR_REFJc(thiz->currChild);
    thiz->bExpand = lengthData < thiz->sizeHead;/*expand if the data have no head.*/
    
    thiz->ixNextChild = thiz->ixBegin + thiz->sizeHead;/*lengthData is inclusively head. maybe checl lengthData, >=sizeHead or 0.*/
    
    thiz->ixEnd = thiz->bExpand ? thiz->ixBegin + thiz->sizeHead : thiz->ixBegin + lengthData;
    
    { /*:@Java4C.Exclude*/
      
      
      if(thiz->ixEnd > thiz->data.value__) 
      { 
        StringJc msg = CONST_z_StringJc("not enough data bytes, requested="); 
        
        StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
        
        msg = 
          ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
          , append_z_StringBuilderJc(_stringBuilderThCxt, "not enough data bytes, requested=", _thCxt)
          , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->ixEnd, _thCxt)
          , append_z_StringBuilderJc(_stringBuilderThCxt, ", buffer-length=", _thCxt)
          , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->data.value__, _thCxt)
          , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
          )/*J2C:non-persistent*/;
        { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
      }
    }
    
    { }
  }
  STACKTRC_LEAVE;
}


/**Returns true if the instance is set as expandable, see {@link #assign(byte[], int)}*/
bool isExpandable_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("isExpandable_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->bExpand;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the given head size, which is set on constructor respectively which is a determined value of an derived instance of this.*/
int32 sizeHead_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("sizeHead_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->sizeHead;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the data buffer itself*/
PtrVal_int8 getData_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getData_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->data;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the head*/
int32 getLengthHead_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLengthHead_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->sizeHead;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the element with all yet added children.*/
int32 getLengthCurrent_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLengthCurrent_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixNextChild - thiz->ixBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the existing actual element.*/
int32 getLength_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLength_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixEnd - thiz->ixBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the data.*/
int32 getLengthTotal_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLengthTotal_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixEnd;
    }
  }
  STACKTRC_LEAVE;
}


/**returns the number number of bytes there are max available from position of the current child.*/
int32 getMaxNrofBytes_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getMaxNrofBytes_ByteDataAccessBaseJc");
  
  { 
    
    if(thiz->bExpand) { STACKTRC_LEAVE;
      return thiz->data.value__ - thiz->ixBegin;
    }
    else { STACKTRC_LEAVE;
      return thiz->ixEnd - thiz->ixBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Checks whether a given size is possible as {@link #setLengthElement(int)} for the given instance.*/
bool checkLengthElement_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 size, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("checkLengthElement_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return size >= thiz->sizeHead && getMaxNrofBytes_ByteDataAccessBaseJc(thiz, _thCxt) >= size;
    }
  }
  STACKTRC_LEAVE;
}

bool getBigEndian_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getBigEndian_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->bBigEndian;
    }
  }
  STACKTRC_LEAVE;
}

bool isInUse_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("isInUse_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->data.ref != null;
    }
  }
  STACKTRC_LEAVE;
}


/**returns true if the given number of bytes is sufficing in the data from position of next child.*/
bool sufficingBytesForNextChild_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("sufficingBytesForNextChild_ByteDataAccessBaseJc");
  
  { 
    int32 maxNrofBytesChild; 
    
    
    maxNrofBytesChild = getMaxNrofBytesForNextChild_ByteDataAccessBaseJc(thiz, _thCxt);
    { STACKTRC_LEAVE;
      return nrofBytes < 0 ? false : maxNrofBytesChild >= nrofBytes;
    }
  }
  STACKTRC_LEAVE;
}


/**returns the maximal number of bytes which are available from position of a next current child.*/
int32 getMaxNrofBytesForNextChild_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getMaxNrofBytesForNextChild_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return (thiz->bExpand ? thiz->data.value__ : thiz->ixEnd) - thiz->ixNextChild;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child Element after the current child or as first child after head.*/
bool addChild_XXi_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* child, int32 sizeChild, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChild_XXi_ByteDataAccessBaseJc");
  
  { 
    int32 ixChild1; 
    
    
    detach_ByteDataAccessBaseJc(child, _thCxt);/*detatch the child from further usage.*/
    
    ASSERT(/*static*/sizeChild == 0 || sizeChild >= child->sizeHead);
    ASSERT(/*static*/child->sizeHead >= 0);
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, sizeChild == 0 ? child->sizeHead : sizeChild, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return false;
    }
    child->ixBegin = ixChild1;
    child->bBigEndian = thiz->bBigEndian;
    child->bExc = thiz->bExc;
    child->bExpand = thiz->bExpand;
    child->data = thiz->data;
    SETREFJc(child->parent, thiz, ByteDataAccessBaseJc_s);
    child->charset = thiz->charset;
    child->ixNextChild = child->ixBegin + child->sizeHead;/*the child does not contain grand children.*/
    
    child->ixEnd = thiz->ixEnd;/*bExpand ? child.ixNextChild : this.ixEnd;  //use the full data range maybe for child.*/
    
    SETREFJc(thiz->currChild, child, ByteDataAccessBaseJc_s);
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child with its given head size without additional data space.*/
bool addChild_XX_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* child, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChild_XX_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return addChild_XXi_ByteDataAccessBaseJc(thiz, child, child->sizeHead, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

bool addChildEmpty_XX_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* child, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildEmpty_XX_ByteDataAccessBaseJc");
  
  { 
    
    if(addChild_XX_ByteDataAccessBaseJc(thiz, child, _thCxt)) 
    { /*:first add the child*/
      
      
      clearHead_ByteDataAccessBaseJc(child);/*then clears its data.*/
      
      { STACKTRC_LEAVE;
        return true;
      }
    }
    else { STACKTRC_LEAVE;
      return false;
    }
  }
  STACKTRC_LEAVE;
}

bool addChildEmpty_XXi_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* child, int32 sizeChild, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildEmpty_XXi_ByteDataAccessBaseJc");
  
  { 
    
    if(addChild_XXi_ByteDataAccessBaseJc(thiz, child, sizeChild, _thCxt)) 
    { /*:first add the child*/
      
      
      clearData_ByteDataAccessBaseJc(child);/*then clears its data.*/
      
      { STACKTRC_LEAVE;
        return true;
      }
    }
    else { STACKTRC_LEAVE;
      return false;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child at any position*/
void addChildAt_iXXi_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxChild, struct ByteDataAccessBaseJc_t* child, int32 sizeChild, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildAt_iXXi_ByteDataAccessBaseJc");
  
  { 
    int32 idxBegin; 
    
    
    ASSERT(/*static*/child->sizeHead >= 0);
    ASSERT(/*static*/sizeChild >= child->sizeHead);
    if(REFJc(child->parent) != null && REFJc(REFJc(child->parent)->currChild) == child) 
    { 
      
      CLEAR_REFJc(REFJc(child->parent)->currChild);
    }/*detatch*/
    
    child->data = thiz->data;
    idxBegin = thiz->ixBegin + idxChild;
    child->ixBegin = idxBegin;
    child->ixEnd = idxBegin + sizeChild;
    child->ixNextChild = idxBegin + child->sizeHead;
    child->bBigEndian = thiz->bBigEndian;
    child->bExc = thiz->bExc;
    child->bExpand = thiz->bExpand;
    SETREFJc(child->parent, thiz, ByteDataAccessBaseJc_s);
    _expand_ByteDataAccessBaseJc(thiz, child->ixNextChild, child->ixEnd, _thCxt);/*return bExpand;*/
    
  }
  STACKTRC_LEAVE;
}


/**Adds a child at any position with its head size.*/
void addChildAt_iXX_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxChild, struct ByteDataAccessBaseJc_t* child, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildAt_iXX_ByteDataAccessBaseJc");
  
  { 
    
    addChildAt_iXXi_ByteDataAccessBaseJc(thiz, idxChild, child, child->sizeHead, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance, and sets the value as integer.*/
bool addChildInt_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildInt_ByteDataAccessBaseJc");
  
  { 
    int32 ixChild1; 
    
    
    ASSERT(/*static*/nrofBytes > 0);
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, nrofBytes, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return false;
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    _setInt_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, nrofBytes, value, _thCxt);
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance, and sets the value as integer.*/
bool addChildInteger_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, int64 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildInteger_ByteDataAccessBaseJc");
  
  { 
    int32 ixChild1; 
    
    
    ASSERT(/*static*/nrofBytes > 0);
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, nrofBytes, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return false;
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    _setLong_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, nrofBytes, value, _thCxt);
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 float value without a child instance, and sets the value as float.*/
bool addChildFloat_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, float value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildFloat_ByteDataAccessBaseJc");
  
  { 
    int32 ixChild1; 
    
    
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, 4, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return false;
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    setFloat_if_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, value);
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child with String value.*/
bool addChildString_SSb_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, StringJc value, StringJc sEncoding, bool preventCtrlChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildString_SSb_ByteDataAccessBaseJc");
  
  { 
    int32 nrofBytes; 
    int32 ixChild1; 
    
    
    nrofBytes = length_StringJc(value);
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, nrofBytes, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return false;
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    _setString_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, nrofBytes, value, sEncoding, preventCtrlChars, _thCxt);
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child with String value.*/
bool addChildString_SS_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, StringJc valueCs, StringJc sEncoding, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildString_SS_ByteDataAccessBaseJc");
  
  { 
    int32 nrofBytes; 
    int32 ixChild1; 
    
    
    nrofBytes = length_StringJc(valueCs);
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, nrofBytes, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return false;
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    { int32 ii; 
      for(ii = 0; ii < nrofBytes; ++ii)
        { 
          int8 charByte; 
          
          
          charByte = (int8)(charAt_StringJc(valueCs, ii));
          thiz->data.ref[ixChild1 + ii] = charByte;
        }
    }
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 short value without a child instance, returns the value as short.*/
int16 getChildInt16_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildInt16_ByteDataAccessBaseJc");
  
  { 
    int32 ixChild1; 
    
    
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, 2, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }
    { STACKTRC_LEAVE;
      return getInt16_i_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 short value without a child instance, returns the value as short.*/
int32 getChildUint16_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildUint16_ByteDataAccessBaseJc");
  
  { 
    int32 ixChild1; 
    
    
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, 2, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }
    { STACKTRC_LEAVE;
      return getUint16_i_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 short value without a child instance, returns the value as short.*/
int16 getChildUint8_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildUint8_ByteDataAccessBaseJc");
  
  { 
    int32 ixChild1; 
    
    
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, 1, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }
    { STACKTRC_LEAVE;
      return getUint8_i_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**adds a child for 1 integer value without a child instance and returns the value as long integer.*/
int64 getChildInteger_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildInteger_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    int32 bytes1; 
    int32 ixChild1; 
    int64 value; 
    
    
    bytes1 = nrofBytes < 0 ? -nrofBytes : nrofBytes;
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, bytes1, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }/*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    value = _getLong_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, nrofBytes, _thCxt);
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance and returns the value as 32-bit-integer.*/
int32 getChildInt_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildInt_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    int32 bytes1; 
    int32 ixChild1; 
    int32 value; 
    
    
    bytes1 = nrofBytes < 0 ? -nrofBytes : nrofBytes;
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, bytes1, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }/*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    value = _getInt_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, nrofBytes, _thCxt);
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 float value without a child instance, but returns the value as integer.*/
float getChildFloat_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildFloat_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    int32 ixChild1; 
    int32 intRepresentation; 
    
    
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, 4, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }/*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    intRepresentation = (int32)_getLong_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, 4, _thCxt);
    { STACKTRC_LEAVE;
      return intBitsToFloat_FloatJc(/*static*/intRepresentation);
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 double value without a child instance, but returns the value as integer.*/
double getChildDouble_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildDouble_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    int32 ixChild1; 
    int64 intRepresentation; 
    
    
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, 8, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return 0;
    }/*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    intRepresentation = _getLong_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, 8, _thCxt);
    { STACKTRC_LEAVE;
      return longBitsToDouble_DoubleJc(/*static*/intRepresentation);
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child for a String value without a child instance, but returns the value as String.*/
StringJc getChildString_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildString_ByteDataAccessBaseJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    int32 ixChild1; 
    
    
    ASSERT(/*static*/nrofBytes >= 0);
    ixChild1 = setIdxtoNextCurrentChild_ByteDataAccessBaseJc(thiz, nrofBytes, _thCxt);
    if(ixChild1 < 0) { STACKTRC_LEAVE;
      return null_StringJc;
    }/*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    { STACKTRC_LEAVE;
      return getString_ByteDataAccessBaseJc(thiz, ixChild1 - thiz->ixBegin, nrofBytes, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Shorten the evaluated content of the data to the position of the given child*/
void removeChild_XX_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* child, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("removeChild_XX_ByteDataAccessBaseJc");
  
  { 
    
    if(REFJc(child->parent) != thiz) { throw_s0Jc(ident_IllegalArgumentExceptionJc, "programming error - child is not parent of this.", 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    thiz->ixNextChild = child->ixBegin;/*set end index to the child's start*/
    
    if(thiz->bExpand) 
    { 
      
      thiz->ixEnd = thiz->ixNextChild;
    }
    if(REFJc(thiz->currChild) != null) 
    { 
      
      detach_ByteDataAccessBaseJc(REFJc(thiz->currChild), _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Remove all connections. Especially for children. */
void detach_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("detach_ByteDataAccessBaseJc");
  
  { 
    
    if(REFJc(thiz->parent) != null && REFJc(REFJc(thiz->parent)->currChild) == thiz) 
    { 
      
      CLEAR_REFJc(REFJc(thiz->parent)->currChild);/*detach in parent*/
      
    }
    if(REFJc(thiz->currChild) != null) 
    { 
      
      detach_ByteDataAccessBaseJc(REFJc(thiz->currChild), _thCxt);
      CLEAR_REFJc(thiz->currChild);/*necessary if currentChild don't refers this parent because any error before.*/
      
    }
    thiz->data.ref = null; thiz->data.value__ = 0;
    CLEAR_REFJc(thiz->parent);
    thiz->ixBegin = thiz->ixEnd = /*? assignment*/0;
    thiz->ixNextChild = 0;
    thiz->bExpand = false;
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the Element data in the assigned buffer.*/
int32 getPositionInBuffer_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getPositionInBuffer_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of a next child which can be added in the assigned buffer.*/
int32 getPositionNextChildInBuffer_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getPositionNextChildInBuffer_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixNextChild;
    }/*//*/
    
  }
  STACKTRC_LEAVE;
}


/**copies the data from another references data into this data.*/
void copyDataFrom_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, struct ByteDataAccessBaseJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("copyDataFrom_ByteDataAccessBaseJc");
  
  { 
    int32 len; 
    
    
    len = getLength_ByteDataAccessBaseJc(src, _thCxt);
    if(thiz->data.value__ < len) 
    { 
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "copy, dst to small", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, len, _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }/*//TODO System.arraycopy(src.data,src.idxBegin,data,idxBegin,len);*/
    
  }
  STACKTRC_LEAVE;
}


/**copies some data to a int[], primarily to debug a content.*/
void copyData_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32_Y* dst, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("copyData_ByteDataAccessBaseJc");
  
  { 
    int32 idxMax; 
    int32 iDst = 0; 
    
    
    idxMax = thiz->ixEnd - thiz->ixBegin;
    if(idxMax / 4 > dst->head.length) idxMax = 4 * dst->head.length;
    iDst = 0;
    { int32 idx; 
      for(idx = 0; idx < idxMax; idx += 4)
        { 
          
          dst->data[iDst++] = (int32)_getLong_ByteDataAccessBaseJc(thiz, idx, 4, _thCxt);
        }
    }
  }
  STACKTRC_LEAVE;
}


/**Returns a String from the given position inside the actual element .*/
StringJc getString_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getString_ByteDataAccessBaseJc");
  
  { 
    int32 idxData; 
    int32 idxEnd1; 
    int32 len; 
    StringJc value = NULL_StringJc; 
    
    
    idxData = idx + thiz->ixBegin;
    idxEnd1 = idxData + nrofBytes;
    ASSERT(/*static*/idxEnd1 <= thiz->ixEnd && idxEnd1 <= thiz->data.value__);
    
    while(thiz->data.ref[--idxEnd1] == 0 && idxEnd1 > idxData)
      ;/*skip 0 character on end*/
      
    len = idxEnd1 + 1 - idxData;
    /*no initvalue*/
    value = new_mBYIIEncoding_StringJc(/*static*/thiz->data, idxData, len, thiz->charset, _thCxt)/*J2C:non-persistent*/;
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets a String to the the given position inside the actual element .*/
int32 setString_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nmax, StringJc ss, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setString_ByteDataAccessBaseJc");
  
  { 
    ByteStringJc byteRepresentation;   /*Use a */
    int32 len; 
    
    
    if(length_StringJc(ss) > nmax) 
    { 
      
      ss = substring_StringJc(ss, 0, nmax, _thCxt)/*J2C:non-persistent*/;
    }/*truncate.*/
    
    /*no initvalue*/
    TRY
    { 
      
      byteRepresentation = getBytesEncoding_StringJc(ss, s0_StringJc("ISO-8859-1"), _thCxt);
    }_TRY
    CATCH(UnsupportedEncodingException, e)
    
      { 
        
        byteRepresentation = null_OS_PtrValue;
      }
    END_TRY
    len = length_ByteStringJc(byteRepresentation);
    if(len > nmax) 
    { 
      
      len = nmax;
    }/*truncate.*/
    
    arraycopy_vm_SystemJc(/*static*/byteRepresentation, 0, thiz->data, thiz->ixBegin + idx, len, _thCxt);
    { STACKTRC_LEAVE;
      return len;
    }
  }
  STACKTRC_LEAVE;
}


/**sets the content inside the actual element with the character bytes from the given String.*/
void _setString_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 nrofBytes, StringJc value, StringJc sEncoding, bool preventCtrlChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_setString_ByteDataAccessBaseJc");
  
  { 
    int32 idxData; 
    int32 idxEnd; 
    ByteStringJc chars;   /**/
    int32 srcLen; 
    
    
    idxData = idx + thiz->ixBegin;
    idxEnd = idxData + nrofBytes;
    /*no initvalue*/
    if(sEncoding.ref== null) 
    { 
      
      sEncoding = z_StringJc("ISO-8859-1")/*J2C:non-persistent*/;
    }
    chars = getBytesEncoding_StringJc(value, sEncoding, _thCxt);
    srcLen = length_ByteStringJc(chars);
    if(srcLen > nrofBytes) 
    { 
      
      srcLen = nrofBytes;
    }
    { int32 ii; 
      for(ii = 0; ii < srcLen; ++ii)
        { 
          int8 cc; 
          
          
          cc = ((/*J2C:cast% from ByteStringJc*/int8)(data_ByteStringJc(chars)[ii]));
          if(preventCtrlChars && cc < 0x20) 
          { 
            
            cc = ((/*J2C:cast% from int32*/int8)(0x3f));
          }/*'?' in ASCII*/
          
          thiz->data.ref[idxData++] = cc;
        }/*fill up the rest of the string with 0-chars.*/
        
    }
    
    while(idxData < idxEnd)
      { 
        
        thiz->data.ref[idxData++] = 0;
      }
  }
  STACKTRC_LEAVE;
}


/**Gets a float value from the content of 4 byte*/
float getFloat_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getFloat_i_ByteDataAccessBaseJc");
  
  { 
    int32 intRepresentation; 
    float value; 
    
    
    intRepresentation = getInt32_i_ByteDataAccessBaseJc(thiz, idx, _thCxt);
    value = intBitsToFloat_FloatJc(/*static*/intRepresentation);
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}

double getDouble_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getDouble_ByteDataAccessBaseJc");
  
  { 
    int64 intRepresentation; 
    
    
    intRepresentation = _getLong_ByteDataAccessBaseJc(thiz, idx, 8, _thCxt);
    { STACKTRC_LEAVE;
      return longBitsToDouble_DoubleJc(/*static*/intRepresentation);
    }
  }
  STACKTRC_LEAVE;
}

int64 getInt64_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt64_ByteDataAccessBaseJc");
  
  { 
    int32 nLo = 0; 
    int32 nHi = 0; 
    int64 val; 
    
    
    /*no initvalue*/
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      nLo = getInt32_i_ByteDataAccessBaseJc(thiz, idx, _thCxt);
      nHi = getInt32_i_ByteDataAccessBaseJc(thiz, idx + 4, _thCxt);
    }
    else 
    { 
      
      nLo = getInt32_i_ByteDataAccessBaseJc(thiz, idx + 4, _thCxt);
      nHi = getInt32_i_ByteDataAccessBaseJc(thiz, idx, _thCxt);
    }
    val = nHi << 32;
    val |= nLo & 0xffffffff;
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 4 bytes inside the actual element as a integer number between -2147483648 and 2147483647,*/
int32 getInt32_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt32_i_ByteDataAccessBaseJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      val = ((thiz->data.ref[thiz->ixBegin + idx]) << 24) | (((thiz->data.ref[thiz->ixBegin + idx + 1]) << 16) & 0xff0000) | (((thiz->data.ref[thiz->ixBegin + idx + 2]) << 8) & 0xff00) | (((thiz->data.ref[thiz->ixBegin + idx + 3])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    else 
    { 
      
      val = ((thiz->data.ref[thiz->ixBegin + idx + 3]) << 24) | (((thiz->data.ref[thiz->ixBegin + idx + 2]) << 16) & 0xff0000) | (((thiz->data.ref[thiz->ixBegin + idx + 1]) << 8) & 0xff00) | (((thiz->data.ref[thiz->ixBegin + idx])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint32_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint32_i_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return getInt32_i_ByteDataAccessBaseJc(thiz, idx, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 2 bytes as a positive nr between 0..65535, big-endian*/
int32 getUint16_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint16_i_ByteDataAccessBaseJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      val = (((thiz->data.ref[thiz->ixBegin + idx]) << 8) & 0xff00) | (((thiz->data.ref[thiz->ixBegin + idx + 1])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    else 
    { 
      
      val = (((thiz->data.ref[thiz->ixBegin + idx + 1]) << 8) & 0xff00) | (((thiz->data.ref[thiz->ixBegin + idx])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 2 bytes as a positive nr between 0..65535 inside the actual element.*/
int16 getInt16_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt16_i_ByteDataAccessBaseJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      val = (((thiz->data.ref[thiz->ixBegin + idx]) << 8) & 0xff00) | (((thiz->data.ref[thiz->ixBegin + idx + 1])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    else 
    { 
      
      val = (((thiz->data.ref[thiz->ixBegin + idx + 1]) << 8) & 0xff00) | (((thiz->data.ref[thiz->ixBegin + idx])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    { STACKTRC_LEAVE;
      return (int16)val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 bytes as ASCII*/
char getChar_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChar_ByteDataAccessBaseJc");
  
  { 
    char val = 0; 
    
    
    /*no initvalue*/
    val = (char)thiz->data.ref[thiz->ixBegin + idx];
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 bytes as a positive or negative nr between -128..127*/
int8 getInt8_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt8_i_ByteDataAccessBaseJc");
  
  { 
    int8 val = 0; 
    
    
    /*no initvalue*/
    val = thiz->data.ref[thiz->ixBegin + idx];
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 bytes as a positive or negative nr between -128..127*/
int16 getUint8_i_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint8_i_ByteDataAccessBaseJc");
  
  { 
    int16 val = 0; 
    
    
    /*no initvalue*/
    val = thiz->data.ref[thiz->ixBegin + idx];
    if(val < 0) 
    { 
      
      val += ((/*J2C:cast% from int32*/int16)(0x100));
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint32_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint32_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getUint16:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getUint32_i_ByteDataAccessBaseJc(thiz, idxBytes + 4 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt32_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt32_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getInt32:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getInt32_i_ByteDataAccessBaseJc(thiz, idxBytes + 4 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt16_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt16_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getInt16:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getInt16_i_ByteDataAccessBaseJc(thiz, idxBytes + 2 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt8_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt8_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getInt8:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getInt8_i_ByteDataAccessBaseJc(thiz, idxBytes + idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint16_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint16_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getUint16:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getUint16_i_ByteDataAccessBaseJc(thiz, idxBytes + 2 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint8_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint8_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getUint8:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getInt8_i_ByteDataAccessBaseJc(thiz, idxBytes + idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

float getFloat_iii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getFloat_iii_ByteDataAccessBaseJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getFloat:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getFloat_i_ByteDataAccessBaseJc(thiz, idxBytes + 4 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 4 bytes as a integer number between -2147483648 and 2147483647,*/
void setInt32_ii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt32_ii_ByteDataAccessBaseJc");
  
  { 
    
    if(thiz->bBigEndian) 
    { 
      
      thiz->data.ref[thiz->ixBegin + idx] = (int8)((value >> 24) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx + 1] = (int8)((value >> 16) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx + 2] = (int8)((value >> 8) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx + 3] = (int8)(value & 0xff);
    }
    else 
    { 
      
      thiz->data.ref[thiz->ixBegin + idx + 3] = (int8)((value >> 24) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx + 2] = (int8)((value >> 16) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx + 1] = (int8)((value >> 8) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx] = (int8)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 4 bytes as a positive nr between 0..2pow32-1, big- or little-endian.*/
void setUint32_il_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int64 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setUint32_il_ByteDataAccessBaseJc");
  
  { /*:the same algorithm in source, but other action on machine level,*/
    /*:because value is long!*/
    
    
    if(thiz->bBigEndian) 
    { 
      
      thiz->data.ref[thiz->ixBegin + idx] = (int8)((value >> 24) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx + 1] = (int8)((value >> 16) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx + 2] = (int8)((value >> 8) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx + 3] = (int8)(value & 0xff);
    }
    else 
    { 
      
      thiz->data.ref[thiz->ixBegin + idx + 3] = (int8)((value >> 24) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx + 2] = (int8)((value >> 16) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx + 1] = (int8)((value >> 8) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx] = (int8)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 2 bytes from an integer between -32768..32768,*/
void setInt16_ii_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 idx, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt16_ii_ByteDataAccessBaseJc");
  
  { 
    
    if(thiz->bBigEndian) 
    { 
      
      thiz->data.ref[thiz->ixBegin + idx] = (int8)((value >> 8) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx + 1] = (int8)(value & 0xff);
    }
    else 
    { 
      
      thiz->data.ref[thiz->ixBegin + idx + 1] = (int8)((value >> 8) & 0xff);
      thiz->data.ref[thiz->ixBegin + idx] = (int8)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}

void throwexc_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, StringJc text, int32 idxArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("throwexc_ByteDataAccessBaseJc");
  
  { 
    StringJc textExc; 
    
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    textExc = 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_s_StringBuilderJc(_stringBuilderThCxt, text, _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, textExc, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
  }
  STACKTRC_LEAVE;
}


/**Prepares a new child for this*/
int32 setIdxtoNextCurrentChild_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, int32 sizeChild, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIdxtoNextCurrentChild_ByteDataAccessBaseJc");
  
  { 
    int32 ixMax; 
    int32 ixChild1; 
    
    
    ASSERT(/*static*/sizeChild >= 0);
    ASSERT(/*static*/thiz->ixNextChild >= 0);/*==0 os possible on an empty element without head.*/
    
    ixMax = thiz->bExpand ? thiz->data.value__ : thiz->ixEnd;
    if(thiz->ixNextChild + sizeChild > ixMax) { STACKTRC_LEAVE;
      return illegalArgument_I_RetOrExceptionJc(/*static*/thiz->bExc, -1, s0_StringJc("child on limit of expand"), _thCxt);
    }
    ixChild1 = thiz->ixNextChild;
    thiz->ixNextChild += sizeChild;
    _expand_ByteDataAccessBaseJc(thiz, thiz->ixNextChild, thiz->ixEnd, _thCxt);/*expand always the ixChildEnd*/
    
    { STACKTRC_LEAVE;
      return ixChild1;
    }
  }
  STACKTRC_LEAVE;
}

int32 ixBegin_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("ixBegin_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixBegin;
    }
  }
  STACKTRC_LEAVE;
}

int32 ixNextChild_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("ixNextChild_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixNextChild;
    }
  }
  STACKTRC_LEAVE;
}

int32 ixEnd_ByteDataAccessBaseJc(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("ixEnd_ByteDataAccessBaseJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->ixEnd;
    }
  }
  STACKTRC_LEAVE;
}


void finalize_ByteDataAccessBaseJc_F(ByteDataAccessBaseJc_s* thiz, ThCxt* _thCxt)
{ STACKTRC_TENTRY("finalize_ByteDataAccessBaseJc_F");
  CLEAR_REFJc(thiz->parent);
  CLEAR_REFJc(thiz->currChild);
  STACKTRC_LEAVE;
}



extern_C struct ClassJc_t const reflection_ByteDataAccessBaseJc_s;
extern_C struct ClassJc_t const reflection_ByteDataAccessBaseJc_s;
extern_C struct ClassJc_t const reflection_CharsetJc;
extern_C struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_ByteDataAccessBaseJc_s_t
{ ObjectArrayJc head; FieldJc data[12];
} reflection_Fields_ByteDataAccessBaseJc_s =
{ CONST_ObjectArrayJc(FieldJc, 12, OBJTYPE_FieldJc, null, &reflection_Fields_ByteDataAccessBaseJc_s)
, {
     { "sizeHead"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->sizeHead) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "data"
    , 0 //nrofArrayElements
    , REFLECTION_int8
    , 1 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kPtrVal_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->data) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "ixBegin"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->ixBegin) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "ixNextChild"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->ixNextChild) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "ixEnd"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->ixEnd) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "bExpand"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->bExpand) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "bBigEndian"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->bBigEndian) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "bExc"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->bExc) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "parent"
    , 0 //nrofArrayElements
    , &reflection_ByteDataAccessBaseJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->parent) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "currChild"
    , 0 //nrofArrayElements
    , &reflection_ByteDataAccessBaseJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->currChild) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "charset"
    , 0 //nrofArrayElements
    , &reflection_CharsetJc
    , kReference_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessBaseJc_s*)(0x1000))->charset) - (int32)(ByteDataAccessBaseJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessBaseJc_s
    }
   , { "version"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&version_ByteDataAccessBaseJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&version_ByteDataAccessBaseJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_ByteDataAccessBaseJc_s
    }
} };
const ClassJc reflection_ByteDataAccessBaseJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "ByteDataAccessBaseJc_s"
,  0 //position of ObjectJc
, sizeof(ByteDataAccessBaseJc_s)
, (FieldJcArray const*)&reflection_Fields_ByteDataAccessBaseJc_s
, null //method
, null //superclass
, null //(ClassOffset_idxMtblJcARRAY*)&interfaces_ByteDataAccessBaseJc_s //interfaces
, 0    //modifiers
};
