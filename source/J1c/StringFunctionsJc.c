/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "J1c/StringFunctionsJc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "Jc/StringJc.h"  //embedded type in class data


/* J2C: Forward declaration of struct ***********************************************/

/**This class contains static String functions without any other dependency.
In C the functions are contained in the Fwc/fw_String.c.
@author Hartmut Schorrig

*/


const char sign_Mtbl_StringFunctionsJc[] = "StringFunctionsJc"; //to mark method tables of all implementations

typedef struct MtblDef_StringFunctionsJc_t { Mtbl_StringFunctionsJc mtbl; MtblHeadJc end; } MtblDef_StringFunctionsJc;
 extern MtblDef_StringFunctionsJc const mtblStringFunctionsJc;

/*Constructor *//**J2C: autogenerated as default constructor. */
struct StringFunctionsJc_t* ctorO_StringFunctionsJc(ObjectJc* othis, ThCxt* _thCxt)
{ StringFunctionsJc_s* ythis = (StringFunctionsJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringFunctionsJc");
  checkConsistence_ObjectJc(othis, sizeof(StringFunctionsJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringFunctionsJc_s, sizeof(StringFunctionsJc_s));  
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}



/**Returns the position of the end of an identifier.*/
int32 posAfterIdentifier_tii_StringFunctionsJc(/*static*/ StringJc src, int32 start, int32 endMax, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("posAfterIdentifier_tii_StringFunctionsJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return posAfterIdentifier_tiiSS_StringFunctionsJc(/*static*/src, start, endMax, null_StringJc, null_StringJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the end of an identifier.*/
int32 posAfterIdentifier_tiiSS_StringFunctionsJc(/*static*/ StringJc src, int32 start, int32 endMax, StringJc additionalStartChars, StringJc additionalChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("posAfterIdentifier_tiiSS_StringFunctionsJc");
  
  { 
    int32 pos; 
    char cc; 
    
    
    pos = start;
    cc = charAt_StringJc(src, pos);
    if(cc == '_' || (cc >= 'A' && cc <= 'Z') || (cc >= 'a' && cc <= 'z') || (additionalStartChars.ptr__!= null && indexOf_C_StringJc(additionalStartChars, cc) >= 0)) 
    { 
      
      pos += 1;
      
      while(pos < endMax && ((cc = /*? assignment*/charAt_StringJc(src, pos)) == '_' || (cc >= '0' && cc <= '9') || (cc >= 'A' && cc <= 'Z') || (cc >= 'a' && cc <= 'z') || (additionalChars.ptr__!= null && indexOf_C_StringJc(additionalChars, cc) >= 0)))
        { 
          
          pos += 1;
        }
    }
    { STACKTRC_LEAVE;
      return pos;
    }
  }
  STACKTRC_LEAVE;
}


/**Parses a given String and convert it to the integer number.*/
int32 parseIntRadix_StringFunctionsJc(/*static*/ StringJc srcP, int32 pos, int32 sizeP, int32 radix, int32_Y* parsedChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("parseIntRadix_StringFunctionsJc");
  
  { 
    int32 val = 0; 
    bool bNegativ = 0; 
    int32 digit = 0; 
    char cc = 0; 
    int32 ixSrc; 
    int32 size; 
    int32 maxDigit; 
    int32 maxHexDigitLower = 'A'/*J2C: no cast found from char=char: ClassData@128340*/; 
    int32 maxHexDigitUpper = 'a'/*J2C: no cast found from char=char: ClassData@128340*/; 
    
    
    val = 0;
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    ixSrc = pos;
    size = length_StringJc(srcP) - pos;
    if(size > sizeP) 
    { 
      
      size = sizeP;
    }
    maxDigit = ((/*J2C:cast% from char*/int32)((radix <= 10) ? '0' + radix - 1 : '9'));
    maxHexDigitLower = ((/*J2C:cast% from char*/int32)('A' + radix - 11));
    maxHexDigitUpper = ((/*J2C:cast% from char*/int32)('a' + radix - 11));
    if(charAt_StringJc(srcP, ixSrc) == '-') 
    { 
      
      ixSrc += 1;
      size -= 1;
      bNegativ = true;
    }
    else 
    { 
      
      bNegativ = false;
    }
    
    while(size > 0 && (digit = /*? assignment*/(cc = /*? assignment*/charAt_StringJc(srcP, ixSrc)) - '0') >= 0 && (cc <= maxDigit || (radix > 10 && (cc >= 'A' && (digit = /*? assignment*/(cc - 'A' + 10)) <= radix || cc >= 'a' && (digit = /*? assignment*/(cc - 'a' + 10)) <= radix))))
      { 
        
        val = radix * val + digit;
        ixSrc += 1;
        size -= 1;
      }
    if(bNegativ) 
    { 
      
      val = -val;
    }
    if(parsedChars != null) 
    { 
      
      parsedChars->data[0] = ixSrc - pos;
    }
    { STACKTRC_LEAVE;
      return (val);
    }
  }
  STACKTRC_LEAVE;
}


/**Parses a given String backward and convert it to the integer number.*/
int32 parseIntRadixBack_StringFunctionsJc(/*static*/ StringJc srcP, int32 pos, int32 sizeP, int32 radix, int32_Y* parsedChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("parseIntRadixBack_StringFunctionsJc");
  
  { 
    int32 val = 0; 
    bool bNegativ = 0; 
    int32 digit = 0; 
    char cc = 0; 
    int32 ixSrc; 
    int32 size; 
    int32 maxDigit; 
    int32 maxHexDigitLower = 'A'/*J2C: no cast found from char=char: ClassData@128340*/; 
    int32 maxHexDigitUpper = 'a'/*J2C: no cast found from char=char: ClassData@128340*/; 
    int32 multPosition = 1; 
    
    
    val = 0;
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    ixSrc = pos;
    size = length_StringJc(srcP) - pos;
    if(size > sizeP) 
    { 
      
      size = sizeP;
    }
    maxDigit = ((/*J2C:cast% from char*/int32)((radix <= 10) ? '0' + radix - 1 : '9'));
    maxHexDigitLower = ((/*J2C:cast% from char*/int32)('A' + radix - 11));
    maxHexDigitUpper = ((/*J2C:cast% from char*/int32)('a' + radix - 11));
    multPosition = 1;
    
    while(size > 0 && ixSrc >= 0 && (digit = /*? assignment*/(cc = /*? assignment*/charAt_StringJc(srcP, ixSrc)) - '0') >= 0 && (cc <= maxDigit || (radix > 10 && (cc >= 'A' && (digit = /*? assignment*/(cc - 'A' + 10)) <= radix || cc >= 'a' && (digit = /*? assignment*/(cc - 'a' + 10)) <= radix))))
      { 
        
        val += multPosition * digit;
        multPosition *= radix;
        ixSrc -= 1;
        size -= 1;
      }
    if(size > 0 && ixSrc >= 0 && charAt_StringJc(srcP, ixSrc) == '-') 
    { 
      
      ixSrc -= 1;
      size -= 1;
      val = -val;
    }
    if(parsedChars != null) 
    { 
      
      parsedChars->data[0] = pos - ixSrc;
    }
    { STACKTRC_LEAVE;
      return (val);
    }
  }
  STACKTRC_LEAVE;
}


/**Parses a given String and convert it to the float number.*/
float parseFloat_StringFunctionsJc(/*static*/ StringJc src, int32 pos, int32 sizeP, int32_Y* parsedCharsP, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("parseFloat_StringFunctionsJc");
  
  { 
    int32 parsedChars = 0; 
    float ret = 0; 
    int32 size; 
    int32_Y* zParsed; 
    int32 ixsrc; 
    
    ObjectJc *newObj1_1=null; //J2C: temporary Objects for new operations
    
    parsedChars = 0;
    /*no initvalue*/
    size = length_StringJc(src) - pos;
    if(size > sizeP) 
    { 
      
      size = sizeP;
    }
    
    zParsed = (int32_Y*)ctorO_ObjectArrayJc((newObj1_1 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (1) * sizeof(int32), mIsLargeSize_objectIdentSize_ObjectJc, _thCxt)), 1, sizeof(int32),REFLECTION_int32, 0);
    ret = (float)parseIntRadix_StringFunctionsJc(/*static*/src, pos, size, 10, zParsed, _thCxt);
    parsedChars += zParsed->data[0];//maybe 0 if .123 is written
    
    ixsrc = pos + zParsed->data[0];
    size -= zParsed->data[0];
    if(charAt_StringJc(src, ixsrc) == '.') 
    { 
      float fracPart; 
      
      
      fracPart = (float)parseIntRadix_StringFunctionsJc(/*static*/src, ixsrc + 1, size - 1, 10, zParsed, _thCxt);
      if(zParsed->data[0] > 0) 
      { 
        
        switch(zParsed->data[0]){
          case 1: fracPart *= 0.1F;break;
          case 2: fracPart *= 0.01F;break;
          case 3: fracPart *= 0.0010F;break;
          case 4: fracPart *= 1.0E-4F;break;
          case 5: fracPart *= 9.999999999999999E-6F;break;
          case 6: fracPart *= 1.0E-6F;break;
          case 7: fracPart *= 1.0E-7F;break;
          case 8: fracPart *= 1.0E-8F;break;
          case 9: fracPart *= 1.0E-9F;break;
          case 10: fracPart *= 1.0E-10F;break;
        }/*switch*/;
        ret += fracPart;
      }
      parsedChars += zParsed->data[0] + 1;//maybe 0 if .123 is written
      
      size -= zParsed->data[0] - 1;
    }//TODO exponent
    
    if(parsedCharsP != null) 
    { 
      
      parsedCharsP->data[0] = parsedChars;
    }
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, null, _thCxt);
      return ret;
    }
  }
  STACKTRC_LEAVE;
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_StringFunctionsJc mtblStringFunctionsJc = {
{ { sign_Mtbl_StringFunctionsJc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern_C struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_StringFunctionsJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_StringFunctionsJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_StringFunctionsJc, ObjectJc) }
   }
 };

const ClassJc reflection_StringFunctionsJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "StringFunctionsJc_s"
,  0 //position of ObjectJc
, sizeof(StringFunctionsJc_s)
, null //attributes and associations
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_StringFunctionsJc_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblStringFunctionsJc.mtbl.head
};
