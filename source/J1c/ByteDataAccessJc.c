/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "J1c/ByteDataAccessJc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "Fwc/fw_Exception.h"  //reference-association: ExceptionJc
#include "Jc/ArraysJc.h"  //reference-association: ArraysJc
#include "Jc/MathJc.h"  //reference-association: MathJc_s
#include "Jc/SystemJc.h"  //reference-association: FloatJc


/* J2C: Forward declaration of struct ***********************************************/


/* J2C: Method-table-references *********************************************************/
#ifndef ByteDataAccessJcMTBDEF
  #define ByteDataAccessJcMTBDEF
  typedef struct ByteDataAccessJcMTB_t { struct Mtbl_ByteDataAccessJc_t const* mtbl; struct ByteDataAccessJc_t* ref; } ByteDataAccessJcMTB;
#endif


/**This class is a base class to control the access to binary data.
The binary data may typically used or produced from a part of software written in C or C++.
There the binary data are struct-constructs. Another example - build of datagram structures.
<br>
This class is a base class which should be derived for user's necessities.
The methods {@link #getInt16(int)} etc. are protected. That should prevent erratic free accesses to data
at application level. A derived class of this class structures the software for byte data access.
<br><br>
It is able to support several kinds of structured data access:<ul>
<li>Simple C-like <code>struct</code> are adequate mapped with a simple derived class of this class,
using the protected commonly access methods like {@link #_getLong(int, int)} with predefined indexes
in special methods like getValueXyz().</li>
<li>Complex <code>struct</code> with nested <code>struct</code> inside are mapped
with one derived class per <code>struct</code>, define one reference per nested struct
and overwriting the method {@link #assignDataToFixChilds()}</li>
<li>Base <code>struct</code> inside a <code>struct</code> (inheritance in C) can be mapped with
extra derived classes for the base struct and usind the
{@link assignCasted_i(ByteDataAccess, int)}-method.</li>
<li>A pack of data with several struct may be mapped using the {@addChild(ByteDataAccess)}-method.
Thereby a parent should be defined, and the structs of the pack are children of this parent.
That structs need not be from the same type.</li>
<li>packs of struct with parent are nestable, it is constructable as a tree of pack of structs.
The parent of the pack is the tree node. It is likewise a XML tree.
The data may be also transformed to a XML data representation
or the data structure may be explained with a XML tree, but they are not
XML data straight.</li>
</ul>
This application possibilities show a capable of development system to access binary data.
The other, hand made way was calculate with indices of the byte[idx] specially user programmed.
This class helps to make such complex index calculation needlessly.
One struct at C level corresponds with one derivated class of ByteDataAccess.
But last also a generation of the java code from C/C++-header files containing the structs is able to.
So the definition of byte positions are made only on one source. The C/C++ is primary thereby.

<h2>children, currentChild, addChild</h2>
Children are used to evaluate or write different data structures after a known structure.
The children may be from several derived types of this class.
With children and children inside children a tree of different data can be built or evaluated.

If no child is added yet, the indices have the following values:
<ul>
<li>idxCurrentChild = -1.
<li>idxCurrentChildEnd = index after known (head-) data.
</ul>
<ul>
<li>idxCurrentChild = the index after the last known child or known (head-) data.
It is idxCurrentChildEnd from state before.
<li>idxCurrentChildEnd = -2, because the length of the child is unknown.
The -2 is used to mark call of next().
</ul>
A call of {@link addChild()} or its adequate addChildXY() sets the indices to the given current child:
<ul>
<li>idxCurrentChild = the index after known (first head-) data, the index of the child.
<li>idxCurrentChildEnd = idxCurrentChild + {@link specifyLengthElement()} if this method returns >=0.
<li>idxCurrentChildEnd = idxCurrentChild + {@link specifyLengthElementHead()} if this method returns >=0.
<li>idxCurrentChildEnd = -1, because the length of the child is not known yet if both methods return -1.
</ul>
The length of the current Child may be set while evaluating the child's data.
The user should call {@link #setLengthElement(int)} with the child
or {@link #setLengthCurrentChildElement(int)} with the parent, respectively with this.
<ul>
<li>idxCurrentChild = is still the index of the child.
<li>idxCurrentChildEnd = idxCurrentChild + given length.
</ul>
If this methods are not called, but next() or addChild...() is called however, without a known length
but this (the parent) knows the rules to determine the length of its possible children,
it is possible to do that. The method {@link specifyLengthCurrentChildElement()} supplied the number of bytes.
But if this method is not overwritten in the inherited class, an exception is thrown.


<br>
The UML structure of such an class in a environment may be shown with the
followed object model diagram, <br>
<code> <+>---> </code>is a composition,
<code> <>---> </code>is a aggregation, <code> <|---- </code>is a inherition.
<pre>
+-------------------------------+                 +----------+
| ByteDataAccess                |----data-------->| byte[]   |
|-------------------------------|                 +----------+
|idxBegin:int                   |
|idxChild:int                   |<---------------+ a known parent
+-------------+     |idxEnd:int                     |---parent-------+ setted in addChild()
| derivated   |     |-------------------------------|
| user        |---|>|specifyLengthElement()         |
| classes     |     |specifyLengthElementHead()     |
+-------------+     |specifyLengthCurrentChild()    |
+-------------------------------+
</pre>

*/


const char sign_Mtbl_ByteDataAccessJc[] = "ByteDataAccessJc"; //to mark method tables of all implementations

const int8 kNothing_ByteDataAccessJc = (int8)(0xff);

/*Constructor */
struct ByteDataAccessJc_t* ctorO_ByteDataAccessJc(ObjectJc* othis, ThCxt* _thCxt)
{ ByteDataAccessJc_s* thiz = (ByteDataAccessJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_ByteDataAccessJc");
  checkConsistence_ObjectJc(othis, sizeof(ByteDataAccessJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_ByteDataAccessJc_s, sizeof(ByteDataAccessJc_s));  
  //j2c: Initialize all class variables:
  {
    CLEAR_REFJc(thiz->toStringformatter);
  }
  { 
    
    thiz->data = null;
    thiz->bBigEndian = false;
    thiz->bExpand = false;
    thiz->idxBegin = 0;
    thiz->idxEnd = 0;
    thiz->idxFirstChild = 0;
    thiz->idxCurrentChild = -1;/*to mark start.*/
    
    thiz->idxCurrentChildEnd = 0;
    CLEAR_REFJc(thiz->parent);/*currentChild = null;*/
    
    set_StringJc(&(thiz->charset), z_StringJc("ISO-8859-1"));
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct ByteDataAccessJc_t* ctorO_ii_ByteDataAccessJc(ObjectJc* othis, int32 sizeHead, int32 sizeData, ThCxt* _thCxt)
{ ByteDataAccessJc_s* thiz = (ByteDataAccessJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_ByteDataAccessJc");
  checkConsistence_ObjectJc(othis, sizeof(ByteDataAccessJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_ByteDataAccessJc_s, sizeof(ByteDataAccessJc_s));  
  //j2c: Initialize all class variables:
  {
    CLEAR_REFJc(thiz->toStringformatter);
  }
  { 
    
    thiz->data = null;
    thiz->bBigEndian = false;
    thiz->bExpand = false;
    thiz->idxBegin = 0;
    thiz->idxEnd = sizeData;
    thiz->idxFirstChild = sizeHead;
    thiz->idxCurrentChild = -1;/*to mark start.*/
    
    thiz->idxCurrentChildEnd = kInitializedWithLength_ByteDataAccessJc;
    CLEAR_REFJc(thiz->parent);/*currentChild = null;*/
    
    set_StringJc(&(thiz->charset), z_StringJc("ISO-8859-1"));
  }
  STACKTRC_LEAVE;
  return thiz;
}



/**Sets the elements data to the default empty data.*/
/*J2C: dynamic call variant of the override-able method: */
void specifyEmptyDefaultData_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  mtbl->specifyEmptyDefaultData(thiz, _thCxt);
}


/**Specifies the length of the head data*/
/*J2C: dynamic call variant of the override-able method: */
int32 specifyLengthElementHead_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  return mtbl->specifyLengthElementHead(thiz, _thCxt);
}


/**Returns the actual length of the whole data presenting with this instance.*/
/*J2C: dynamic call variant of the override-able method: */
int32 specifyLengthElement_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  return mtbl->specifyLengthElement(thiz, _thCxt);
}


/**Notifies, that a child is added*/
void notifyAddChild_ByteDataAccessJc_F(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("notifyAddChild_ByteDataAccessJc_F");
  
  { /*:in default, do nothing with this.*/
    
    
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void notifyAddChild_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  mtbl->notifyAddChild(thiz, _thCxt);
}


/**Returns the length of a child element at current position specified in  the derivated class.*/
int32 specifyLengthCurrentChildElement_ByteDataAccessJc_F(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("specifyLengthCurrentChildElement_ByteDataAccessJc_F");
  
  { 
    
    { throw_s0Jc(ident_IllegalArgumentExceptionJc, "The length of the child is undefined, no user specification is known", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 specifyLengthCurrentChildElement_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  return mtbl->specifyLengthCurrentChildElement(thiz, _thCxt);
}


/**This method is called inside all assign...() methods.*/
void assignDataToFixChilds_ByteDataAccessJc_F(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assignDataToFixChilds_ByteDataAccessJc_F");
  
  { 
    
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void assignDataToFixChilds_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  mtbl->assignDataToFixChilds(thiz, _thCxt);
}


/**Sets the big or little endian mode.*/
void setBigEndian_ByteDataAccessJc_F(ByteDataAccessJc_s* thiz, bool val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setBigEndian_ByteDataAccessJc_F");
  
  { 
    
    thiz->bBigEndian = val;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void setBigEndian_ByteDataAccessJc(ByteDataAccessJc_s* thiz, bool val, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  mtbl->setBigEndian(thiz, val, _thCxt);
}


/**Resets the view to the buffer*/
void reset_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 lengthHead, int32 lengthData, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("reset_ByteDataAccessJc");
  
  { 
    int32 lengthHeadSpecified; 
    
    
    lengthHeadSpecified = lengthHead < 0 ? mtthis->specifyLengthElementHead(thiz, _thCxt) : lengthHead;
    if(lengthData <= 0) 
    { 
      
      mtthis->specifyEmptyDefaultData(thiz, _thCxt);
      thiz->bExpand = true;
    }
    else 
    { 
      
      thiz->bExpand = lengthData <= 0;/*expand if the data have no head.*/
      
    }
    /*if(currentChild !=null){*/
    thiz->idxCurrentChild = -1;
    thiz->idxFirstChild = thiz->idxCurrentChildEnd = /*? assignment*/thiz->idxBegin + lengthHeadSpecified;/*NOTE: problem in last version? The idxBegin ... idxEnd should be the number of given data.*/
    
    thiz->idxEnd = thiz->bExpand ? thiz->idxFirstChild : thiz->idxBegin + lengthData;
    if(thiz->idxEnd > thiz->data->head.length) 
    { 
      StringJc msg = CONST_z_StringJc("not enough data bytes, requested="); 
      
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      msg = 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "not enough data bytes, requested=", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->idxEnd, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, ", buffer-length=", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->data->head.length, _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
      { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }
  }
  STACKTRC_LEAVE;
}


/**Assigns new data to this element at given index in data.*/
void assignData_iYiii_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int8_Y* dataP, int32 lengthHead, int32 lengthData, int32 index, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("assignData_iYiii_ByteDataAccessJc");
  
  { 
    
    thiz->data = dataP;
    if(index < 0) 
    { 
      
      { throw_s0Jc(ident_RuntimeExceptionJc, "idx have to be >=0", 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }
    thiz->idxBegin = index;
    /*if(parent!= null && parent.currentChild == this)*/
    CLEAR_REFJc(thiz->parent);
    reset_ByteDataAccessJc(thiz, lengthHead, lengthData, _thCxt);
    mtthis->assignDataToFixChilds(thiz, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Initializes a top level, the data are considered as non initalized.*/
void assignEmpty_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int8_Y* data, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("assignEmpty_ByteDataAccessJc");
  
  { 
    
    TRY
    { 
      
      assignData_iYii_ByteDataAccessJc(thiz, data, -1, 0);
    }_TRY
    CATCH(IllegalArgumentException, e)
    
      { 
        
        
      }
    END_TRY
    mtthis->specifyEmptyDefaultData(thiz, _thCxt);/*overrideable*/
    
  }
  STACKTRC_LEAVE;
}


/**assigns the element to the given position of the parents data to present a child of the parent*/
void assignAtIndex_iiXX_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idxChildInParent, int32 lengthChild, struct ByteDataAccessJc_t* parent, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("assignAtIndex_iiXX_ByteDataAccessJc");
  
  { 
    
    thiz->bBigEndian = parent->bBigEndian;
    thiz->bExpand = parent->bExpand;
    assignData_iYii_ByteDataAccessJc(thiz, parent->data, parent->idxBegin + idxChildInParent + lengthChild, parent->idxBegin + idxChildInParent);
    mtthis->setBigEndian(thiz, parent->bBigEndian, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**assigns the element to the given position of the parents data to present a child of the parent.*/
void assignAtIndex_iXX_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idxChildInParent, struct ByteDataAccessJc_t* parent, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("assignAtIndex_iXX_ByteDataAccessJc");
  
  { 
    int32 lengthHead; 
    int32 lengthData = 0; 
    
    
    lengthHead = getLengthHead_ByteDataAccessJc(thiz);
    /*no initvalue*/
    if(thiz->idxCurrentChildEnd == kInitializedWithLength_ByteDataAccessJc) 
    { 
      
      lengthData = thiz->idxEnd;
    }
    else 
    { 
      
      lengthData = -1;/*unknown*/
      
    }
    assignData_iYiii_ByteDataAccessJc(thiz, parent->data, lengthHead, lengthData, parent->idxBegin + idxChildInParent, _thCxt);
    mtthis->setBigEndian(thiz, parent->bBigEndian, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**adds an child Element after the current child or as first child after head.*/
bool addChild_ByteDataAccessJc(ByteDataAccessJc_s* thiz, struct ByteDataAccessJc_t* child, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("addChild_ByteDataAccessJc");
  
  { 
    int32 sizeChildHead = 0; 
    int32 sizeChild = 0; 
    ByteDataAccessJcMTB childMtb;   /**/
    int32 sizeChild1 = 0; 
    int32 idxEndNew; 
    
    
    mtthis->notifyAddChild(thiz, _thCxt);
    /*no initvalue*/
    /*no initvalue*/
    if(child->idxCurrentChildEnd == kInitializedWithLength_ByteDataAccessJc) 
    { /*:initialized child with its local length:*/
      
      
      sizeChildHead = child->idxFirstChild;
      sizeChild = child->idxEnd;
    }
    else 
    { /*:uninitialized child with length, or reused child:*/
      
      
      sizeChildHead = sizeChild = /*? assignment*/-1;
    }
    child->bBigEndian = thiz->bBigEndian;
    child->bExpand = thiz->bExpand;
    setIdxtoNextCurrentChild_ByteDataAccessJc(thiz, _thCxt);
    SETMTBJc(childMtb, child, ByteDataAccessJc);
    /*no initvalue*/
    if(sizeChild <= sizeChildHead) 
    { /*:especially -1, the size is unknown.*/
      
      
      if(thiz->bExpand) 
      { 
        
        sizeChild1 = -1;
      }/*initialize with specifyLength()*/
      
      else 
      { 
        
        sizeChild1 = thiz->idxEnd - thiz->idxCurrentChild;
      }/*the child fills the parent.*/
      
    }
    else 
    { 
      
      sizeChild1 = sizeChild;/*given size is valid.*/
      
    }
    assignData_iYiii_ByteDataAccessJc( (childMtb.ref), thiz->data, sizeChildHead, sizeChild1, thiz->idxCurrentChild, _thCxt);
    childMtb.mtbl->setBigEndian( (childMtb.ref), thiz->bBigEndian, _thCxt);
    SETREFJc(child->parent, thiz, ByteDataAccessJc_s);/*this.currentChild = child;*/
    
    idxEndNew = child->idxEnd > child->idxCurrentChildEnd ? child->idxEnd : child->idxCurrentChildEnd;
    expand_ByteDataAccessJc(thiz, idxEndNew, _thCxt);
    { STACKTRC_LEAVE;
      return thiz->bExpand;
    }
  }
  STACKTRC_LEAVE;
}


/**sets the idxCurrentChild to the known idxCurrentChildEnd.*/
void setIdxtoNextCurrentChild_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIdxtoNextCurrentChild_ByteDataAccessJc");
  
  { 
    
    if(thiz->idxCurrentChildEnd >= thiz->idxCurrentChild) 
    { /*:This is the standard case.*/
      /*:NOTE: idxCurrentChild = -1 is assert if no child is added before.*/
      
      
      thiz->idxCurrentChild = thiz->idxCurrentChildEnd;
    }
    else if(thiz->idxCurrentChildEnd == -2) 
    { }
    else 
    { 
      
      { throw_s0Jc(ident_RuntimeExceptionJc, "unexpected idxCurrentChildEnd", 0, &_thCxt->stacktraceThreadContext, __LINE__); };/*its a programming error.*/
      
    }
    thiz->idxCurrentChildEnd = -1;/*the child content is not checked, this index will be set if setLengthCurrentChildElement() is called.*/
    
  }
  STACKTRC_LEAVE;
}


/**sets the idxCurrentChildEnd and idxEnd*/
bool setIdxCurrentChildEnd_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIdxCurrentChildEnd_ByteDataAccessJc");
  
  { 
    
    if(thiz->bExpand) 
    { 
      
      if(thiz->data->head.length < thiz->idxCurrentChild + nrofBytes) 
      { 
        StringJc msg = CONST_z_StringJc("data length to small:"); 
        
        StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
        
        msg = 
          ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
          , append_z_StringBuilderJc(_stringBuilderThCxt, "data length to small:", _thCxt)
          , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->idxCurrentChild + nrofBytes), _thCxt)
          , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
          )/*J2C:non-persistent*/;
        { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    else 
    { 
      
      if(thiz->idxEnd < thiz->idxCurrentChildEnd) 
      { /*:not expand, but the nrof data are to few*/
        
        StringJc msg = CONST_z_StringJc("to few user data:"); 
        
        StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
        
        msg = 
          ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
          , append_z_StringBuilderJc(_stringBuilderThCxt, "to few user data:", _thCxt)
          , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->idxCurrentChild + nrofBytes), _thCxt)
          , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
          )/*J2C:non-persistent*/;
        { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    expand_ByteDataAccessJc(thiz, thiz->idxCurrentChild + nrofBytes, _thCxt);/*also of all parents*/
    
    { STACKTRC_LEAVE;
      return thiz->bExpand;
    }
  }
  STACKTRC_LEAVE;
}


/**Increments the idxEnd and the idxCurrentChildEnd if a new child is added*/
void correctCurrentChildEnd_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idxEndNew, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("correctCurrentChildEnd_ByteDataAccessJc");
  
  { 
    
    if(thiz->idxEnd < idxEndNew) 
    { 
      
      thiz->idxEnd = idxEndNew;
    }
    if(thiz->idxCurrentChildEnd < idxEndNew) 
    { 
      
      thiz->idxCurrentChildEnd = idxEndNew;
    }
    if(REFJc(thiz->parent) != null) 
    { 
      
      correctCurrentChildEnd_ByteDataAccessJc(REFJc(thiz->parent), idxEndNew, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Increments the idxEnd if a new child is added*/
void expand_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idxCurrentChildEndNew, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("expand_ByteDataAccessJc");
  
  { 
    
    if(thiz->bExpand) 
    { /*:do it only in expand mode*/
      
      
      thiz->idxEnd = idxCurrentChildEndNew;
    }
    ASSERT(/*static*/idxCurrentChildEndNew >= thiz->idxFirstChild);
    thiz->idxCurrentChildEnd = idxCurrentChildEndNew;
    if(REFJc(thiz->parent) != null) 
    { 
      
      expand_ByteDataAccessJc(REFJc(thiz->parent), idxCurrentChildEndNew, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Expands the end index of the parent, it means the management*/
void expandParent_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("expandParent_ByteDataAccessJc");
  
  { 
    
    if(thiz->idxBegin == 0 && REFJc(thiz->parent) == null) 
    { }
    else if(REFJc(thiz->parent) != null) 
    { 
      
      if(REFJc(thiz->parent)->idxEnd < thiz->idxEnd) 
      { 
        
        REFJc(thiz->parent)->idxEnd = thiz->idxEnd;
      }
      expandParent_ByteDataAccessJc(REFJc(thiz->parent), _thCxt);
    }
    else { throw_s0Jc(ident_IllegalArgumentExceptionJc, "invalid expandParent()", 0, &_thCxt->stacktraceThreadContext, __LINE__); };
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance, but returns the value as integer.*/
int64 getChildInteger_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildInteger_ByteDataAccessJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(thiz, _thCxt);
    if(!setIdxCurrentChildEnd_ByteDataAccessJc(thiz, abs(/*static*/nrofBytes), _thCxt)) 
    { /*:NOTE: to read from idxInChild = 0, build the difference as shown:*/
      
      int64 value; 
      
      
      value = _getLong_ByteDataAccessJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, nrofBytes, _thCxt);
      { STACKTRC_LEAVE;
        return value;
      }
    }
    else { throw_s0Jc(ident_RuntimeExceptionJc, "Not available in expand mode.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 float value without a child instance, but returns the value as integer.*/
float getChildFloat_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildFloat_ByteDataAccessJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(thiz, _thCxt);
    if(!setIdxCurrentChildEnd_ByteDataAccessJc(thiz, 4, _thCxt)) 
    { /*:NOTE: to read from idxInChild = 0, build the difference as shown:*/
      
      int32 intRepresentation; 
      
      
      intRepresentation = (int32)_getLong_ByteDataAccessJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, 4, _thCxt);
      { STACKTRC_LEAVE;
        return intBitsToFloat_FloatJc(/*static*/intRepresentation);
      }
    }
    else { throw_s0Jc(ident_RuntimeExceptionJc, "Not available in expand mode.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 double value without a child instance, but returns the value as integer.*/
double getChildDouble_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildDouble_ByteDataAccessJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(thiz, _thCxt);
    if(!setIdxCurrentChildEnd_ByteDataAccessJc(thiz, 8, _thCxt)) 
    { /*:NOTE: to read from idxInChild = 0, build the difference as shown:*/
      
      int64 intRepresentation; 
      
      
      intRepresentation = _getLong_ByteDataAccessJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, 8, _thCxt);
      { STACKTRC_LEAVE;
        return longBitsToDouble_DoubleJc(/*static*/intRepresentation);
      }
    }
    else { throw_s0Jc(ident_RuntimeExceptionJc, "Not available in expand mode.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance, and sets the value as integer.*/
void addChildInteger_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 nrofBytes, int64 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildInteger_ByteDataAccessJc");
  
  { 
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(thiz, _thCxt);
    if(thiz->data->head.length < thiz->idxCurrentChild + nrofBytes) 
    { 
      StringJc msg = CONST_z_StringJc("data length to small:"); 
      
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      msg = 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "data length to small:", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->idxCurrentChild + nrofBytes), _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
      { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    _setLong_ByteDataAccessJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, nrofBytes, value, _thCxt);
    expand_ByteDataAccessJc(thiz, thiz->idxCurrentChild + nrofBytes, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance, and sets the value as integer.*/
void addChildFloat_ByteDataAccessJc(ByteDataAccessJc_s* thiz, float value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildFloat_ByteDataAccessJc");
  
  { 
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(thiz, _thCxt);
    if(thiz->data->head.length < thiz->idxCurrentChild + 4) 
    { 
      StringJc msg = CONST_z_StringJc("data length to small:"); 
      
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      msg = 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "data length to small:", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->idxCurrentChild + 4), _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
      { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    setFloat_if_ByteDataAccessJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, value);
    expand_ByteDataAccessJc(thiz, thiz->idxCurrentChild + 4, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Adds a child for a String value without a child instance, but returns the value as String.*/
StringJc getChildString_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildString_ByteDataAccessJc");
  
  { /*:NOTE: there is no instance for this child, but it is the current child anyway.*/
    
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(thiz, _thCxt);
    if(!setIdxCurrentChildEnd_ByteDataAccessJc(thiz, nrofBytes, _thCxt)) 
    { /*:NOTE: to read from idxInChild = 0, build the difference as shown:*/
      
      
      { STACKTRC_LEAVE;
        return _getString_ByteDataAccessJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, nrofBytes, _thCxt);
      }
    }
    else { throw_s0Jc(ident_RuntimeExceptionJc, "Not available in expand mode.  ", 0, &_thCxt->stacktraceThreadContext, __LINE__); return null_StringJc; };
  }
  STACKTRC_LEAVE;
}


/**Adds a child with String value.*/
void addChildString_SSb_ByteDataAccessJc(ByteDataAccessJc_s* thiz, StringJc value, StringJc sEncoding, bool preventCtrlChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildString_SSb_ByteDataAccessJc");
  
  { 
    int32 nrofBytes; 
    
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(thiz, _thCxt);
    nrofBytes = length_StringJc(value);
    if(thiz->data->head.length < thiz->idxCurrentChild + nrofBytes) 
    { 
      StringJc msg = CONST_z_StringJc("data length to small:"); 
      
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      msg = 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "data length to small:", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->idxCurrentChild + nrofBytes), _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
      { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    _setString_ByteDataAccessJc(thiz, thiz->idxCurrentChild - thiz->idxBegin, nrofBytes, value, sEncoding, preventCtrlChars, _thCxt);
    expand_ByteDataAccessJc(thiz, thiz->idxCurrentChild + nrofBytes, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Adds a child with String value.*/
void addChildString_SS_ByteDataAccessJc(ByteDataAccessJc_s* thiz, StringJc valueCs, StringJc sEncoding, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildString_SS_ByteDataAccessJc");
  
  { 
    int32 nrofBytes; 
    
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(thiz, _thCxt);
    nrofBytes = length_StringJc(valueCs);
    if(thiz->data->head.length < thiz->idxCurrentChild + nrofBytes) 
    { 
      StringJc msg = CONST_z_StringJc("data length to small:"); 
      
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      msg = 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "data length to small:", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->idxCurrentChild + nrofBytes), _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
      { throw_sJc(ident_IllegalArgumentExceptionJc, msg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }/*NOTE: there is no instance for this child, but it is the current child anyway.*/
    /*NOTE: to read from idxInChild = 0, build the difference as shown:*/
    
    { int32 ii; 
      for(ii = 0; ii < nrofBytes; ++ii)
        { 
          int8 charByte; 
          
          
          charByte = (int8)(charAt_StringJc(valueCs, ii));
          thiz->data->data[thiz->idxCurrentChild + ii] = charByte;
        }
    }
    expand_ByteDataAccessJc(thiz, thiz->idxCurrentChild + nrofBytes, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**returns true if the given number of bytes is sufficing in the data from position of next child.*/
bool sufficingBytesForNextChild_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("sufficingBytesForNextChild_ByteDataAccessJc");
  
  { 
    int32 maxNrofBytesChild; 
    
    
    maxNrofBytesChild = getMaxNrofBytesForNextChild_ByteDataAccessJc(thiz, _thCxt);
    { STACKTRC_LEAVE;
      return nrofBytes < 0 ? false : maxNrofBytesChild >= nrofBytes;
    }
  }
  STACKTRC_LEAVE;
}


/**returns the number number of bytes there are max available from position of a next current child.*/
int32 getMaxNrofBytesForNextChild_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getMaxNrofBytesForNextChild_ByteDataAccessJc");
  
  { /*:if(idxCurrentChild == -1)*/
    
    
    
    { }
    if(thiz->idxCurrentChildEnd < thiz->idxCurrentChild) { throw_s0Jc(ident_IllegalArgumentExceptionJc, "length of current child is undefined.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return thiz->idxEnd - thiz->idxCurrentChildEnd;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the current child element.*/
int32 getLengthCurrentChildElement_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("getLengthCurrentChildElement_ByteDataAccessJc");
  
  { 
    
    if(thiz->idxCurrentChildEnd > thiz->idxCurrentChild) 
    { /*:a get method, especially getText() was called,*/
      /*:so the end of the child is known yet, use it!*/
      
      
      { STACKTRC_LEAVE;
        return thiz->idxCurrentChildEnd - thiz->idxCurrentChild;
      }
    }
    else 
    { /*:only the user can define the length.*/
      
      
      { STACKTRC_LEAVE;
        return mtthis->specifyLengthCurrentChildElement(thiz, _thCxt);
      }
    }
  }
  STACKTRC_LEAVE;
}


/**Returns a String from the given position inside the actual element .*/
StringJc getString_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, int32 nmax, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getString_ByteDataAccessJc");
  
  { 
    StringJc sRet = NULL_StringJc; 
    int32 pos0; 
    
    
    /*no initvalue*/
    TRY
    { 
      
      sRet = new_BYIICharset_StringJc(/*static*/thiz->data, thiz->idxBegin + idx, nmax, s0_StringJc("ISO-8859-1"), _thCxt)/*J2C:non-persistent*/;
    }_TRY
    CATCH(UnsupportedEncodingException, e)
    
      { 
        
        sRet = null_StringJc/*J2C:non-persistent*/;
      }
    END_TRY
    pos0 = indexOf_C_StringJc(sRet, ((char)(0)));
    if(pos0 > 0) 
    { /*:The data are zero terminated!*/
      
      
      sRet = substring_StringJc(sRet, 0, pos0, _thCxt)/*J2C:non-persistent*/;
    }
    { STACKTRC_LEAVE;
      return sRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets a String to the the given position inside the actual element .*/
int32 setString_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, int32 nmax, StringJc ss, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setString_ByteDataAccessJc");
  
  { 
    ByteStringJc byteRepresentation;   /*Use a */
    int32 len; 
    
    
    if(length_StringJc(ss) > nmax) 
    { 
      
      ss = substring_StringJc(ss, 0, nmax, _thCxt)/*J2C:non-persistent*/;
    }/*truncate.*/
    
    /*no initvalue*/
    TRY
    { 
      
      byteRepresentation = getBytesEncoding_StringJc(ss, s0_StringJc("ISO-8859-1"), _thCxt);
    }_TRY
    CATCH(UnsupportedEncodingException, e)
    
      { 
        
        byteRepresentation = null_OS_PtrValue;
      }
    END_TRY
    len = length_ByteStringJc(byteRepresentation);
    if(len > nmax) 
    { 
      
      len = nmax;
    }/*truncate.*/
    
    arraycopy_v_SystemJc(/*static*/byteRepresentation, 0, & ((thiz->data)->head.object), thiz->idxBegin + idx, len, _thCxt);
    { STACKTRC_LEAVE;
      return len;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 to 8 bytes inside the actual element as a long number,*/
int64 _getLong_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idxInChild, int32 nrofBytesAndSign, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_getLong_ByteDataAccessJc");
  
  { 
    int64 val = 0; 
    int32 idxStep = 0; 
    int32 idx = 0; 
    int32 nrofBytes = 0; 
    bool bSigned = 0; 
    int32 nByteCnt; 
    
    
    val = 0;
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    if(nrofBytesAndSign >= 0) 
    { 
      
      nrofBytes = nrofBytesAndSign;
      bSigned = false;
    }
    else 
    { 
      
      nrofBytes = -nrofBytesAndSign;
      bSigned = true;
    }
    if(thiz->bBigEndian) 
    { 
      
      idx = thiz->idxBegin + idxInChild;
      idxStep = 1;
    }
    else 
    { 
      
      idx = thiz->idxBegin + idxInChild + nrofBytes - 1;
      idxStep = -1;
    }
    nByteCnt = nrofBytes;
    do 
      { 
        
        val |= thiz->data->data[idx] & 0xff;
        if(--nByteCnt <= 0) break;/*TRICKY: break in mid of loop, no shift operation.*/
        
        val <<= 8;
        idx += idxStep;
      }while(true);/*see break;*/
    
    if(bSigned) 
    { 
      int32 posSign; 
      int64 maskSign = 1; 
      
      
      posSign = (nrofBytes * 8) - 1;
      maskSign = 1 << posSign;
      if((val & maskSign) != 0) 
      { 
        int64 bitsSign = 0xffffffffffffffff; 
        
        
        bitsSign = 0xffffffffffffffff << (posSign);
        val |= bitsSign;/*supplement the rest bits of long with the sign value,it's negativ.*/
        
      }
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**sets the content of 1 to 8 bytes inside the actual element as a long number,*/
void _setLong_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, int32 nrofBytes, int64 val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_setLong_ByteDataAccessJc");
  
  { 
    int32 idxStep = 0; 
    
    
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      idx = thiz->idxBegin + idx + nrofBytes - 1;
      idxStep = -1;
    }
    else 
    { 
      
      idx = thiz->idxBegin + idx;
      idxStep = 1;
    }
    do 
      { 
        
        thiz->data->data[idx] = (int8)(val);
        if(--nrofBytes <= 0) break;
        val >>= 8;
        idx += idxStep;
      }while(true);/*see break;*/
    
  }
  STACKTRC_LEAVE;
}


/**sets the content inside the acutal element with the character bytes from the given String.*/
StringJc _getString_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_getString_ByteDataAccessJc");
  
  { 
    int32 idxData; 
    StringJc value = NULL_StringJc; 
    int32 end; 
    
    
    idxData = idx + thiz->idxBegin;
    
    value = new_BYIICharset_StringJc(/*static*/thiz->data, idxData, nrofBytes, thiz->charset, _thCxt);
    end = indexOf_C_StringJc(value, ((char)(0)));
    if(end >= 0) 
    { 
      
      value = substring_StringJc(value, 0, end, _thCxt)/*J2C:non-persistent*/;
    }
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}


/**sets the content inside the actual element with the character bytes from the given String.*/
void _setString_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, int32 nrofBytes, StringJc value, StringJc sEncoding, bool preventCtrlChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_setString_ByteDataAccessJc");
  
  { 
    int32 idxData; 
    int32 idxEnd; 
    ByteStringJc chars;   /**/
    int32 srcLen; 
    
    
    idxData = idx + thiz->idxBegin;
    idxEnd = idxData + nrofBytes;
    /*no initvalue*/
    if(sEncoding.ptr__== null) 
    { 
      
      sEncoding = z_StringJc("ISO-8859-1")/*J2C:non-persistent*/;
    }
    chars = getBytesEncoding_StringJc(value, sEncoding, _thCxt);
    srcLen = length_ByteStringJc(chars);
    { int32 ii; 
      for(ii = 0; ii < srcLen && ii < nrofBytes; ii++)
        { 
          int8 cc; 
          
          
          cc = ((/*J2C:cast% from ByteStringJc*/int8)(data_ByteStringJc(chars)[ii]));
          if(preventCtrlChars && cc < 0x20) 
          { 
            
            cc = ((/*J2C:cast% from int32*/int8)(0x3f));
          }/*'?' in ASCII*/
          
          thiz->data->data[idxData++] = cc;
        }/*fill up the rest of the string with 0-chars.*/
        
    }
    
    while(idxData < idxEnd)
      { 
        
        thiz->data->data[idxData++] = 0;
      }
  }
  STACKTRC_LEAVE;
}


/**copies some data to a int[], primarily to debug a content.*/
void copyData_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32_Y* dst, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("copyData_ByteDataAccessJc");
  
  { 
    int32 idxMax; 
    int32 iDst = 0; 
    
    
    idxMax = thiz->idxEnd - thiz->idxBegin;
    if(idxMax / 4 > dst->head.length) idxMax = 4 * dst->head.length;
    iDst = 0;
    { int32 idx; 
      for(idx = 0; idx < idxMax; idx += 4)
        { 
          
          dst->data[iDst++] = (int32)_getLong_ByteDataAccessJc(thiz, idx, 4, _thCxt);
        }
    }
  }
  STACKTRC_LEAVE;
}


/**Sets all data of this element to 0.*/
void clearData_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("clearData_ByteDataAccessJc");
  
  { 
    
    fill_B_ArraysJc(/*static*/thiz->data, thiz->idxBegin, thiz->idxEnd, (int8)0, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Sets all data of the head of this element to 0.*/
void clearHead_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("clearHead_ByteDataAccessJc");
  
  { 
    
    if(thiz->idxFirstChild > thiz->idxBegin) 
    { 
      
      fill_B_ArraysJc(/*static*/thiz->data, thiz->idxBegin, thiz->idxFirstChild, (int8)0, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Gets a float value from the content of 4 byte*/
float getFloat_i_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getFloat_i_ByteDataAccessJc");
  
  { 
    int32 intRepresentation; 
    float value; 
    
    
    intRepresentation = getInt32_i_ByteDataAccessJc(thiz, idx, _thCxt);
    value = intBitsToFloat_FloatJc(/*static*/intRepresentation);
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}

double getDouble_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getDouble_ByteDataAccessJc");
  
  { 
    int64 intRepresentation; 
    
    
    intRepresentation = _getLong_ByteDataAccessJc(thiz, idx, 8, _thCxt);
    { STACKTRC_LEAVE;
      return longBitsToDouble_DoubleJc(/*static*/intRepresentation);
    }
  }
  STACKTRC_LEAVE;
}

int64 getInt64_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt64_ByteDataAccessJc");
  
  { 
    int32 nLo = 0; 
    int32 nHi = 0; 
    int64 val; 
    
    
    /*no initvalue*/
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      nLo = getInt32_i_ByteDataAccessJc(thiz, idx, _thCxt);
      nHi = getInt32_i_ByteDataAccessJc(thiz, idx + 4, _thCxt);
    }
    else 
    { 
      
      nLo = getInt32_i_ByteDataAccessJc(thiz, idx + 4, _thCxt);
      nHi = getInt32_i_ByteDataAccessJc(thiz, idx, _thCxt);
    }
    val = nHi << 32;
    val |= nLo & 0xffffffff;
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 4 bytes inside the actual element as a integer number between -2147483648 and 2147483647,*/
int32 getInt32_i_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt32_i_ByteDataAccessJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      val = ((thiz->data->data[thiz->idxBegin + idx]) << 24) | (((thiz->data->data[thiz->idxBegin + idx + 1]) << 16) & 0xff0000) | (((thiz->data->data[thiz->idxBegin + idx + 2]) << 8) & 0xff00) | (((thiz->data->data[thiz->idxBegin + idx + 3])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    else 
    { 
      
      val = ((thiz->data->data[thiz->idxBegin + idx + 3]) << 24) | (((thiz->data->data[thiz->idxBegin + idx + 2]) << 16) & 0xff0000) | (((thiz->data->data[thiz->idxBegin + idx + 1]) << 8) & 0xff00) | (((thiz->data->data[thiz->idxBegin + idx])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 2 bytes as a positive nr between 0..65535, big-endian*/
int32 getUint16_i_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint16_i_ByteDataAccessJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      val = (((thiz->data->data[thiz->idxBegin + idx]) << 8) & 0xff00) | (((thiz->data->data[thiz->idxBegin + idx + 1])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    else 
    { 
      
      val = (((thiz->data->data[thiz->idxBegin + idx + 1]) << 8) & 0xff00) | (((thiz->data->data[thiz->idxBegin + idx])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 2 bytes as a positive nr between 0..65535 inside the actual element.*/
int16 getInt16_i_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt16_i_ByteDataAccessJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    if(thiz->bBigEndian) 
    { 
      
      val = (((thiz->data->data[thiz->idxBegin + idx]) << 8) & 0xff00) | (((thiz->data->data[thiz->idxBegin + idx + 1])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    else 
    { 
      
      val = (((thiz->data->data[thiz->idxBegin + idx + 1]) << 8) & 0xff00) | (((thiz->data->data[thiz->idxBegin + idx])) & 0xff);/*NOTE: the value has only 8 bits for bitwise or.*/
      
    }
    { STACKTRC_LEAVE;
      return (int16)val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 bytes as ASCII*/
char getChar_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChar_ByteDataAccessJc");
  
  { 
    char val = 0; 
    
    
    /*no initvalue*/
    val = (char)thiz->data->data[thiz->idxBegin + idx];
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 bytes as a positive or negative nr between -128..127*/
int8 getInt8_i_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt8_i_ByteDataAccessJc");
  
  { 
    int8 val = 0; 
    
    
    /*no initvalue*/
    val = thiz->data->data[thiz->idxBegin + idx];
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 bytes as a positive or negative nr between -128..127*/
int32 getUint8_i_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint8_i_ByteDataAccessJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    val = thiz->data->data[thiz->idxBegin + idx] & 0xff;
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint32_iii_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint32_iii_ByteDataAccessJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    /** */
    if(idxArray >= lengthArray || idxArray < 0) /** */
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getUint16:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getUint32_i_ByteDataAccessJc(thiz, idxBytes + 4 * idxArray);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt32_iii_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt32_iii_ByteDataAccessJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    /** */
    if(idxArray >= lengthArray || idxArray < 0) /** */
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getInt32:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getInt32_i_ByteDataAccessJc(thiz, idxBytes + 4 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt16_iii_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt16_iii_ByteDataAccessJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    /** */
    if(idxArray >= lengthArray || idxArray < 0) /** */
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getInt16:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getInt16_i_ByteDataAccessJc(thiz, idxBytes + 2 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt8_iii_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt8_iii_ByteDataAccessJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    /** */
    if(idxArray >= lengthArray || idxArray < 0) /** */
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getInt8:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getInt8_i_ByteDataAccessJc(thiz, idxBytes + idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint16_iii_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint16_iii_ByteDataAccessJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    /** */
    if(idxArray >= lengthArray || idxArray < 0) /** */
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getUint16:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getUint16_i_ByteDataAccessJc(thiz, idxBytes + 2 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint8_iii_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint8_iii_ByteDataAccessJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    /** */
    if(idxArray >= lengthArray || idxArray < 0) /** */
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getUint8:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getInt8_i_ByteDataAccessJc(thiz, idxBytes + idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

float getFloat_iii_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getFloat_iii_ByteDataAccessJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    /** */
    if(idxArray >= lengthArray || idxArray < 0) /** */
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "getFloat:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return getFloat_i_ByteDataAccessJc(thiz, idxBytes + 4 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 4 bytes as a integer number between -2147483648 and 2147483647,*/
void setInt32_ii_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt32_ii_ByteDataAccessJc");
  
  { 
    
    if(thiz->bBigEndian) 
    { 
      
      thiz->data->data[thiz->idxBegin + idx] = (int8)((value >> 24) & 0xff);
      thiz->data->data[thiz->idxBegin + idx + 1] = (int8)((value >> 16) & 0xff);
      thiz->data->data[thiz->idxBegin + idx + 2] = (int8)((value >> 8) & 0xff);
      thiz->data->data[thiz->idxBegin + idx + 3] = (int8)(value & 0xff);
    }
    else 
    { 
      
      thiz->data->data[thiz->idxBegin + idx + 3] = (int8)((value >> 24) & 0xff);
      thiz->data->data[thiz->idxBegin + idx + 2] = (int8)((value >> 16) & 0xff);
      thiz->data->data[thiz->idxBegin + idx + 1] = (int8)((value >> 8) & 0xff);
      thiz->data->data[thiz->idxBegin + idx] = (int8)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 4 bytes as a positive nr between 0..2pow32-1, big- or little-endian.*/
void setUint32_il_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, int64 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setUint32_il_ByteDataAccessJc");
  
  { /*:the same algorithm in source, but other action on machine level,*/
    /*:because value is long!*/
    
    
    if(thiz->bBigEndian) 
    { 
      
      thiz->data->data[thiz->idxBegin + idx] = (int8)((value >> 24) & 0xff);
      thiz->data->data[thiz->idxBegin + idx + 1] = (int8)((value >> 16) & 0xff);
      thiz->data->data[thiz->idxBegin + idx + 2] = (int8)((value >> 8) & 0xff);
      thiz->data->data[thiz->idxBegin + idx + 3] = (int8)(value & 0xff);
    }
    else 
    { 
      
      thiz->data->data[thiz->idxBegin + idx + 3] = (int8)((value >> 24) & 0xff);
      thiz->data->data[thiz->idxBegin + idx + 2] = (int8)((value >> 16) & 0xff);
      thiz->data->data[thiz->idxBegin + idx + 1] = (int8)((value >> 8) & 0xff);
      thiz->data->data[thiz->idxBegin + idx] = (int8)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 2 bytes from an integer between -32768..32768,*/
void setInt16_ii_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 idx, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt16_ii_ByteDataAccessJc");
  
  { 
    
    if(thiz->bBigEndian) 
    { 
      
      thiz->data->data[thiz->idxBegin + idx] = (int8)((value >> 8) & 0xff);
      thiz->data->data[thiz->idxBegin + idx + 1] = (int8)(value & 0xff);
    }
    else 
    { 
      
      thiz->data->data[thiz->idxBegin + idx + 1] = (int8)((value >> 8) & 0xff);
      thiz->data->data[thiz->idxBegin + idx] = (int8)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}


/**Copies the data into a byte[]*/
void copyDataFrom_ByteDataAccessJc(ByteDataAccessJc_s* thiz, struct ByteDataAccessJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("copyDataFrom_ByteDataAccessJc");
  
  { 
    int32 len; 
    
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    len = getLength_ByteDataAccessJc(src);
    /** */
    if(thiz->data->head.length < len) /** */
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "copy, dst to small", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, len, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    arraycopy_SystemJc(/*static*/& ((src->data)->head.object), src->idxBegin, & ((thiz->data)->head.object), thiz->idxBegin, len, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Counts the idxChild by given index, idxChild is ByteCount from idxBegin*/
void elementAt_ByteDataAccessJc(ByteDataAccessJc_s* thiz, int32 indexObjectArray, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("elementAt_ByteDataAccessJc");
  
  { 
    
    TRY
    { 
      
      thiz->idxCurrentChild = thiz->idxBegin + mtthis->specifyLengthElementHead(thiz, _thCxt) + mtthis->specifyLengthCurrentChildElement(thiz, _thCxt) * indexObjectArray;
    }_TRY
    CATCH(IllegalArgumentException, e)
    
      { 
        
        printStackTrace_ExceptionJc(e, _thCxt);
      }
    END_TRY
  }
  STACKTRC_LEAVE;
}

bool assertNotExpandable_ByteDataAccessJc(ByteDataAccessJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assertNotExpandable_ByteDataAccessJc");
  
  { 
    
    ASSERT(/*static*/thiz->idxCurrentChild > 0 && thiz->idxEnd > 0 && !thiz->bExpand);
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


void finalize_ByteDataAccessJc_F(ObjectJc* othis, ThCxt* _thCxt)
{ ByteDataAccessJc_s* thiz = (ByteDataAccessJc_s*)othis;  //upcasting to the real class.
 STACKTRC_TENTRY("finalize_ByteDataAccessJc_F");
  CLEAR_REFJc(thiz->parent);
  CLEAR_REFJc(thiz->toStringformatter);
  finalize_ObjectJc_F(&thiz->base.object, _thCxt); //J2C: finalizing the superclass.
  STACKTRC_LEAVE;
}


 extern_C struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_ByteDataAccessJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_ByteDataAccessJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, 0 /*J2C: no Mtbl*/ }
   }
 };

extern_C struct ClassJc_t const reflection_ByteDataAccessJc_s;
extern_C struct ClassJc_t const reflection_ByteDataAccessJc_s;
extern_C struct ClassJc_t const reflection_StringFormatterJc_s;
extern_C struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_ByteDataAccessJc_s_t
{ ObjectArrayJc head; FieldJc data[12];
} reflection_Fields_ByteDataAccessJc_s =
{ CONST_ObjectArrayJc(FieldJc, 12, OBJTYPE_FieldJc, null, &reflection_Fields_ByteDataAccessJc_s)
, {
     { "data"
    , 0 //nrofArrayElements
    , REFLECTION_int8
    , 1 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->data) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "idxBegin"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->idxBegin) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "idxEnd"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->idxEnd) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "bExpand"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->bExpand) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "idxFirstChild"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->idxFirstChild) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "idxCurrentChild"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->idxCurrentChild) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "idxCurrentChildEnd"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->idxCurrentChildEnd) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "bBigEndian"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->bBigEndian) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "parent"
    , 0 //nrofArrayElements
    , &reflection_ByteDataAccessJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->parent) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "charset"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->charset) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "toStringformatter"
    , 0 //nrofArrayElements
    , &reflection_StringFormatterJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->toStringformatter) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "kNothing"
    , 0 //nrofArrayElements
    , REFLECTION_int8
    , 1 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&kNothing_ByteDataAccessJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&kNothing_ByteDataAccessJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_ByteDataAccessJc_s
    }
} };
const ClassJc reflection_ByteDataAccessJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "ByteDataAccessJc_s"
,  0 //position of ObjectJc
, sizeof(ByteDataAccessJc_s)
, (FieldJcArray const*)&reflection_Fields_ByteDataAccessJc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_ByteDataAccessJc_s //superclass
, null //interfaces
, 0    //modifiers
};
