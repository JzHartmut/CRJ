/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "J1c/StringPartScanJc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "J1c/SpecialCharStringsJc.h"  //reference-association: SpecialCharStringsJc_s
#include "J1c/StringFunctionsJc.h"  //reference-association: StringFunctionsJc_s
#include "Jc/AssertJc.h"  //reference-association: AssertJc_s
#include "Jc/MathJc.h"  //reference-association: MathJc_s
#include "Jc/ObjectJc.h"  //reference-association: IntegerJc
#include "Jc/StringJc.h"  //embedded type in class data


/* J2C: Forward declaration of struct ***********************************************/
struct Part_StringPartJc_t;

/**This class extends the capability of StringPartBase for scanning capability.
In opposite to the {@link StringPart#seek(int)} functionality with several conditions
the scan methods does not search till a requested char or string but test the string
starting from the begin of the valid part. If the test is ok, the begin of the valid part
is shifted to right behind the scanned string. The result of the scanning process
may be evaluated later. Therefore it is stored in this class, for example {@link #getLastScannedIntegerNumber()}
can be gotten after scan.
<pre>
abcdefghijklmnopqrstuvwxyz  Sample of the whole associated String
--------------------    The valid part before scan
++++++++++++++    The valid part after scan
******                  The successfully scanned part.
xxxxx             Starting next scan
</pre>
A scan works with the current valid part always.
<br><br>
<b>concatenated sequence of scans</b>:<br>
It is possible to concatenate scans, for example
<pre>
sp.scanStart();
if(sp.scan("keyword").scan('=').scanIdentifier().scanOk()){
String sIdent = sp.getLastScannedString().toString();
} else if(sp.scan("other-keyword").scan(.....
</pre>
The following rule is valid:
<ul>
<li>The operations are concatenated, because any operation returns this.
It is a nice-to-have writing style.
<li>If a scan fails, the following scan operations are not executed.
<li>{@link #scanOk()} returns false if any of the scan methods after {@link #scanStart()}
or the last {@link #scanOk()} fails.
<li>If a {@link #scanOk()} was invoked and the scan before that fails, the begin of the valid part
is set to that position where the scan has started before this scan sequence. It is the position
where {@link #scanStart()} was called or the last {@link #scanOk()} with return true was called.
</ul>
With them a well readable sequential test of content can be programmed in the shown form above.
In a sequence of scans white space and comments may be skipped over if the method
{@link #setIgnoreWhitespaces(boolean)} etc. are invoked before. That setting is valid for all following
scan invocations.

@author Hartmut Schorrig
e
*/


const char sign_Mtbl_StringPartScanJc[] = "StringPartScanJc"; //to mark method tables of all implementations

typedef struct MtblDef_StringPartScanJc_t { Mtbl_StringPartScanJc mtbl; MtblHeadJc end; } MtblDef_StringPartScanJc;
 extern MtblDef_StringPartScanJc const mtblStringPartScanJc;

/*Constructor */
struct StringPartScanJc_t* ctorO_Csii_StringPartScanJc(ObjectJc* othis, struct CharSequenceJc_t* src, int32 begin, int32 end, ThCxt* _thCxt)
{ StringPartScanJc_s* thiz = (StringPartScanJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringPartScanJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartScanJc_s), null, _thCxt);  
  //J2C:super Constructor
  ctorO_Csii_StringPartJc(/*static*/othis, src, begin, end, _thCxt);
  setReflection_ObjectJc(othis, &reflection_StringPartScanJc_s, sizeof(StringPartScanJc_s));  
  //j2c: Initialize all class variables:
  {
    /*J2C: newArray*/
      init_ObjectJc(&thiz->nLastIntegerNumber.head.object, sizeof_ARRAYJc(int64, 5), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&thiz->nLastIntegerNumber.head.object, 5, sizeof(int64), null, 0);//J2C: constructor for embedded array;
    thiz->idxLastIntegerNumber = -1;
    /*J2C: newArray*/
      init_ObjectJc(&thiz->nLastFloatNumber.head.object, sizeof_ARRAYJc(double, 5), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&thiz->nLastFloatNumber.head.object, 5, sizeof(double), null, 0);//J2C: constructor for embedded array;
    thiz->idxLastFloatNumber = -1;
  }
  { 
    
    
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct StringPartScanJc_t* ctorO_Cs_StringPartScanJc(ObjectJc* othis, struct CharSequenceJc_t* src, ThCxt* _thCxt)
{ StringPartScanJc_s* thiz = (StringPartScanJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringPartScanJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartScanJc_s), null, _thCxt);  
  //J2C:super Constructor
  ctorO_Cs_StringPartJc(/*static*/othis, src, _thCxt);
  setReflection_ObjectJc(othis, &reflection_StringPartScanJc_s, sizeof(StringPartScanJc_s));  
  //j2c: Initialize all class variables:
  {
    /*J2C: newArray*/
      init_ObjectJc(&thiz->nLastIntegerNumber.head.object, sizeof_ARRAYJc(int64, 5), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&thiz->nLastIntegerNumber.head.object, 5, sizeof(int64), null, 0);//J2C: constructor for embedded array;
    thiz->idxLastIntegerNumber = -1;
    /*J2C: newArray*/
      init_ObjectJc(&thiz->nLastFloatNumber.head.object, sizeof_ARRAYJc(double, 5), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&thiz->nLastFloatNumber.head.object, 5, sizeof(double), null, 0);//J2C: constructor for embedded array;
    thiz->idxLastFloatNumber = -1;
  }
  { 
    
    
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct StringPartScanJc_t* ctorO_StringPartScanJc(ObjectJc* othis, ThCxt* _thCxt)
{ StringPartScanJc_s* thiz = (StringPartScanJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringPartScanJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartScanJc_s), null, _thCxt);  
  //J2C:super Constructor
  ctorO_StringPartJc(/*static*/othis, _thCxt);
  setReflection_ObjectJc(othis, &reflection_StringPartScanJc_s, sizeof(StringPartScanJc_s));  
  //j2c: Initialize all class variables:
  {
    /*J2C: newArray*/
      init_ObjectJc(&thiz->nLastIntegerNumber.head.object, sizeof_ARRAYJc(int64, 5), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&thiz->nLastIntegerNumber.head.object, 5, sizeof(int64), null, 0);//J2C: constructor for embedded array;
    thiz->idxLastIntegerNumber = -1;
    /*J2C: newArray*/
      init_ObjectJc(&thiz->nLastFloatNumber.head.object, sizeof_ARRAYJc(double, 5), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&thiz->nLastFloatNumber.head.object, 5, sizeof(double), null, 0);//J2C: constructor for embedded array;
    thiz->idxLastFloatNumber = -1;
  }
  { 
    
    
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*** */
struct StringPartScanJc_t* scanStart_StringPartScanJc(StringPartScanJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanStart_StringPartScanJc");
  
  { 
    
    thiz->base.super.bCurrentOk = true;
    scanOk_StringPartScanJc(thiz, _thCxt);//turn all indicees to ok
    
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}

bool scanEntry_StringPartScanJc(StringPartScanJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanEntry_StringPartScanJc");
  
  { 
    
    if(thiz->base.super.bCurrentOk) 
    { 
      
      seekNoWhitespaceOrComments_StringPartJc(& ((* (thiz)).base.super), _thCxt);
      if(thiz->base.super.bStartScan) 
      { 
        
        thiz->idxLastIntegerNumber = -1;//idxLastFloatNumber = 0;
        
        thiz->base.super.bStartScan = false;
      }
      if(thiz->base.super.begin == thiz->base.super.end) 
      { 
        
        thiz->base.super.bCurrentOk = false;//error, because nothing to scan.
        
      }
    }
    { STACKTRC_LEAVE;
      return thiz->base.super.bCurrentOk;
    }
  }
  STACKTRC_LEAVE;
}


/**Test the result of scanning and set the scan Pos Ok, if current scanning was ok*/
bool scanOk_StringPartScanJc(StringPartScanJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanOk_StringPartScanJc");
  
  { 
    bool bOk; 
    
    
    if(thiz->base.super.bCurrentOk) 
    { 
      
      thiz->beginScan = thiz->base.super.beginLast = /*? assignment*/thiz->base.super.begin;//the scanOk-position is the begin of maximal part.
      
      thiz->base.super.bStartScan = true;//set all idxLast... to 0
      
    }
    else 
    { 
      
      thiz->base.super.begin = thiz->base.super.beginLast = /*? assignment*/thiz->beginScan;//return to the begin
      
    }//if(report != null){ report.report(6," scanOk:" + beginMin + ".." + begin + ":" + (bCurrentOk ? "ok" : "error")); }
    
    bOk = thiz->base.super.bCurrentOk;
    thiz->base.super.bCurrentOk = true;//prepare to next try scanning
    
    { STACKTRC_LEAVE;
      return (bOk);
    }
  }
  STACKTRC_LEAVE;
}


/**scan next content, test the requested String.*/
struct StringPartScanJc_t* scan_StringPartScanJc(StringPartScanJc_s* thiz, struct CharSequenceJc_t* sTestP, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scan_StringPartScanJc");
  
  { 
    
    if(thiz->base.super.bCurrentOk) 
    { //:      but the sTestP may contain only cEndOfText. end of text will be okay than.
      
      struct CharSequenceJc_t* sTest = null; 
      int32 len; 
      bool bTestToEndOfText; 
      
      
      seekNoWhitespaceOrComments_StringPartJc(& ((* (thiz)).base.super), _thCxt);
      /*no initvalue*/
      len = indexOf_Csci_StringFunctionsJc(/*static*/sTestP, cEndOfText_StringPartJc, 0, _thCxt);
      bTestToEndOfText = (len >= 0);
      if(bTestToEndOfText) 
      { 
        
        sTest = subSequence_CharSequenceJc(sTestP, 0, len, _thCxt)/*J2C-error testAndChangeAccess: t**/;
      }
      else 
      { 
        
        len = length_CharSequenceJc(sTestP);
        sTest = sTestP;
      }
      if((thiz->base.super.begin + len) <= thiz->base.super.endMax && equals_CsiiCs_StringFunctionsJc(/*static*/REFJc(thiz->base.super.content), thiz->base.super.begin, thiz->base.super.begin + len, sTest, _thCxt) && (!bTestToEndOfText || thiz->base.super.begin + len == thiz->base.super.end)) 
      { 
        
        thiz->base.super.begin += len;
      }
      else 
      { 
        
        thiz->base.super.bCurrentOk = false;
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/*** */
struct StringPartScanJc_t* scanQuotion_CsSSY_StringPartScanJc(StringPartScanJc_s* thiz, struct CharSequenceJc_t* sQuotionmarkStart, StringJc sQuotionMarkEnd, StringJc_Y* sResult, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanQuotion_CsSSY_StringPartScanJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return scanQuotion_CsSSYi_StringPartScanJc(thiz, sQuotionmarkStart, sQuotionMarkEnd, sResult, MAX_VALUE_IntegerJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/*** */
struct StringPartScanJc_t* scanQuotion_CsSSYi_StringPartScanJc(StringPartScanJc_s* thiz, struct CharSequenceJc_t* sQuotionmarkStart, StringJc sQuotionMarkEnd, StringJc_Y* sResult, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanQuotion_CsSSYi_StringPartScanJc");
  
  { 
    
    if(scanEntry_StringPartScanJc(thiz, _thCxt)) 
    { 
      
      
        ( scan_StringPartScanJc(thiz, sQuotionmarkStart, _thCxt)
        , lentoNonEscapedString_StringPartJc(& ((* (thiz)).base.super), sQuotionMarkEnd, maxToTest, _thCxt)
        );
      if(thiz->base.super.bCurrentOk) 
      { //:TODO ...ToEndString, now use only 1 char in sQuotionMarkEnd
        
        StringJc _persistring3_1=NULL_StringJc; //J2C: temporary persistent Strings
        struct Part_StringPartJc_t* _temp3_1; //J2C: temporary references for concatenation
        
        if(sResult != null) sResult->data[0] = 
          ( _temp3_1= getCurrentPart_StringPartJc(& ((* (thiz)).base.super), _thCxt)
          , _persistring3_1 = persist_StringJc(toString_Part_StringPartJc(& ((* (_temp3_1)).base.object)/*J2cT1*/, _thCxt))
          )/*J2C:non-persistent*/;
        
          ( fromEnd_StringPartJc(& ((* (thiz)).base.super), _thCxt)
          , seek_i_StringPartJc(& ((* (thiz)).base.super), length_StringJc(sQuotionMarkEnd), _thCxt)
          );
        activateGC_ObjectJc(PTR_StringJc(_persistring3_1), null, _thCxt);
      }
      else thiz->base.super.bCurrentOk = false;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Scans if it is a integer number, contains exclusively of digits 0..9*/
int64 scanDigits_StringPartScanJc(StringPartScanJc_s* thiz, bool bHex, int32 maxNrofChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanDigits_StringPartScanJc");
  
  { 
    
    if(thiz->base.super.bCurrentOk) 
    { 
      int64 nn = 0; 
      bool bCont = true; 
      int32 pos; 
      int32 max; 
      
      
      nn = 0;
      bCont = true;
      pos = thiz->base.super.begin;
      max = (thiz->base.super.end - pos) < maxNrofChars ? thiz->base.super.end : pos + maxNrofChars;
      do 
        { 
          
          if(pos < max) 
          { 
            char cc; 
            
            
            cc = charAt_CharSequenceJc(REFJc(thiz->base.super.content), pos);
            if(cc >= '0' && cc <= '9') nn = nn * (bHex ? 16 : 10) + (cc - '0');
            else if(bHex && cc >= 'a' && cc <= 'f') nn = nn * 16 + (cc - 'a' + 10);
            else if(bHex && cc >= 'A' && cc <= 'F') nn = nn * 16 + (cc - 'A' + 10);
            else bCont = false;
            if(bCont) 
            { 
              
              pos += 1;
            }
          }
          else bCont = false;
        }while(bCont);
      if(pos > thiz->base.super.begin) 
      { 
        
        thiz->base.super.begin = pos;
        { STACKTRC_LEAVE;
          return nn;
        }//nLastIntegerNumber = nn;
        
      }
      else thiz->base.super.bCurrentOk = false;//scanning failed.
      
    }
    { STACKTRC_LEAVE;
      return -1;
    }//on error
    
  }
  STACKTRC_LEAVE;
}


/**Scanns a integer number as positiv value without sign.*/
struct StringPartScanJc_t* scanPositivInteger_StringPartScanJc(StringPartScanJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanPositivInteger_StringPartScanJc");
  
  { 
    
    if(scanEntry_StringPartScanJc(thiz, _thCxt)) 
    { 
      int64 value; 
      
      
      value = scanDigits_StringPartScanJc(thiz, false, MAX_VALUE_IntegerJc, _thCxt);
      if(thiz->base.super.bCurrentOk) 
      { 
        
        if(thiz->idxLastIntegerNumber < thiz->nLastIntegerNumber.head.length - 2) 
        { 
          
          thiz->nLastIntegerNumber.data[++thiz->idxLastIntegerNumber] = value;
        }
        else { throw_s0Jc(ident_ParseExceptionJc, "to much scanned integers", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Scans an integer expression with possible sign char '-' at first.*/
struct StringPartScanJc_t* scanInteger_StringPartScanJc(StringPartScanJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanInteger_StringPartScanJc");
  
  { 
    
    if(scanEntry_StringPartScanJc(thiz, _thCxt)) 
    { 
      bool bNegativValue = false; 
      int64 value; 
      
      
      bNegativValue = false;
      if(charAt_CharSequenceJc(REFJc(thiz->base.super.content), thiz->base.super.begin) == '-') 
      { 
        
        bNegativValue = true;
        seek_i_StringPartJc(& ((* (thiz)).base.super), 1, _thCxt);
      }
      value = scanDigits_StringPartScanJc(thiz, false, MAX_VALUE_IntegerJc, _thCxt);
      if(bNegativValue) 
      { 
        
        value = -value;
      }
      if(thiz->base.super.bCurrentOk) 
      { 
        
        if(thiz->idxLastIntegerNumber < thiz->nLastIntegerNumber.head.length - 2) 
        { 
          
          thiz->nLastIntegerNumber.data[++thiz->idxLastIntegerNumber] = value;
        }
        else { throw_s0Jc(ident_ParseExceptionJc, "to much scanned integers", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Scans a float number*/
struct StringPartScanJc_t* scanFloatNumber_b_StringPartScanJc(StringPartScanJc_s* thiz, bool cleanBuffer, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanFloatNumber_b_StringPartScanJc");
  
  { 
    
    if(cleanBuffer) 
    { 
      
      thiz->idxLastFloatNumber = -1;
    }
    scanFloatNumber_StringPartScanJc(thiz, _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Scans a float number*/
struct StringPartScanJc_t* scanFloatNumber_StringPartScanJc(StringPartScanJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanFloatNumber_StringPartScanJc");
  
  { 
    
    if(scanEntry_StringPartScanJc(thiz, _thCxt)) 
    { 
      int64 nInteger = 0; 
      int64 nFractional = 0; 
      int32 nDivisorFract = 1; 
      int32 nExponent = 0; 
      char cc = 0; 
      bool bNegativValue = false; 
      bool bNegativExponent = false; 
      bool bFractionalFollowed = false; 
      
      
      nInteger = 0;
      nFractional = 0;
      nDivisorFract = 1;
      /*no initvalue*/
      /*no initvalue*/
      bNegativValue = false;
      bNegativExponent = false;
      bFractionalFollowed = false;
      if((cc = /*? assignment*/charAt_CharSequenceJc(REFJc(thiz->base.super.content), thiz->base.super.begin)) == '-') 
      { 
        
        bNegativValue = true;
        seek_i_StringPartJc(& ((* (thiz)).base.super), 1, _thCxt);
        cc = charAt_CharSequenceJc(REFJc(thiz->base.super.content), thiz->base.super.begin);
      }
      if(cc == '.') 
      { 
        
        nInteger = 0;
        bFractionalFollowed = true;
      }
      else 
      { 
        
        nInteger = scanDigits_StringPartScanJc(thiz, false, MAX_VALUE_IntegerJc, _thCxt);
        if(thiz->base.super.bCurrentOk) 
        { 
          
          if(thiz->base.super.begin < thiz->base.super.endMax && charAt_CharSequenceJc(REFJc(thiz->base.super.content), thiz->base.super.begin) == '.') 
          { 
            
            bFractionalFollowed = true;
          }
        }
      }
      if(thiz->base.super.bCurrentOk && bFractionalFollowed) 
      { 
        
        seek_i_StringPartJc(& ((* (thiz)).base.super), 1, _thCxt);//over .
        
        
        while(thiz->base.super.begin < thiz->base.super.endMax && getCurrentChar_StringPartJc(& ((* (thiz)).base.super), _thCxt) == '0')
          { 
            
            seek_i_StringPartJc(& ((* (thiz)).base.super), 1, _thCxt);
            nDivisorFract *= 10;
          }//int posFrac = begin;
          
        nFractional = scanDigits_StringPartScanJc(thiz, false, MAX_VALUE_IntegerJc, _thCxt);
        if(thiz->base.super.bCurrentOk) 
        { }
        else if(nDivisorFract >= 10) 
        { 
          
          thiz->base.super.bCurrentOk = true;//it is okay, at ex."9.0" is found. There are no more digits after "0".
          
          nFractional = 0;
        }
      }
      else 
      { 
        
        nFractional = 0;
      }//nDigitsFrac = 0;}
      
      if(thiz->base.super.bCurrentOk) 
      { 
        int32 nPosExponent; 
        
        
        nPosExponent = thiz->base.super.begin;
        if(nPosExponent < thiz->base.super.endMax && (cc = /*? assignment*/charAt_CharSequenceJc(REFJc(thiz->base.super.content), thiz->base.super.begin)) == 'e' || cc == 'E') 
        { 
          
          seek_i_StringPartJc(& ((* (thiz)).base.super), 1, _thCxt);
          if((cc = /*? assignment*/charAt_CharSequenceJc(REFJc(thiz->base.super.content), thiz->base.super.begin)) == '-') 
          { 
            
            bNegativExponent = true;
            seek_i_StringPartJc(& ((* (thiz)).base.super), 1, _thCxt);
            cc = charAt_CharSequenceJc(REFJc(thiz->base.super.content), thiz->base.super.begin);
          }
          if(cc >= '0' && cc <= '9') 
          { 
            
            nExponent = (int32)scanDigits_StringPartScanJc(thiz, false, MAX_VALUE_IntegerJc, _thCxt);
            if(!thiz->base.super.bCurrentOk) 
            { 
              
              nExponent = 0;
            }
          }
          else 
          { //: it isn't an exponent, but a String beginning with 'E' or 'e'.
            //:This string is not a part of the float number.
            
            
            thiz->base.super.begin = nPosExponent;
            nExponent = 0;
          }
        }
        else 
        { 
          
          nExponent = 0;
        }
      }
      else 
      { 
        
        nExponent = 0;
      }
      if(thiz->base.super.bCurrentOk) 
      { 
        double result; 
        
        
        result = nInteger;
        if(nFractional > 0) 
        { 
          double fFrac; 
          
          
          fFrac = nFractional;
          
          while(fFrac >= 1.0)
            { 
              
              fFrac /= 10.0;
            }
          fFrac /= nDivisorFract;//number of 0 after . until first digit.
          
          result += fFrac;
        }
        if(bNegativValue) 
        { 
          
          result = -result;
        }
        if(nExponent != 0) 
        { 
          
          if(bNegativExponent) 
          { 
            
            nExponent = -nExponent;
          }
          result *= pow_MathJc(/*static*/10, nExponent);
        }
        if(thiz->idxLastFloatNumber < thiz->nLastFloatNumber.head.length - 2) 
        { 
          
          thiz->nLastFloatNumber.data[++thiz->idxLastFloatNumber] = result;
        }
        else { throw_s0Jc(ident_ParseExceptionJc, "to much scanned floats", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Scans a sequence of hex chars a hex number*/
struct StringPartScanJc_t* scanHex_StringPartScanJc(StringPartScanJc_s* thiz, int32 maxNrofChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanHex_StringPartScanJc");
  
  { 
    
    if(scanEntry_StringPartScanJc(thiz, _thCxt)) 
    { 
      int64 value; 
      
      
      value = scanDigits_StringPartScanJc(thiz, true, maxNrofChars, _thCxt);
      if(thiz->base.super.bCurrentOk) 
      { 
        
        if(thiz->idxLastIntegerNumber < thiz->nLastIntegerNumber.head.length - 2) 
        { 
          
          thiz->nLastIntegerNumber.data[++thiz->idxLastIntegerNumber] = value;
        }
        else { throw_s0Jc(ident_ParseExceptionJc, "to much scanned integers", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Scans a integer number possible as hex, or decimal number.*/
struct StringPartScanJc_t* scanHexOrDecimal_StringPartScanJc(StringPartScanJc_s* thiz, int32 maxNrofChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanHexOrDecimal_StringPartScanJc");
  
  { 
    
    if(scanEntry_StringPartScanJc(thiz, _thCxt)) 
    { 
      int64 value = 0; 
      
      
      /*no initvalue*/
      if(equals_CsiiCs_StringFunctionsJc(/*static*/REFJc(thiz->base.super.content), thiz->base.super.begin, thiz->base.super.begin + 2, s0_StringJc("0x")/*J2C-error testAndChangeAccess: t**/, _thCxt)) 
      { 
        
        seek_i_StringPartJc(& ((* (thiz)).base.super), 2, _thCxt);
        value = scanDigits_StringPartScanJc(thiz, true, maxNrofChars, _thCxt);
      }
      else 
      { 
        
        value = scanDigits_StringPartScanJc(thiz, false, maxNrofChars, _thCxt);
      }
      if(thiz->base.super.bCurrentOk) 
      { 
        
        if(thiz->idxLastIntegerNumber < thiz->nLastIntegerNumber.head.length - 2) 
        { 
          
          thiz->nLastIntegerNumber.data[++thiz->idxLastIntegerNumber] = value;
        }
        else { throw_s0Jc(ident_ParseExceptionJc, "to much scanned integers", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/*** */
struct StringPartScanJc_t* scanIdentifier_StringPartScanJc(StringPartScanJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanIdentifier_StringPartScanJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return scanIdentifier_SS_StringPartScanJc(thiz, null_StringJc, null_StringJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/*** */
struct StringPartScanJc_t* scanIdentifier_SS_StringPartScanJc(StringPartScanJc_s* thiz, StringJc additionalStartChars, StringJc additionalChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanIdentifier_SS_StringPartScanJc");
  
  { 
    
    if(scanEntry_StringPartScanJc(thiz, _thCxt)) 
    { 
      
      lentoIdentifier_SS_StringPartJc(& ((* (thiz)).base.super), additionalStartChars, additionalChars, _thCxt);
      if(thiz->base.super.bFound) 
      { 
        
        SETREFJc(thiz->sLastString, & ((* (getCurrentPart_StringPartJc(& ((* (thiz)).base.super), _thCxt))).base.CharSequenceJc), CharSequenceJc);
        thiz->base.super.begin = thiz->base.super.end;//after identifier.
        
      }
      else 
      { 
        
        thiz->base.super.bCurrentOk = false;
      }
      thiz->base.super.end = thiz->base.super.endLast;//revert the change of length, otherwise end = end of identifier.
      
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the last scanned integer number*/
int64 getLastScannedIntegerNumber_StringPartScanJc(StringPartScanJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLastScannedIntegerNumber_StringPartScanJc");
  
  { 
    
    if(thiz->idxLastIntegerNumber >= 0) 
    { 
      
      { STACKTRC_LEAVE;
        return thiz->nLastIntegerNumber.data[thiz->idxLastIntegerNumber--];
      }
    }
    else { throw_s0Jc(ident_ParseExceptionJc, "no integer number scanned.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}


/**Returns the last scanned float number.*/
double getLastScannedFloatNumber_StringPartScanJc(StringPartScanJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLastScannedFloatNumber_StringPartScanJc");
  
  { 
    
    if(thiz->idxLastFloatNumber >= 0) 
    { 
      
      { STACKTRC_LEAVE;
        return thiz->nLastFloatNumber.data[thiz->idxLastFloatNumber--];
      }
    }
    else { throw_s0Jc(ident_ParseExceptionJc, "no float number scanned.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}


/**Returns the part of the last scanning yet only from {@link #scanIdentifier()}*/
struct CharSequenceJc_t* getLastScannedString_StringPartScanJc(StringPartScanJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLastScannedString_StringPartScanJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return REFJc(thiz->sLastString);
    }
  }
  STACKTRC_LEAVE;
}


/**Gets a String with translitaration.*/
struct CharSequenceJc_t* getCircumScriptionToAnyChar_StringPartScanJc(StringPartScanJc_s* thiz, StringJc sCharsEnd, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCircumScriptionToAnyChar_StringPartScanJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return getCircumScriptionToAnyChar_p_StringPartScanJc(thiz, sCharsEnd, false, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

struct CharSequenceJc_t* getCircumScriptionToAnyCharOutsideQuotion_StringPartScanJc(StringPartScanJc_s* thiz, StringJc sCharsEnd, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCircumScriptionToAnyCharOutsideQuotion_StringPartScanJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return getCircumScriptionToAnyChar_p_StringPartScanJc(thiz, sCharsEnd, true, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

struct CharSequenceJc_t* getCircumScriptionToAnyChar_p_StringPartScanJc(StringPartScanJc_s* thiz, StringJc sCharsEnd, bool bOutsideQuotion, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCircumScriptionToAnyChar_p_StringPartScanJc");
  
  { 
    struct CharSequenceJc_t* sResult = null; 
    char cEscape = '\\'; 
    int32 posEnd; 
    int32 posEscape; 
    
    
    /*no initvalue*/
    if(thiz->base.super.begin == 4910) stop_AssertJc(/*static*/_thCxt);
    cEscape = '\\';
    posEnd = (sCharsEnd.ptr__== null) ? thiz->base.super.end : bOutsideQuotion ? indexOfAnyCharOutsideQuotion_StringPartJc(& ((* (thiz)).base.super), sCharsEnd, 0, thiz->base.super.end - thiz->base.super.begin, _thCxt) : indexOfAnyChar_S_StringPartJc(& ((* (thiz)).base.super), sCharsEnd, _thCxt);
    if(posEnd < 0) posEnd = thiz->base.super.end - thiz->base.super.begin;//int posEscape = indexOf(cEscape);
    //search the first escape char inside the string.
    
    posEscape = indexOf_Csiic_StringFunctionsJc(/*static*/REFJc(thiz->base.super.content), thiz->base.super.begin, thiz->base.super.begin + posEnd, cEscape, _thCxt) - thiz->base.super.begin;
    if(posEscape < 0) 
    { //:there is no escape char in the current part to sCharsEnd,
      //:no extra conversion is necessary.
      
      
      sResult = & ((* (
        ( lento_i_StringPartJc(& ((* (thiz)).base.super), posEnd, _thCxt)
        , getCurrentPart_StringPartJc(& ((* (thiz)).base.super), _thCxt)
        ))).base.CharSequenceJc);
    }
    else 
    { //:escape character is found before end
      
      
      if(charAt_CharSequenceJc(REFJc(thiz->base.super.content), thiz->base.super.begin + posEnd - 1) == cEscape) 
      { //:the escape char is the char immediately before the end char.
        //:It means, the end char isn't such one and posEnd is faulty.
        //:Search the really end char:
        
        
        do 
          { //:search the end char after part of string without escape char
            
            
            posEnd = (sCharsEnd.ptr__== null) ? thiz->base.super.end : indexOfAnyChar_Sii_StringPartJc(& ((* (thiz)).base.super), sCharsEnd, posEscape + 2, MAX_VALUE_IntegerJc, _thCxt);
            if(posEnd < 0) posEnd = thiz->base.super.end;
            posEscape = indexOf_ci_StringPartJc(& ((* (thiz)).base.super), cEscape, posEscape + 2, _thCxt);
          }while((posEscape + 1) == posEnd);
      }
      lento_i_StringPartJc(& ((* (thiz)).base.super), posEnd, _thCxt);
      sResult = resolveCircumScription_SpecialCharStringsJc(/*static*/& ((* (getCurrentPart_StringPartJc(& ((* (thiz)).base.super), _thCxt))).base.CharSequenceJc), _thCxt);
    }
    fromEnd_StringPartJc(& ((* (thiz)).base.super), _thCxt);
    { STACKTRC_LEAVE;
      return sResult;
    }
  }
  STACKTRC_LEAVE;
}


/**Scans a String with transcription till one of end characters, maybe outside any quotation.*/
struct StringPartScanJc_t* scanTranscriptionToAnyChar_StringPartScanJc(StringPartScanJc_s* thiz, CharSequenceJc_Y* dst, StringJc sCharsEnd, char transcriptChar, char quotationStartChar, char quotationEndChar, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanTranscriptionToAnyChar_StringPartScanJc");
  
  { 
    
    if(scanEntry_StringPartScanJc(thiz, _thCxt)) 
    { 
      int32 posEnd; 
      
      
      if(thiz->base.super.begin == 4910) stop_AssertJc(/*static*/_thCxt);
      posEnd = indexOfAnyChar_Siiccc_StringPartJc(& ((* (thiz)).base.super), sCharsEnd, 0, thiz->base.super.end - thiz->base.super.begin, transcriptChar, quotationStartChar, quotationEndChar, _thCxt);
      if(posEnd >= 0) 
      { 
        
        lento_i_StringPartJc(& ((* (thiz)).base.super), posEnd, _thCxt);
        if(dst != null) 
        { 
          
          dst->data[0] = convertTranscription_StringFunctionsJc(/*static*/& ((* (getCurrentPart_StringPartJc(& ((* (thiz)).base.super), _thCxt))).base.CharSequenceJc), transcriptChar, _thCxt);
        }
        fromEnd_StringPartJc(& ((* (thiz)).base.super), _thCxt);
      }
      else 
      { 
        
        thiz->base.super.bCurrentOk = false;
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Closes the work*/
void close_StringPartScanJc_F(StringPartScanJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("close_StringPartScanJc_F");
  
  { 
    
    ((Mtbl_StringPartJc const*)getMtbl_ObjectJc(&((&thiz->base.super))->base.object, sign_Mtbl_StringPartJc) )->close((&thiz->base.super), _thCxt);
    CLEAR_REFJc(thiz->sLastString);
    thiz->beginScan = 0;
    thiz->base.super.bCurrentOk = thiz->base.super.bFound = /*? assignment*/false;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void close_StringPartScanJc(StringPartScanJc_s* thiz, ThCxt* _thCxt)
{ Mtbl_StringPartScanJc const* mtbl = (Mtbl_StringPartScanJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_StringPartScanJc);
  mtbl->close(thiz, _thCxt);
}


void finalize_StringPartScanJc_F(ObjectJc* othis, ThCxt* _thCxt)
{ StringPartScanJc_s* thiz = (StringPartScanJc_s*)othis;  //upcasting to the real class.
 STACKTRC_TENTRY("finalize_StringPartScanJc_F");
  CLEAR_REFJc(thiz->sLastString);
  finalize_StringPartJc_F(&thiz->base.object, _thCxt); //J2C: finalizing the superclass.
  STACKTRC_LEAVE;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_StringPartScanJc mtblStringPartScanJc = {
{ { sign_Mtbl_StringPartScanJc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((1 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, close_StringPartScanJc_F //close
, { { sign_Mtbl_StringPartJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_StringPartScanJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
    /**J2C: Mtbl-interfaces of StringPartScanJc: */
  , { { sign_Mtbl_CharSequenceJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    }
  , { { sign_Mtbl_ComparableJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    }
  , { { sign_Mtbl_CloseableJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern_C struct ClassJc_t const reflection_StringPartJc_s;
 static struct superClasses_StringPartScanJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_StringPartScanJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_StringPartJc_s, OFFSET_Mtbl(Mtbl_StringPartScanJc, StringPartJc) }
   }
 };

extern_C struct ClassJc_t const reflection_StringPartScanJc_s;
extern_C struct ClassJc_t const reflection_CharSequenceJc;
const struct Reflection_Fields_StringPartScanJc_s_t
{ ObjectArrayJc head; FieldJc data[6];
} reflection_Fields_StringPartScanJc_s =
{ CONST_ObjectArrayJc(FieldJc, 6, OBJTYPE_FieldJc, null, &reflection_Fields_StringPartScanJc_s)
, {
     { "beginScan"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartScanJc_s*)(0x1000))->beginScan) - (int32)(StringPartScanJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartScanJc_s
    }
   , { "nLastIntegerNumber"
    , 5 //nrofArrayElements
    , REFLECTION_int64
    , 8 << kBitPrimitiv_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |kEmbeddedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartScanJc_s*)(0x1000))->nLastIntegerNumber) - (int32)(StringPartScanJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartScanJc_s
    }
   , { "idxLastIntegerNumber"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartScanJc_s*)(0x1000))->idxLastIntegerNumber) - (int32)(StringPartScanJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartScanJc_s
    }
   , { "nLastFloatNumber"
    , 5 //nrofArrayElements
    , REFLECTION_double
    , 8 << kBitPrimitiv_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |kEmbeddedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartScanJc_s*)(0x1000))->nLastFloatNumber) - (int32)(StringPartScanJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartScanJc_s
    }
   , { "idxLastFloatNumber"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartScanJc_s*)(0x1000))->idxLastFloatNumber) - (int32)(StringPartScanJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartScanJc_s
    }
   , { "sLastString"
    , 0 //nrofArrayElements
    , &reflection_CharSequenceJc
    , kEnhancedReference_Modifier_reflectJc /*@*/ //bitModifiers
    , (int16)((int32)(&((StringPartScanJc_s*)(0x1000))->sLastString) - (int32)(StringPartScanJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartScanJc_s
    }
} };
const ClassJc reflection_StringPartScanJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "StringPartScanJc_s"
,  0 //position of ObjectJc
, sizeof(StringPartScanJc_s)
, (FieldJcArray const*)&reflection_Fields_StringPartScanJc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_StringPartScanJc_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblStringPartScanJc.mtbl.head
};
