/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "J1c/StringPartJc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "J1c/StringFunctionsJc.h"  //reference-association: StringFunctionsJc_s
#include "Jc/SystemJc.h"  //reference-association: SystemJc


/* J2C: Forward declaration of struct ***********************************************/

/**This is an alternative to the {@link java.lang.String} which uses a shared reference to the char sequence.
This class is able to use if String processing is done in a closed thread. This class must not be used
instead java.lang.String if the String would referenced persistently and used from more as one thread.
String with this class are not immutable.
@author Hartmut Schorrig

*/


const char sign_Mtbl_StringPartJc[] = "StringPartJc"; //to mark method tables of all implementations

typedef struct MtblDef_StringPartJc_t { Mtbl_StringPartJc mtbl; MtblHeadJc end; } MtblDef_StringPartJc;
 extern MtblDef_StringPartJc const mtblStringPartJc;
StringJc sVersion_StringPartJc = CONST_z_StringJc("2014-01-12");
const int32 seekToLeft_StringPartJc = mSeekToLeft__StringPartJc + mSeekBackward__StringPartJc;
const int32 seekBack_StringPartJc = 0x20 + mSeekBackward__StringPartJc;
const char cStartOfText_StringPartJc = (char)(0x2);
const char cEndOfText_StringPartJc = (char)(0x3);

/*Constructor */
struct StringPartJc_t* ctorO_StringPartJc(ObjectJc* othis, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringPartJc_s, sizeof(StringPartJc_s));  
  //j2c: Initialize all class variables:
  {
    thiz->bCurrentOk = true;
    thiz->bStartScan = true;
    thiz->bFound = true;
    thiz->bitMode = 0;
    set_StringJc(&(thiz->sCommentStart), z_StringJc("/*"));
    set_StringJc(&(thiz->sCommentEnd), z_StringJc("*/"));
    set_StringJc(&(thiz->sCommentToEol), z_StringJc("//"));
  }
  { 
    
    CLEAR_REFJc(thiz->content);
    thiz->begiMin = thiz->begin = /*? assignment*/thiz->beginLast = /*? assignment*/0;
    thiz->endLast = thiz->endMax = /*? assignment*/thiz->end = /*? assignment*/0;
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct StringPartJc_t* ctorO_Cs_StringPartJc(ObjectJc* othis, struct CharSequenceJc_t* src, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringPartJc_s, sizeof(StringPartJc_s));  
  //j2c: Initialize all class variables:
  {
    thiz->bCurrentOk = true;
    thiz->bStartScan = true;
    thiz->bFound = true;
    thiz->bitMode = 0;
    set_StringJc(&(thiz->sCommentStart), z_StringJc("/*"));
    set_StringJc(&(thiz->sCommentEnd), z_StringJc("*/"));
    set_StringJc(&(thiz->sCommentToEol), z_StringJc("//"));
  }
  { 
    
    ctorO_Csii_StringPartJc(othis, src, 0, length_CharSequenceJc(src, _thCxt), _thCxt);
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct StringPartJc_t* ctorO_Csii_StringPartJc(ObjectJc* othis, struct CharSequenceJc_t* src, int32 start, int32 end, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringPartJc_s, sizeof(StringPartJc_s));  
  //j2c: Initialize all class variables:
  {
    thiz->bCurrentOk = true;
    thiz->bStartScan = true;
    thiz->bFound = true;
    thiz->bitMode = 0;
    set_StringJc(&(thiz->sCommentStart), z_StringJc("/*"));
    set_StringJc(&(thiz->sCommentEnd), z_StringJc("*/"));
    set_StringJc(&(thiz->sCommentToEol), z_StringJc("//"));
  }
  { 
    
    thiz->begiMin = thiz->begin = /*? assignment*/start;
    thiz->endMax = thiz->end = /*? assignment*/end;
    SETREFJc(thiz->content, src, CharSequenceJc);
  }
  STACKTRC_LEAVE;
  return thiz;
}



/**Sets the input file for information {@link #getInputfile()}*/
void setInputfile_StringPartJc(StringPartJc_s* thiz, StringJc file, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInputfile_StringPartJc");
  
  { 
    
    set_StringJc(&(thiz->sFile), file);
  }
  STACKTRC_LEAVE;
}


/**Sets the content to the given string, forgets the old content*/
struct StringPartJc_t* assign_Cs_StringPartJc(StringPartJc_s* thiz, struct CharSequenceJc_t* ref, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("assign_Cs_StringPartJc");
  
  { 
    
    SETREFJc(thiz->content, ref, CharSequenceJc);
    mtthis->setParttoMax(thiz);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the content to the given string, forgets the old content.*/
struct StringPartJc_t* assignReplaceEnv_StringPartJc(StringPartJc_s* thiz, struct StringBuilderJc_t* input, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assignReplaceEnv_StringPartJc");
  
  { 
    int32 pos1 = 0; 
    int32 zInput; 
    
    
    pos1 = 0;
    zInput = length_StringBuilderJc(input);
    
    while((pos1 = /*? assignment*/indexOf_zI_StringBuilderJc(input, "$", pos1, _thCxt)) >= 0)
      { 
        int32 posident = 0; 
        int32 posidentend = 0; 
        int32 pos9 = 0; 
        StringJc sEnv; 
        
        
        /*no initvalue*/
        /*no initvalue*/
        /*no initvalue*/
        if(charAt_StringBuilderJc(input, pos1 + 1, _thCxt) == '(') 
        { 
          
          posident = pos1 + 2;
          posidentend = indexOf_zI_StringBuilderJc(input, ")", posident, _thCxt);
          pos9 = posidentend + 1;/*after )*/
          
        }
        else 
        { 
          
          posident = pos1 + 1;
          posidentend = pos9 = /*? assignment*/posAfterIdentifier_Csii_StringFunctionsJc(/*static*/input, posident, zInput, _thCxt);
        }
        sEnv = getenv_SystemJc(/*static*/substring_StringBuilderJc(input, posident, posidentend, _thCxt), _thCxt)/*J2C:non-persistent*/;
        if(sEnv.ptr__== null) 
        { 
          
          sEnv = z_StringJc("")/*J2C:non-persistent*/;
        }
        replace_StringBuilderJc(input, pos1, pos9, sEnv, _thCxt);
        zInput = length_StringBuilderJc(input);
      }
    SETREFJc(thiz->content, input, CharSequenceJc);
    thiz->begiMin = thiz->beginLast = /*? assignment*/thiz->begin = /*? assignment*/0;
    thiz->endMax = thiz->end = /*? assignment*/thiz->endLast = /*? assignment*/length_CharSequenceJc(REFJc(thiz->content), _thCxt);
    thiz->bStartScan = thiz->bCurrentOk = /*? assignment*/true;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the StringPart with the same String object as the given StringPart, forgets the old content.*/
struct StringPartJc_t* assign_XX_StringPartJc(StringPartJc_s* thiz, struct StringPartJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assign_XX_StringPartJc");
  
  { 
    
    if(src == thiz) 
    { /*:set from the own instance: the maxPart is the actual one.*/
      
      
      thiz->begiMin = thiz->beginLast = /*? assignment*/thiz->begin;
      thiz->endMax = thiz->endLast = /*? assignment*/thiz->end;
    }
    else 
    { /*:set from a other instance, inherit the content.*/
      
      
      SETREFJc(thiz->content, REFJc(src->content), CharSequenceJc);
      thiz->begiMin = thiz->beginLast = /*? assignment*/thiz->begin = /*? assignment*/src->begin;
      thiz->endMax = thiz->end = /*? assignment*/thiz->endLast = /*? assignment*/src->end;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the content of the StringPart , forgets the old content*/
struct StringPartJc_t* assignFromEnd_StringPartJc(StringPartJc_s* thiz, struct StringPartJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assignFromEnd_StringPartJc");
  
  { 
    
    SETREFJc(thiz->content, REFJc(src->content), CharSequenceJc);
    thiz->beginLast = thiz->begin;
    thiz->begiMin = thiz->begin = /*? assignment*/src->end;/*from actual end*/
    
    thiz->endLast = thiz->endMax = /*? assignment*/thiz->end = /*? assignment*/src->endMax;/*from maximal end*/
    
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the mode of ignoring comments.*/
bool setIgnoreComment_b_StringPartJc(StringPartJc_s* thiz, bool bSet, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreComment_b_StringPartJc");
  
  { 
    bool bRet; 
    
    
    bRet = (thiz->bitMode & mSkipOverCommentInsideText_mode_StringPartJc) != 0;
    if(bSet) thiz->bitMode |= mSkipOverCommentInsideText_mode_StringPartJc;
    else thiz->bitMode &= ~mSkipOverCommentInsideText_mode_StringPartJc;
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the character string of inline commentmode of ignoring comments.*/
bool setIgnoreComment_SS_StringPartJc(StringPartJc_s* thiz, StringJc sStart, StringJc sEnd, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreComment_SS_StringPartJc");
  
  { 
    bool bRet; 
    
    
    bRet = (thiz->bitMode & mSkipOverCommentInsideText_mode_StringPartJc) != 0;
    thiz->bitMode |= mSkipOverCommentInsideText_mode_StringPartJc;
    set_StringJc(&(thiz->sCommentStart), sStart);
    set_StringJc(&(thiz->sCommentEnd), sEnd);
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the mode of ignoring comments to end of line.*/
bool setIgnoreEndlineComment_b_StringPartJc(StringPartJc_s* thiz, bool bSet, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreEndlineComment_b_StringPartJc");
  
  { 
    bool bRet; 
    
    
    bRet = (thiz->bitMode & mSkipOverCommentToEol_mode_StringPartJc) != 0;
    if(bSet) thiz->bitMode |= mSkipOverCommentToEol_mode_StringPartJc;
    else thiz->bitMode &= ~mSkipOverCommentToEol_mode_StringPartJc;
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the character string introducing the comments to end of line.*/
bool setIgnoreEndlineComment_S_StringPartJc(StringPartJc_s* thiz, StringJc sStart, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreEndlineComment_S_StringPartJc");
  
  { 
    bool bRet; 
    
    
    bRet = (thiz->bitMode & mSkipOverCommentToEol_mode_StringPartJc) != 0;
    thiz->bitMode |= mSkipOverCommentToEol_mode_StringPartJc;
    set_StringJc(&(thiz->sCommentToEol), sStart);
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the mode of ignoring whitespaces.*/
bool setIgnoreWhitespaces_StringPartJc(StringPartJc_s* thiz, bool bSet, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreWhitespaces_StringPartJc");
  
  { 
    bool bRet; 
    
    
    bRet = (thiz->bitMode & mSkipOverWhitespace_mode_StringPartJc) != 0;
    if(bSet) thiz->bitMode |= mSkipOverWhitespace_mode_StringPartJc;
    else thiz->bitMode &= ~mSkipOverWhitespace_mode_StringPartJc;
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the start of the maximal part to the actual start of the valid part.*/
struct StringPartJc_t* setBeginMaxPart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setBeginMaxPart_StringPartJc");
  
  { 
    
    thiz->begiMin = thiz->begin;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the start of the part to the exclusively end, set the end to the end of the content.*/
struct StringPartJc_t* fromEnd_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("fromEnd_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    thiz->endLast = thiz->end;
    thiz->begin = thiz->end;
    thiz->end = thiz->endMax;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**This method returns the characters of the current part.*/
char charAt_StringPartJc(StringPartJc_s* thiz, int32 index, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("charAt_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return absCharAt_StringPartJc(thiz, thiz->begin + index, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns a volatile CharSequence from the range inside the current part.*/
struct Part_StringPartJc_t* subSequence_StringPartJc(StringPartJc_s* thiz, int32 from, int32 to, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("subSequence_StringPartJc");
  
  { 
    ObjectJc *newObj1_1=null; /*J2C: temporary Objects for new operations
    */StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(from < 0 || to > (thiz->end - thiz->begin)) { throw_sJc(ident_IllegalArgumentExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "StringPartBase.subString - faulty;", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, from, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin + from, thiz->begin + to, _thCxt), _thCxt);
      return ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin + from, thiz->begin + to, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 length_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("length_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->end - thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the lenght of the maximal part from current position*/
int32 lengthMaxPart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lengthMaxPart_StringPartJc");
  
  { 
    
    if(thiz->endMax > thiz->begin) { STACKTRC_LEAVE;
      return thiz->endMax - thiz->begin;
    }
    else { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the endposition of the part of string to the given chars after start.*/
struct StringPartJc_t* lento_i_StringPartJc(StringPartJc_s* thiz, int32 len, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lento_i_StringPartJc");
  
  { 
    int32 endNew; 
    
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    thiz->endLast = thiz->end;
    endNew = thiz->begin + len;
    if(endNew < thiz->begin) /***/
    throwIndexOutOfBoundsException_StringPartJc(thiz, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "lento(int) negative:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, (endNew - thiz->begin), _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), _thCxt);
    if(endNew > thiz->endMax) /***/
    throwIndexOutOfBoundsException_StringPartJc(thiz, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "lento(int) after endMax:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, (endNew - thiz->endMax), _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), _thCxt);
    thiz->end = endNew;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the end position of the part of string to exclusively the char cc.*/
struct StringPartJc_t* lento_c_StringPartJc(StringPartJc_s* thiz, char cc, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lento_c_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    thiz->end = thiz->begin - 1;
    
    while(++thiz->end < thiz->endLast)
      { 
        
        if(charAt_CharSequenceJc(REFJc(thiz->content), thiz->end, _thCxt) == cc) 
        { 
          
          thiz->bFound = true;
          { STACKTRC_LEAVE;
          return thiz;
        }
        }
      }
    thiz->end = thiz->begin;/*not found*/
    
    thiz->bFound = false;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the endposition of the part of string to exclusively the given string.*/
struct StringPartJc_t* lento_S_StringPartJc(StringPartJc_s* thiz, StringJc ss, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lento_S_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lento_Csi_StringPartJc(thiz, ((/*J2C:cast from StringJc*/CharSequenceJc*)(ss/*J2C-error testAndChangeAccess: t**/)), seekNormal_StringPartJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the endposition of the part of string to exclusively the given string.*/
struct StringPartJc_t* lento_Csi_StringPartJc(StringPartJc_s* thiz, struct CharSequenceJc_t* ss, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lento_Csi_StringPartJc");
  
  { 
    int32 pos; 
    
    
    thiz->endLast = thiz->end;
    pos = indexOf_CsiiCs_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin, thiz->end, ss, _thCxt);
    thiz->bFound = (pos >= 0);
    if(pos >= 0) 
    { 
      
      thiz->end = pos;
      if((mode & seekEnd_StringPartJc) != 0) 
      { 
        
        thiz->end += length_CharSequenceJc(ss, _thCxt);
      }
    }
    else 
    { 
      
      thiz->end = thiz->begin;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the endposition of the part of string to the end of the identifier which is beginning on start.*/
struct StringPartJc_t* lentoIdentifier_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoIdentifier_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lentoIdentifier_SS_StringPartJc(thiz, null_StringJc, null_StringJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the endposition of the part of string to the end of the identifier which is beginning on start.*/
struct StringPartJc_t* lentoIdentifier_SS_StringPartJc(StringPartJc_s* thiz, StringJc additionalStartChars, StringJc additionalChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoIdentifier_SS_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    thiz->end = thiz->begin;
    if(thiz->end >= thiz->endMax) 
    { 
      
      thiz->bFound = false;
    }
    else 
    { /*:TODO use StringFunctions.lenIdentifier*/
      
      char cc; 
      
      
      cc = charAt_CharSequenceJc(REFJc(thiz->content), thiz->end, _thCxt);
      if(cc == '_' || (cc >= 'A' && cc <= 'Z') || (cc >= 'a' && cc <= 'z') || (additionalStartChars.ptr__!= null && indexOf_C_StringJc(additionalStartChars, cc) >= 0)) 
      { 
        
        thiz->end += 1;
        
        while(thiz->end < thiz->endMax && ((cc = /*? assignment*/charAt_CharSequenceJc(REFJc(thiz->content), thiz->end, _thCxt)) == '_' || (cc >= '0' && cc <= '9') || (cc >= 'A' && cc <= 'Z') || (cc >= 'a' && cc <= 'z') || (additionalChars.ptr__!= null && indexOf_C_StringJc(additionalChars, cc) >= 0)))
          { 
            
            thiz->end += 1;
          }
      }
      thiz->bFound = (thiz->end > thiz->begin);
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the len to the first position of any given char, but not if the char is escaped.*/
struct StringPartJc_t* lentoAnyNonEscapedChar_StringPartJc(StringPartJc_s* thiz, StringJc sCharsEnd, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyNonEscapedChar_StringPartJc");
  
  { 
    
    if(thiz->bCurrentOk) 
    { 
      char cEscape = '\\'; 
      int32 pos; 
      
      
      cEscape = '\\';
      thiz->endLast = thiz->end;
      pos = indexOfAnyChar_Sii_StringPartJc(thiz, sCharsEnd, 0, maxToTest, _thCxt);
      
      while(pos > thiz->begin + 1 && charAt_CharSequenceJc(REFJc(thiz->content), pos - 1, _thCxt) == cEscape)
        { /*:the escape char is before immediately. It means, the end char is not matched.*/
          
          
          pos = indexOfAnyChar_Sii_StringPartJc(thiz, sCharsEnd, pos + 1 - thiz->begin, maxToTest, _thCxt);
        }
      if(pos < 0) 
      { 
        
        thiz->end = thiz->begin;
        thiz->bFound = false;
      }
      else 
      { 
        
        thiz->end = thiz->begin + pos;
        thiz->bFound = true;
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the valid part to the first position of the given String,*/
struct StringPartJc_t* lentoNonEscapedString_StringPartJc(StringPartJc_s* thiz, StringJc sEnd, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoNonEscapedString_StringPartJc");
  
  { 
    
    if(thiz->bCurrentOk) 
    { 
      char cEscape = '\\'; 
      int32 pos; 
      
      
      cEscape = '\\';
      thiz->endLast = thiz->end;
      pos = indexOf_Csii_StringPartJc(thiz, ((/*J2C:cast from StringJc*/CharSequenceJc*)(sEnd/*J2C-error testAndChangeAccess: t**/)), 0, maxToTest, _thCxt);
      
      while(pos > thiz->begin + 1 && charAt_CharSequenceJc(REFJc(thiz->content), pos - 1, _thCxt) == cEscape)
        { /*:the escape char is before immediately. It means, the end char is not matched.*/
          
          
          pos = indexOf_Csii_StringPartJc(thiz, ((/*J2C:cast from StringJc*/CharSequenceJc*)(sEnd/*J2C-error testAndChangeAccess: t**/)), pos + 1 - thiz->begin, maxToTest, _thCxt);
        }
      if(pos < 0) 
      { 
        
        thiz->end = thiz->begin;
        thiz->bFound = false;
      }
      else 
      { 
        
        thiz->end = thiz->begin + pos;
        thiz->bFound = true;
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the current Part from the current position to exactly one line.*/
struct StringPartJc_t* line_StringPartJc_F(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("line_StringPartJc_F");
  
  { 
    int32 posStart; 
    int32 posEnd; 
    
    
    posStart = lastIndexOfAnyChar_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begiMin, thiz->begin, s0_StringJc("\r\n"), _thCxt);
    if(posStart < 0) 
    { 
      
      posStart = thiz->begiMin;
    }
    posEnd = indexOfAnyChar_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin, thiz->endMax, s0_StringJc("\r\n"), _thCxt);
    if(posEnd < 0) 
    { 
      
      posEnd = thiz->endMax;
    }
    thiz->begin = posStart;
    thiz->end = posEnd;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* line_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_StringPartJc);
  return mtbl->line(thiz, _thCxt);
}


/**Displaces the start of the part for some chars to left or to right.*/
struct StringPartJc_t* seek_i_StringPartJc(StringPartJc_s* thiz, int32 nr, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seek_i_StringPartJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    thiz->beginLast = thiz->begin;
    thiz->begin += nr;
    if(thiz->begin > thiz->end) /***/
    throwIndexOutOfBoundsException_StringPartJc(thiz, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "seek=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, nr, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, " begin=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->begin - nr), _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, " end=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->end, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), _thCxt);
    else if(thiz->begin < thiz->begiMin) /***/
    throwIndexOutOfBoundsException_StringPartJc(thiz, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "seek=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, nr, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, " begin=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->begin - nr), _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, " begin-min=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->begiMin, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), _thCxt);
    thiz->bFound = true;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Displaces the start of the part to the first char it is no whitespace.*/
struct StringPartJc_t* seekNoWhitespace_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekNoWhitespace_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    
    while(thiz->begin < thiz->end && indexOf_C_StringJc(zI_StringJc(" \t\r\n\f",5), charAt_CharSequenceJc(REFJc(thiz->content), thiz->begin, _thCxt)) >= 0)
      { 
        
        thiz->begin += 1;
      }
    thiz->bFound = (thiz->begin > thiz->beginLast);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**skip over comment and whitespaces*/
struct StringPartJc_t* skipWhitespaceAndComment_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("skipWhitespaceAndComment_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return seekNoWhitespaceOrComments_StringPartJc(thiz, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Displaces the begin of the part to the first char it is no whitespace or comment.*/
struct StringPartJc_t* seekNoWhitespaceOrComments_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekNoWhitespaceOrComments_StringPartJc");
  
  { 
    int32 start00; 
    int32 start0 = 0; 
    
    
    start00 = thiz->begin;
    /*no initvalue*/
    do 
      { 
        
        start0 = thiz->begin;
        if((thiz->bitMode & mSkipOverWhitespace_mode_StringPartJc) != 0) 
        { 
          
          seekNoWhitespace_StringPartJc(thiz, _thCxt);
        }
        if((thiz->bitMode & mSkipOverCommentInsideText_mode_StringPartJc) != 0) 
        { 
          
          if(compare_CsiCsii_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin, ((/*J2C:cast from StringJc*/CharSequenceJc*)(thiz->sCommentStart/*J2C-error testAndChangeAccess: t**/)), 0, length_StringJc(thiz->sCommentStart), _thCxt) == 0) 
          { 
            
            seek_Si_StringPartJc(thiz, thiz->sCommentEnd, seekEnd_StringPartJc, _thCxt);
          }
        }
        if((thiz->bitMode & mSkipOverCommentToEol_mode_StringPartJc) != 0) 
        { 
          
          if(compare_CsiCsii_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin, ((/*J2C:cast from StringJc*/CharSequenceJc*)(thiz->sCommentToEol/*J2C-error testAndChangeAccess: t**/)), 0, length_StringJc(thiz->sCommentToEol), _thCxt) == 0) 
          { 
            
            seek_ci_StringPartJc(thiz, '\n', seekEnd_StringPartJc, _thCxt);
          }
        }
      }while(thiz->begin != start0);/*:TRICKY: if something is done, repeat all conditions.*/
    
    thiz->bFound = (thiz->begin > start00);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns true, if the last called seek__(), lento__() or skipWhitespaceAndComment()*/
bool found_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("found_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->bFound;
    }
  }
  STACKTRC_LEAVE;
}


/**Displaces the begin of the part to the leftest possible begin.*/
struct StringPartJc_t* seekBegin_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekBegin_StringPartJc");
  
  { 
    
    thiz->begin = thiz->beginLast = /*? assignment*/thiz->begiMin;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Searchs the given String inside the valid part, posits the begin of the part to the begin of the searched string.*/
struct StringPartJc_t* seek_Si_StringPartJc(StringPartJc_s* thiz, StringJc sSeek, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seek_Si_StringPartJc");
  
  { 
    int32 seekArea1 = 0; 
    int32 seekArea9 = 0; 
    int32 posNotFound = 0; 
    int32 pos = 0; 
    
    
    thiz->beginLast = thiz->begin;
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    if((mode & mSeekToLeft__StringPartJc) == mSeekToLeft__StringPartJc) 
    { 
      int32 posAreaEnd; 
      
      
      posAreaEnd = thiz->begin + length_StringJc(sSeek) - 1;
      if(posAreaEnd > thiz->endMax) posAreaEnd = thiz->endMax;/*but not over the end.*/
      
      seekArea1 = thiz->begiMin;
      seekArea9 = posAreaEnd;/*sSeekArea = content.substring(startMin, posAreaEnd );*/
      
      posNotFound = thiz->begin;/*if not found, the rightest position of area*/
      
    }
    else 
    { 
      
      seekArea1 = thiz->begin;
      seekArea9 = thiz->end;/*sSeekArea = content.substring(begin, end );*/
      
      posNotFound = thiz->end;/*if not found, the rightest position of area*/
      
    }
    /*no initvalue*/
    if((mode & mSeekBackward__StringPartJc) == mSeekBackward__StringPartJc) 
    { 
      
      pos = lastIndexOf_CsiiS_StringFunctionsJc(/*static*/REFJc(thiz->content), seekArea1, seekArea9, sSeek, _thCxt);/*sSeekArea.lastIndexOf(sSeek);*/
      
    }
    else 
    { 
      
      pos = indexOf_CsiiS_StringFunctionsJc(/*static*/REFJc(thiz->content), seekArea1, seekArea9, sSeek, _thCxt);
    }
    if(pos < 0) 
    { 
      
      thiz->begin = posNotFound;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->bFound = true;
      thiz->begin = pos;
      if((mode & seekEnd_StringPartJc) == seekEnd_StringPartJc) 
      { 
        
        thiz->begin += length_StringJc(sSeek);
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Seeks back form the current end to the end of the given String starting from the end of the current part.*/
struct StringPartJc_t* seekBack_StringPartJc(StringPartJc_s* thiz, StringJc sSeek, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekBack_StringPartJc");
  
  { 
    int32 pos; 
    
    
    pos = lastIndexOf_CsiiS_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin, thiz->end, sSeek, _thCxt);
    if(pos < 0) thiz->bFound = false;
    else 
    { 
      
      thiz->begin = pos + length_StringJc(sSeek);
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Seeks back from the current end to one of the characters contained in chars, starting from the end of the current part.*/
struct StringPartJc_t* seekBackToAnyChar_StringPartJc(StringPartJc_s* thiz, StringJc chars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekBackToAnyChar_StringPartJc");
  
  { 
    int32 pos; 
    
    
    pos = lastIndexOfAnyChar_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin, thiz->end, chars, _thCxt);
    if(pos < 0) thiz->bFound = false;
    else 
    { 
      
      thiz->begin = pos;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Searchs the given String inside the valid part, posits the begin of the part to the begin of the searched string.*/
struct StringPartJc_t* seekAnyString_StringPartJc(StringPartJc_s* thiz, StringJc_Y* strings, int32_Y* nrofFoundString, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekAnyString_StringPartJc");
  
  { 
    int32 pos = 0; 
    
    
    thiz->beginLast = thiz->begin;
    /*no initvalue*/
    pos = indexOfAnyString_StringPartJc(thiz, ((/*J2C:cast from StringJc*/CharSequenceJc*)(strings/*J2C-error testAndChangeAccess: X**/)), 0, MAX_VALUE_IntegerJc, nrofFoundString, null, _thCxt);
    if(pos < 0) 
    { 
      
      thiz->bFound = false;
      thiz->begin = thiz->end;
    }
    else 
    { 
      
      thiz->bFound = true;
      thiz->begin = thiz->begin + pos;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Searchs the given character inside the valid part, posits the begin of the part to the begin of the searched char.*/
struct StringPartJc_t* seek_ci_StringPartJc(StringPartJc_s* thiz, char cSeek, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seek_ci_StringPartJc");
  
  { 
    int32 seekArea1 = 0; 
    int32 seekArea9 = 0; 
    int32 posNotFound = 0; 
    int32 pos = 0; 
    
    
    thiz->beginLast = thiz->begin;
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    if((mode & mSeekToLeft__StringPartJc) == mSeekToLeft__StringPartJc) 
    { 
      int32 posAreaEnd; 
      
      
      posAreaEnd = thiz->begin;
      if(posAreaEnd > thiz->endMax) posAreaEnd = thiz->endMax;/*but not over the end.*/
      
      seekArea1 = thiz->begiMin;
      seekArea9 = posAreaEnd;/*sSeekArea = content.substring(startMin, posAreaEnd );*/
      
      posNotFound = thiz->begin;/*if not found, the rightest position of area*/
      
    }
    else 
    { 
      
      seekArea1 = thiz->begin;
      seekArea9 = thiz->end;/*sSeekArea = content.substring(begin, end );*/
      
      posNotFound = thiz->end;/*if not found, the rightest position of area*/
      
    }
    /*no initvalue*/
    if((mode & mSeekBackward__StringPartJc) == mSeekBackward__StringPartJc) 
    { 
      
      pos = lastIndexOf_Csiic_StringFunctionsJc(/*static*/REFJc(thiz->content), seekArea1, seekArea9, cSeek, _thCxt);
    }
    else 
    { 
      
      pos = indexOf_Csiic_StringFunctionsJc(/*static*/REFJc(thiz->content), seekArea1, seekArea9, cSeek, _thCxt);
    }
    if(pos < 0) 
    { 
      
      thiz->begin = posNotFound;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->bFound = true;
      thiz->begin = pos;
      if((mode & seekEnd_StringPartJc) == seekEnd_StringPartJc) 
      { 
        
        thiz->begin += 1;
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Posits the start of the part after all of the chars given in the parameter string.*/
struct StringPartJc_t* seekNoChar_StringPartJc(StringPartJc_s* thiz, StringJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekNoChar_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    
    while(thiz->begin < thiz->end && indexOf_C_StringJc(sChars, charAt_CharSequenceJc(REFJc(thiz->content), thiz->begin, _thCxt)) >= 0)thiz->begin += 1;
    if(thiz->begin < thiz->end) thiz->bFound = true;
    else thiz->bFound = false;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Searches any char contained in sChars in the current part*/
int32 indexOfAnyChar_Sii_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyChar_Sii_StringPartJc");
  
  { 
    int32 pos; 
    int32 max; 
    int32 found; 
    
    
    pos = thiz->begin + fromWhere;
    max = (thiz->end - pos) < maxToTest ? thiz->end : pos + maxToTest;
    found = indexOfAnyChar_StringFunctionsJc(/*static*/REFJc(thiz->content), pos, max, sChars, _thCxt);
    if(found < 0) { STACKTRC_LEAVE;
      return found;
    }
    else { STACKTRC_LEAVE;
      return found - thiz->begin;
    }/**/
    
  }
  STACKTRC_LEAVE;
}


/**Returns the position of one of the chars in sChars within the part, started inside the part with fromIndex,*/
int32 indexOfAnyChar_Siiccc_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 fromWhere, int32 maxToTest, char transcriptChar, char quotationStartChar, char quotationEndChar, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyChar_Siiccc_StringPartJc");
  
  { 
    int32 pos; 
    int32 max; 
    bool bNotFound = true; 
    
    
    pos = thiz->begin + fromWhere;
    max = (thiz->end - pos) < maxToTest ? thiz->end : thiz->begin + maxToTest;
    bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        char cc; 
        
        
        cc = charAt_CharSequenceJc(REFJc(thiz->content), pos, _thCxt);
        if(cc == quotationStartChar && cc != 0) 
        { 
          int32 endQuotion; 
          
          
          endQuotion = indexEndOfQuotation_StringPartJc(thiz, quotationEndChar, transcriptChar, pos - thiz->begin, max - thiz->begin, _thCxt);
          if(endQuotion < 0) 
          { 
            
            pos = max;
          }
          else 
          { 
            
            pos = endQuotion + thiz->begin;
          }
        }
        else if(cc == transcriptChar && cc != 0 && pos < (max - 1)) 
        { 
          
          pos += 2;
        }
        else 
        { 
          
          if(indexOf_C_StringJc(sChars, cc) >= 0) 
          { 
            
            bNotFound = false;
          }
          else 
          { 
            
            pos += 1;
          }
        }
      }
    if(bNotFound) 
    { 
      
      if(indexOf_C_StringJc(sChars, cEndOfText_StringPartJc) >= 0) { STACKTRC_LEAVE;
        return pos - thiz->begin;
      }/* it is found because cEndOfText is searched too.*/
      
      else { STACKTRC_LEAVE;
        return -1;
      }
    }
    else { STACKTRC_LEAVE;
      return (pos - thiz->begin);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the last position of one of the chars in sChars*/
int32 lastIndexOfAnyChar_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lastIndexOfAnyChar_StringPartJc");
  
  { 
    int32 pos; 
    int32 min; 
    int32 index; 
    
    
    pos = (thiz->end - thiz->begin) < maxToTest ? thiz->end - 1 : thiz->begin + maxToTest - 1;
    min = thiz->begin + fromWhere;
    
    while(pos >= min && indexOf_C_StringJc(sChars, charAt_CharSequenceJc(REFJc(thiz->content), pos, _thCxt)) < 0)
      { 
        
        pos -= 1;
      }
    index = pos >= min ? pos - thiz->begin : -1;
    { STACKTRC_LEAVE;
      return index;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of one of the chars in sChars within the part, started inside the part with fromIndex,*/
int32 indexOfAnyString_StringPartJc(StringPartJc_s* thiz, CharSequenceJc_Y* listStrings, int32 fromWhere, int32 maxToTest, int32_Y* nrofFoundString, StringJc_Y* foundString, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyString_StringPartJc");
  
  { 
    int32 pos; 
    int32 max; 
    StringBufferJc sFirstCharBuffer = { 0 };   /**/
    bool acceptToEndOfText = false; 
    StringJc sFirstChars;   /**/
    bool found = false; 
    int32 nChars = 0; 
    
    
    pos = thiz->begin + fromWhere;
    max = (thiz->end - pos) < maxToTest ? thiz->end : pos + maxToTest;
    ASSERT(/*static*/listStrings->head.length < 100);/*static size is need*/
    
    
    //J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(sFirstCharBuffer.base.object), sizeof(sFirstCharBuffer), 0); 
    ctorO_I_StringBufferJc(/*static*/&(sFirstCharBuffer.base.object), 100, _thCxt);
    acceptToEndOfText = false;
    /**Compose a String with all first chars, to test whether a current char of src is equal. */
    
    { 
      int32 ii = -1; 
      
      
      ii = -1;
      /**Compose a String with all first chars, to test whether a current char of src is equal. */
      
      while(++ii < listStrings->head.length)/**Compose a String with all first chars, to test whether a current char of src is equal. */
        
        { /*:String sString = (String)(iter.next());*/
          
          struct CharSequenceJc_t* sString; 
          
          
          sString = listStrings->data[ii];
          /**Compose a String with all first chars, to test whether a current char of src is equal. */
          if(charAt_CharSequenceJc(sString, 0, _thCxt) == cEndOfText_StringPartJc) /**Compose a String with all first chars, to test whether a current char of src is equal. */
          
          { 
            
            /**Compose a String with all first chars, to test whether a current char of src is equal. */
            acceptToEndOfText = true;
          }
          else /**Compose a String with all first chars, to test whether a current char of src is equal. */
          
          { 
            
            /**Compose a String with all first chars, to test whether a current char of src is equal. */
            append_C_StringBufferJc(& (sFirstCharBuffer), charAt_CharSequenceJc(sString, 0, _thCxt), _thCxt);
          }
        }
    }
    sFirstChars = toString_StringBufferJc(& ((sFirstCharBuffer).base.object), _thCxt)/*J2C:non-persistent*/;
    found = false;
    
    while(!found && pos < max)
      { 
        int32 nrofFoundString1 = -1; 
        
        
        nrofFoundString1 = -1;
        /**increment over not matching chars, test all first chars: */
        
        while(pos < max && (nrofFoundString1 = /*? assignment*/indexOf_C_StringJc(sFirstChars, charAt_CharSequenceJc(REFJc(thiz->content), pos, _thCxt))) < 0)/**increment over not matching chars, test all first chars: */
          pos += 1;
        if(pos < max) 
        { 
          int32 ii = -1;   /*a fist matching char is found! test wether or not the whole string is matched.*/
          
          
          ii = -1;
          
          while(!found && ++ii < listStrings->head.length)
            { /*:String sString = (String)(iter.next());*/
              
              struct CharSequenceJc_t* sString; 
              int32 testLen; 
              
              
              sString = listStrings->data[ii];
              testLen = length_CharSequenceJc(sString, _thCxt);
              if((max - pos) >= testLen && equals_CsiiCs_StringFunctionsJc(/*static*/REFJc(thiz->content), pos, pos + testLen, sString, _thCxt)) 
              { 
                
                found = true;
                if(foundString != null) 
                { 
                  
                  foundString->data[0] = toString_CharSequenceJc(& ((* (sString)).base.object)/*J2cT1*/)/*J2C:non-persistent*/;
                }
                if(nrofFoundString != null) 
                { 
                  
                  nrofFoundString->data[0] = ii;
                }
              }/*else { nrofFoundString1 +=1; }*/
              
            }
          if(!found) 
          { 
            
            pos += 1;
          }/*check from the next char because no string matches.*/
          
        }
      }
    /*no initvalue*/
    if(pos < max || (pos == max && acceptToEndOfText)) 
    { 
      
      nChars = pos - thiz->begin;
    }
    else 
    { 
      
      nChars = -1;
      if(foundString != null) 
      { 
        
        foundString->data[0] = null_StringJc/*J2C:non-persistent*/;
      }
      if(nrofFoundString != null) 
      { 
        
        nrofFoundString->data[0] = -1;
      }
    }
    { STACKTRC_LEAVE;
      return nChars;
    }
  }
  STACKTRC_LEAVE;
}


/**Searches any char contained in sChars in the current part*/
int32 indexOfAnyCharOutsideQuotion_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyCharOutsideQuotion_StringPartJc");
  
  { 
    int32 pos; 
    int32 max; 
    bool bNotFound = true; 
    
    
    pos = thiz->begin + fromWhere;
    max = (thiz->end - pos) < maxToTest ? thiz->end : thiz->begin + maxToTest;
    bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        char cc; 
        
        
        cc = charAt_CharSequenceJc(REFJc(thiz->content), pos, _thCxt);
        if(cc == '\"') 
        { 
          int32 endQuotion; 
          
          
          endQuotion = indexEndOfQuotion_StringPartJc(thiz, '\"', pos - thiz->begin, max - thiz->begin, _thCxt);
          if(endQuotion < 0) 
          { 
            
            pos = max;
          }
          else 
          { 
            
            pos = endQuotion + thiz->begin;
          }
        }
        else 
        { 
          
          if(indexOf_C_StringJc(sChars, cc) >= 0) 
          { 
            
            bNotFound = false;
          }
          else 
          { 
            
            pos += 1;
          }
        }
      }
    { STACKTRC_LEAVE;
      return (bNotFound) ? -1 : (pos - thiz->begin);
    }
  }
  STACKTRC_LEAVE;
}


/**Searches the end of a quoted string*/
int32 indexEndOfQuotion_StringPartJc(StringPartJc_s* thiz, char cEndQuotion, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexEndOfQuotion_StringPartJc");
  
  { 
    int32 pos; 
    int32 max; 
    bool bNotFound = true; 
    
    
    pos = thiz->begin + fromWhere + 1;
    max = (thiz->end - pos) < maxToTest ? thiz->end : pos + maxToTest;
    bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        char cc; 
        
        
        cc = charAt_CharSequenceJc(REFJc(thiz->content), pos++, _thCxt);
        if(cc == '\\' && (pos + 1) < max) 
        { 
          
          pos += 1;/*on \ overread the next char, test char after them!*/
          
        }
        else if(cc == cEndQuotion) 
        { 
          
          bNotFound = false;
        }
      }
    { STACKTRC_LEAVE;
      return (bNotFound ? -1 : (pos - thiz->begin));
    }
  }
  STACKTRC_LEAVE;
}


/**Searches the end of a quoted string*/
int32 indexEndOfQuotation_StringPartJc(StringPartJc_s* thiz, char cEndQuotion, char transcriptChar, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexEndOfQuotation_StringPartJc");
  
  { 
    int32 pos; 
    int32 max; 
    bool bNotFound = true; 
    
    
    pos = thiz->begin + fromWhere + 1;
    max = (thiz->end - pos) < maxToTest ? thiz->end : pos + maxToTest;
    bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        char cc; 
        
        
        cc = charAt_CharSequenceJc(REFJc(thiz->content), pos++, _thCxt);
        if(cc == transcriptChar && cc != 0 && (pos + 1) < max) 
        { 
          
          pos += 1;/*on \ overread the next char, test char after them!*/
          
        }
        else if(cc == cEndQuotion) 
        { 
          
          bNotFound = false;
        }
      }
    { STACKTRC_LEAVE;
      return (bNotFound ? -1 : (pos - thiz->begin));
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of one of the chars in sChars within the part,*/
int32 indexOfAnyChar_S_StringPartJc(StringPartJc_s* thiz, StringJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyChar_S_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return indexOfAnyChar_Sii_StringPartJc(thiz, sChars, 0, MAX_VALUE_IntegerJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the first char other than the chars in sChars within the part, started inside the part with fromIndex,*/
int32 indexOfNoChar_Si_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 fromWhere, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfNoChar_Si_StringPartJc");
  
  { 
    int32 pos; 
    
    
    pos = thiz->begin + fromWhere;
    
    while(pos < thiz->end && indexOf_C_StringJc(sChars, charAt_CharSequenceJc(REFJc(thiz->content), pos, _thCxt)) >= 0)pos += 1;
    { STACKTRC_LEAVE;
      return (pos >= thiz->end) ? -1 : (pos - thiz->begin);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the first char other than the chars in sChars within the part,*/
int32 indexOfNoChar_S_StringPartJc(StringPartJc_s* thiz, StringJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfNoChar_S_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return indexOfNoChar_Si_StringPartJc(thiz, sChars, 0, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any char content in sChars (terminate chars).*/
struct StringPartJc_t* lentoAnyChar_Si_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyChar_Si_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lentoAnyChar_Sii_StringPartJc(thiz, sChars, maxToTest, seekNormal_StringPartJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any char content in sChars (terminate chars).*/
struct StringPartJc_t* lentoAnyChar_Sii_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 maxToTest, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyChar_Sii_StringPartJc");
  
  { 
    int32 pos = 0; 
    
    
    thiz->endLast = thiz->end;
    /*no initvalue*/
    if((mode & mSeekBackward__StringPartJc) != 0) 
    { 
      
      pos = lastIndexOfAnyChar_StringPartJc(thiz, sChars, 0, maxToTest, _thCxt);
    }
    else 
    { 
      
      pos = indexOfAnyChar_Sii_StringPartJc(thiz, sChars, 0, maxToTest, _thCxt);
    }
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->end = thiz->begin + pos;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any terminate string given in sString.*/
struct StringPartJc_t* lentoAnyString_SYi_StringPartJc(StringPartJc_s* thiz, StringJc_Y* strings, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyString_SYi_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lentoAnyString_SYii_StringPartJc(thiz, strings, maxToTest, seekNormal_StringPartJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any terminate string given in sString.*/
struct StringPartJc_t* lentoAnyString_SYii_StringPartJc(StringPartJc_s* thiz, StringJc_Y* strings, int32 maxToTest, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyString_SYii_StringPartJc");
  
  { 
    struct foundString_Y { ObjectArrayJc head; StringJc data[1]; }foundString = NULL_StringJc;   /**/
    int32 pos; 
    
    
    thiz->endLast = thiz->end;
    
    (StringJc_Y*)ctorO_ObjectArrayJc(&foundString.head.object, 1, sizeof(StringJc),&reflection_StringJc, 0);
    pos = indexOfAnyString_StringPartJc(thiz, ((/*J2C:cast from StringJc*/CharSequenceJc*)(strings/*J2C-error testAndChangeAccess: X**/)), 0, maxToTest, null, (struct StringJc_Y_t*)(&( foundString)), _thCxt);
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      if((mode & seekEnd_StringPartJc) != 0) 
      { 
        
        pos += length_StringJc(foundString.data[0]);
      }
      thiz->end = thiz->begin + pos;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any terminate string given in sString.*/
void lentoAnyStringWithIndent_StringPartJc(StringPartJc_s* thiz, StringJc_Y* strings, StringJc sIndentChars, int32 maxToTest, struct StringBuilderJc_t* buffer, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyStringWithIndent_StringPartJc");
  
  { 
    int32 indentColumn; 
    int32 startLine; 
    bool bAlsoWhiteSpaces; 
    int32 pos; 
    
    
    thiz->endLast = thiz->end;/*String sRet; sRet = "";*/
    
    setLength_StringBuilderJc(buffer, 0, _thCxt);
    indentColumn = getCurrentColumn_StringPartJc(thiz, _thCxt);
    startLine = thiz->begin;
    bAlsoWhiteSpaces = (charAt_StringJc(sIndentChars, length_StringJc(sIndentChars) - 1) == ' ');
    pos = indexOfAnyString_StringPartJc(thiz, ((/*J2C:cast from StringJc*/CharSequenceJc*)(strings/*J2C-error testAndChangeAccess: X**/)), 0, maxToTest, null, null, _thCxt);
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      bool bFinish = false; 
      
      
      thiz->bFound = true;
      thiz->end = thiz->begin + pos;
      bFinish = false;
      
      while(!bFinish)
        { 
          
          pos = indexOf_Csci_StringFunctionsJc(/*static*/REFJc(thiz->content), '\n', startLine, _thCxt);
          if(pos < 0) pos = thiz->end;
          if(pos > thiz->end) 
          { /*:next newline after terminated string, that is the last line.*/
            
            
            pos = thiz->end;
            bFinish = true;
          }
          else 
          { 
            
            pos += 1;
          }/* '\n' including*/
          /*append the line to output string:*/
          
          append_s_StringBuilderJc(buffer, subSequence_CharSequenceJc(REFJc(thiz->content), startLine, pos, _thCxt), _thCxt);
          if(!bFinish) 
          { /*:skip over indent.*/
            
            int32 posIndent; 
            
            
            startLine = pos;
            posIndent = startLine + indentColumn;
            if(posIndent > thiz->end) posIndent = thiz->end;
            
            while(startLine < posIndent && indexOf_C_StringJc(sIndentChars, charAt_CharSequenceJc(REFJc(thiz->content), startLine, _thCxt)) >= 0)
              { 
                
                startLine += 1;
              }
            if(bAlsoWhiteSpaces) 
            { 
              
              
              while(indexOf_C_StringJc(zI_StringJc(" \t",2), charAt_CharSequenceJc(REFJc(thiz->content), startLine, _thCxt)) >= 0)
                { 
                  
                  startLine += 1;
                }
            }
          }
        }
    }
    { STACKTRC_LEAVE;
      return;
    }/*buffer.toString();*/
    
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any char content in sChars (terminate chars),*/
struct StringPartJc_t* lentoAnyCharOutsideQuotion_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyCharOutsideQuotion_StringPartJc");
  
  { 
    int32 pos; 
    
    
    thiz->endLast = thiz->end;
    pos = indexOfAnyCharOutsideQuotion_StringPartJc(thiz, sChars, 0, maxToTest, _thCxt);
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->end = thiz->begin + pos;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to the end of the quotion*/
struct StringPartJc_t* lentoQuotionEnd_StringPartJc(StringPartJc_s* thiz, char sEndQuotion, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoQuotionEnd_StringPartJc");
  
  { 
    int32 pos; 
    
    
    thiz->endLast = thiz->end;
    pos = indexEndOfQuotion_StringPartJc(thiz, sEndQuotion, 0, maxToTest, _thCxt);
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->end = thiz->begin + pos;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to the end of the current line.*/
struct StringPartJc_t* lentoLineEnd_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoLineEnd_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lentoAnyChar_S_StringPartJc(thiz, s0_StringJc("\n\r\f"), _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Increments the begin of the current part over maybe found whitespaces*/
struct StringPartJc_t* trimWhiteSpaces_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("trimWhiteSpaces_StringPartJc");
  
  { 
    
    seekNoWhitespace_StringPartJc(thiz, _thCxt);
    lenBacktoNoChar_StringPartJc(thiz, s0_StringJc(" \t\r\n\f"), _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any char content in sChars (terminate chars).*/
struct StringPartJc_t* lentoAnyChar_S_StringPartJc(StringPartJc_s* thiz, StringJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyChar_S_StringPartJc");
  
  { 
    
    lentoAnyChar_Si_StringPartJc(thiz, sChars, MAX_VALUE_IntegerJc, _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length to the end of the maximal part if the length is 0*/
struct StringPartJc_t* len0end_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("len0end_StringPartJc");
  
  { 
    
    if(thiz->end <= thiz->begin) thiz->end = thiz->endMax;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length to the end of the maximal part.*/
struct StringPartJc_t* setLengthMax_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setLengthMax_StringPartJc");
  
  { 
    
    thiz->end = thiz->endMax;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Posits the end of the part before all of the chars given in the parameter string.*/
struct StringPartJc_t* lenBacktoNoChar_StringPartJc(StringPartJc_s* thiz, StringJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lenBacktoNoChar_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    
    while(thiz->end > thiz->begin && indexOf_C_StringJc(sChars, charAt_CharSequenceJc(REFJc(thiz->content), thiz->end - 1, _thCxt)) >= 0)
      { 
        
        thiz->end = thiz->end - 1;
      }
    if(thiz->end <= thiz->begin) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;/*all chars skipped to left.*/
      
    }
    else thiz->bFound = true;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Trims all leading and trailing whitespaces within the part.*/
struct StringPartJc_t* trim_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("trim_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return 
      ( seekNoChar_StringPartJc(thiz, s0_StringJc(" \t\n\r"), _thCxt)
      , lenBacktoNoChar_StringPartJc(thiz, s0_StringJc(" \t\n\r"), _thCxt)
      );
    }/*end position decreased*/
    
  }
  STACKTRC_LEAVE;
}


/**Trims a java- or C-style line-comment from end of part and all leading and trailing whitespaces.*/
struct StringPartJc_t* trimComment_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("trimComment_StringPartJc");
  
  { 
    int32 posComment; 
    
    
    thiz->beginLast = thiz->begin;
    thiz->endLast = thiz->end;
    posComment = indexOf_S_StringPartJc(thiz, s0_StringJc("//"), _thCxt);
    if(posComment >= 0) thiz->end = thiz->begin + posComment;
    thiz->bFound = (thiz->begin > thiz->beginLast);
    { STACKTRC_LEAVE;
      return trim_StringPartJc(thiz, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 compareTo_StringPartJc(StringPartJc_s* thiz, struct CharSequenceJc_t* str2, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("compareTo_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return compare_CsiCsii_StringFunctionsJc(/*static*/& ((* (thiz)).base.CharSequenceJc), 0, str2, 0, MAX_VALUE_IntegerJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the char within the part,*/
int32 indexOf_c_StringPartJc(StringPartJc_s* thiz, char ch, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_c_StringPartJc");
  
  { 
    int32 pos; 
    
    
    pos = indexOf_Csiic_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin, thiz->end, ch, _thCxt);
    
    ;
    if(pos < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else { STACKTRC_LEAVE;
      return pos - thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the char within the part, started inside the part with fromIndex,*/
int32 indexOf_ci_StringPartJc(StringPartJc_s* thiz, char ch, int32 fromIndex, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_ci_StringPartJc");
  
  { 
    
    if(fromIndex >= (thiz->end - thiz->begin) || fromIndex < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else 
    { 
      int32 pos; 
      
      
      pos = indexOf_Csiic_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin + fromIndex, thiz->end, ch, _thCxt);
      
      ;
      if(pos < 0) { STACKTRC_LEAVE;
        return -1;
      }
      else { STACKTRC_LEAVE;
        return pos - thiz->begin + fromIndex;
      }
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the string within the part*/
int32 indexOf_S_StringPartJc(StringPartJc_s* thiz, StringJc sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_S_StringPartJc");
  
  { 
    int32 pos; 
    
    
    pos = indexOf_CsiiS_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin, thiz->end, sCmp, _thCxt);
    if(pos < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else { STACKTRC_LEAVE;
      return pos - thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the string within the part*/
int32 indexOf_Cs_StringPartJc(StringPartJc_s* thiz, struct CharSequenceJc_t* sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_Cs_StringPartJc");
  
  { 
    int32 pos; 
    
    
    pos = indexOf_CsiiCs_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin, thiz->end, sCmp, _thCxt);
    if(pos < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else { STACKTRC_LEAVE;
      return pos - thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the string within the part*/
int32 indexOf_Csii_StringPartJc(StringPartJc_s* thiz, struct CharSequenceJc_t* sCmp, int32 fromIndex, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_Csii_StringPartJc");
  
  { 
    int32 max; 
    
    
    max = (thiz->end - thiz->begin) < maxToTest ? thiz->end : thiz->begin + maxToTest;
    if(fromIndex >= (max - thiz->begin) || fromIndex < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else 
    { 
      int32 pos; 
      
      
      pos = indexOf_CsiiCs_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin + fromIndex, max, sCmp, _thCxt);
      if(pos < 0) { STACKTRC_LEAVE;
        return -1;
      }
      else { STACKTRC_LEAVE;
        return pos - thiz->begin + fromIndex;
      }
    }
  }
  STACKTRC_LEAVE;
}


/**Compares the Part of string with the given string*/
bool equals_Cs_StringPartJc(StringPartJc_s* thiz, struct CharSequenceJc_t* sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("equals_Cs_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return equals_CsiiCs_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin, thiz->end, sCmp, _thCxt);
    }/*content.substring(start, end).equals(sCmp);*/
    
  }
  STACKTRC_LEAVE;
}


/**compares the Part of string with the given string.*/
bool startsWith_StringPartJc(StringPartJc_s* thiz, struct CharSequenceJc_t* sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("startsWith_StringPartJc");
  
  { 
    int32 pos_cEndOfText; 
    
    
    pos_cEndOfText = indexOf_Csci_StringFunctionsJc(/*static*/sCmp, cEndOfText_StringPartJc, 0, _thCxt);
    if(pos_cEndOfText >= 0) 
    { 
      
      if(pos_cEndOfText == 0) 
      { 
        
        { STACKTRC_LEAVE;
          return thiz->begin == thiz->end;
        }
      }
      else 
      { 
        
        { STACKTRC_LEAVE;
          return equals_CsiiCs_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin, thiz->end, sCmp, _thCxt);
        }/*content.substring(start, end).equals(sCmp);*/
        
      }
    }
    else 
    { 
      
      { STACKTRC_LEAVE;
        return startsWith_CsiiCs_StringFunctionsJc(/*static*/REFJc(thiz->content), thiz->begin, thiz->end, sCmp, _thCxt);
      }/*content.substring(start, end).startsWith(sCmp);*/
      
    }
  }
  STACKTRC_LEAVE;
}


/**This routine provides the this-pointer as StringPartScan in a concatenation of StringPartBase-invocations.*/
struct StringPartScanJc_t* scan_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scan_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return (StringPartScanJc)thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Gets the current position, useable for rewind*/
int64 getCurrentPosition_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentPosition_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the current position at a fix position inside the maxPart.*/
void setCurrentPosition_StringPartJc(StringPartJc_s* thiz, int64 pos, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setCurrentPosition_StringPartJc");
  
  { 
    
    thiz->begin = (int32)pos;
  }
  STACKTRC_LEAVE;
}


/**Gets a substring inside the maximal part*/
struct Part_StringPartJc_t* substring_StringPartJc(StringPartJc_s* thiz, int32 pos, int32 posendP, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("substring_StringPartJc");
  
  { 
    int32 posend = 0; 
    
    ObjectJc *newObj1_1=null; /*J2C: temporary Objects for new operations
    */
    /*no initvalue*/
    if(posendP <= 0) 
    { 
      
      posend = thiz->endMax - posendP;/*if posendP is fault, an exception is thrown.*/
      
    }
    else 
    { 
      
      posend = posendP;
    }
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), pos + thiz->begiMin, posend, _thCxt), _thCxt);
      return ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), pos + thiz->begiMin, posend, _thCxt);
    }/*content.substring(pos+begiMin, posend);*/
    
    activateGC_ObjectJc(newObj1_1, null, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Gets the next chars from current Position.*/
struct CharSequenceJc_t* getCurrent_StringPartJc(StringPartJc_s* thiz, int32 nChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrent_StringPartJc");
  
  { 
    int32 nChars1; 
    
    ObjectJc *newObj1_1=null; /*J2C: temporary Objects for new operations
    */
    nChars1 = (length_CharSequenceJc(REFJc(thiz->content), _thCxt) - thiz->begin) < nChars ? length_CharSequenceJc(REFJc(thiz->content), _thCxt) - thiz->begin : nChars;
    if(nChars1 == 0) { STACKTRC_LEAVE;
      return ((/*J2C:cast from char const**/CharSequenceJc*)(""/*J2C-error testAndChangeAccess: t**/));
    }
    else { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, (ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin, thiz->begin + nChars1, _thCxt)), _thCxt);
      return & ((* ((ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin, thiz->begin + nChars1, _thCxt)))).base.CharSequenceJc);
    }
  }
  STACKTRC_LEAVE;
}


/**Gets the next char at current Position.*/
char getCurrentChar_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentChar_StringPartJc");
  
  { 
    
    if(thiz->begin < length_CharSequenceJc(REFJc(thiz->content), _thCxt)) 
    { 
      
      { STACKTRC_LEAVE;
        return charAt_CharSequenceJc(REFJc(thiz->content), thiz->begin, _thCxt);
      }
    }
    else { STACKTRC_LEAVE;
      return '\0';
    }/*/**@java2c=StringBuilderInThreadCxt.*/ throw new IndexOutOfBoundsException("end of StringPartBase:" + begin); // return cEndOfText;*/
    
  }
  STACKTRC_LEAVE;
}


/**get the Line ct*/
int32 XXXgetLineCt_StringPartJc_F(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("XXXgetLineCt_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 XXXgetLineCt_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_StringPartJc);
  return mtbl->XXXgetLineCt(thiz, _thCxt);
}


/**Get the Line number and the column of the begin position.*/
int32 getLineAndColumn_StringPartJc_F(StringPartJc_s* thiz, int32_Y* column, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLineAndColumn_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 getLineAndColumn_StringPartJc(StringPartJc_s* thiz, int32_Y* column, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getLineAndColumn(thiz, column, _thCxt);
}


/**Gets the current position in line (column of the text).*/
int32 getCurrentColumn_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentColumn_StringPartJc");
  
  { /*:if((bitMode & mGetColumn_mode)==0){ return -1; }*/
    /*:else {*/
    
    int32 pos; 
    
    
    pos = lastIndexOf_Csiic_StringFunctionsJc(/*static*/REFJc(thiz->content), 0, thiz->begin, '\n', _thCxt);
    if(pos < 0) { STACKTRC_LEAVE;
      return thiz->begin;
    }/*first line, no \n before*/
    
    else { STACKTRC_LEAVE;
      return thiz->begin - pos - 1;
    }/*}*/
    
  }
  STACKTRC_LEAVE;
}


/**This method may be overridden to return the file which is used to build this Stringpart.*/
StringJc getInputfile_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInputfile_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->sFile;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the actual part of the string.*/
struct Part_StringPartJc_t* getCurrentPart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentPart_StringPartJc");
  
  { 
    ObjectJc *newObj1_1=null, *newObj1_2=null; /*J2C: temporary Objects for new operations
    */
    if(thiz->end > thiz->begin) { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin, thiz->end, _thCxt), _thCxt);
      return ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin, thiz->end, _thCxt);
    }
    else { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, ctorO_Part_StringPartJc(thiz, (newObj1_2 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin, thiz->begin, _thCxt), _thCxt);
      activateGC_ObjectJc(newObj1_2, ctorO_Part_StringPartJc(thiz, (newObj1_2 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin, thiz->begin, _thCxt), _thCxt);
      return ctorO_Part_StringPartJc(thiz, (newObj1_2 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin, thiz->begin, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the last part of the string before any seek or scan operation.*/
struct CharSequenceJc_t* getLastPart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLastPart_StringPartJc");
  
  { 
    ObjectJc *newObj1_1=null; /*J2C: temporary Objects for new operations
    */
    if(thiz->begin > thiz->beginLast) { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->beginLast, thiz->begin, _thCxt), _thCxt);
      return & ((* (ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->beginLast, thiz->begin, _thCxt))).base.CharSequenceJc);
    }
    else { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, null, _thCxt);
      return ((/*J2C:cast from char const**/CharSequenceJc*)(""/*J2C-error testAndChangeAccess: t**/));
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the actual part of the string.*/
struct CharSequenceJc_t* getCurrentPart_i_StringPartJc(StringPartJc_s* thiz, int32 maxLength, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentPart_i_StringPartJc");
  
  { 
    int32 max; 
    
    ObjectJc *newObj1_1=null; /*J2C: temporary Objects for new operations
    */
    max = (thiz->end - thiz->begin) < maxLength ? thiz->end : thiz->begin + maxLength;
    if(thiz->end > thiz->begin) { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin, max, _thCxt), _thCxt);
      return & ((* (ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin, max, _thCxt))).base.CharSequenceJc);
    }
    else { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, null, _thCxt);
      return ((/*J2C:cast from char const**/CharSequenceJc*)(""/*J2C-error testAndChangeAccess: t**/));
    }
  }
  STACKTRC_LEAVE;
}


/**Retrurn the part from start to end independent of the current positions.*/
struct Part_StringPartJc_t* getPart_StringPartJc(StringPartJc_s* thiz, int32 fromPos, int32 nrofChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getPart_StringPartJc");
  
  { 
    ObjectJc *newObj1_1=null; /*J2C: temporary Objects for new operations
    */
    if((fromPos + nrofChars) > length_CharSequenceJc(REFJc(thiz->content), _thCxt)) 
    { 
      
      nrofChars = length_CharSequenceJc(REFJc(thiz->content), _thCxt) - fromPos;
    }
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), fromPos, fromPos + nrofChars, _thCxt), _thCxt);
      return ctorO_Part_StringPartJc(thiz, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), fromPos, fromPos + nrofChars, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

char absCharAt_StringPartJc(StringPartJc_s* thiz, int32 index, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("absCharAt_StringPartJc");
  
  { 
    int32 pos; 
    
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    pos = index;
    if(pos >= 0 && pos < length_CharSequenceJc(REFJc(thiz->content), _thCxt)) { STACKTRC_LEAVE;
      return charAt_CharSequenceJc(REFJc(thiz->content), pos, _thCxt);
    }
    else { throw_sJc(ident_IllegalArgumentExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "StringPartBase.charAt - faulty; ", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, index, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}


/**Returns a String from absolute range.*/
StringJc absSubString_StringPartJc(StringPartJc_s* thiz, int32 from, int32 to, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("absSubString_StringPartJc");
  
  { 
    int32 pos; 
    int32 len; 
    int32 end1; 
    
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    pos = from;
    len = to - from;
    end1 = pos + len;
    if(REFJc(thiz->content) == null) 
    { 
      
      { STACKTRC_LEAVE;
        return s0_StringJc(" ??null?? ");
      }
    }
    if(pos >= 0 && end1 <= length_CharSequenceJc(REFJc(thiz->content), _thCxt)) 
    { 
      StringJc _temp2_1; /*J2C: temporary references for concatenation */
      
      { STACKTRC_LEAVE;
        return 
        ( _temp2_1= subSequence_CharSequenceJc(REFJc(thiz->content), pos, pos + len, _thCxt)
        , toString_StringJc(_temp2_1)
        );
      }
    }
    else { throw_sJc(ident_IllegalArgumentExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "StringPartBase.subSequence - faulty; ", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, from, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return null_StringJc; };
  }
  STACKTRC_LEAVE;
}

StringJc toString_StringPartJc_F(ObjectJc* ithis, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("toString_StringPartJc_F");
  
  { 
    struct Part_StringPartJc_t* _temp1_1; /*J2C: temporary references for concatenation */
    
    { STACKTRC_LEAVE;
      return 
      ( _temp1_1= getCurrentPart_StringPartJc(thiz, _thCxt)
      , toString_Part_StringPartJc(& ((* (_temp1_1)).base.CharSequenceJc.base.object)/*J2cT1*/, _thCxt)
      );
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc toString_StringPartJc(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_ObjectJc const* mtbl = (Mtbl_ObjectJc const*)getMtbl_ObjectJc(ithis, sign_Mtbl_ObjectJc);
  return mtbl->toString(ithis, _thCxt);
}


/**Returns a debug information of the content of the StringPart*/
StringJc debugString_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("debugString_StringPartJc");
  
  { 
    int32 len; 
    StringJc ret;   /**/
    
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    len = length_CharSequenceJc(REFJc(thiz->content), _thCxt);
    ret = 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_s_StringBuilderJc(_stringBuilderThCxt, subSequence_CharSequenceJc(REFJc(thiz->content), 0, len > 20 ? 20 : len, _thCxt), _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "<<<", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->begin, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, ",", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->end, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, ">>>", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    if(thiz->begin < len) 
    { 
      
      /***/
      ret = 
        ( append_s_StringBuilderJc(_stringBuilderThCxt, subSequence_CharSequenceJc(REFJc(thiz->content), thiz->begin, len > (thiz->begin + 20) ? thiz->begin + 20 : len, _thCxt), _thCxt)
        , toStringNonPersist_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
    }
    /***/
    ret = 
      ( append_z_StringBuilderJc(_stringBuilderThCxt, "<<<", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    { STACKTRC_LEAVE;
      return ret;
    }/*java2c: buffer in threadContext*/
    
  }
  STACKTRC_LEAVE;
}


/**Central mehtod to invoke excpetion, usefull to set a breakpoint in debug*/
void throwIndexOutOfBoundsException_StringPartJc(StringPartJc_s* thiz, StringJc sMsg, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("throwIndexOutOfBoundsException_StringPartJc");
  
  { 
    
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, sMsg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
  }
  STACKTRC_LEAVE;
}


/**Closes the work*/
void close_StringPartJc_F(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("close_StringPartJc_F");
  
  { 
    
    CLEAR_REFJc(thiz->content);
    thiz->begiMin = thiz->beginLast = /*? assignment*/thiz->begin = /*? assignment*/0;
    thiz->endMax = thiz->end = /*? assignment*/thiz->endLast = /*? assignment*/0;
    thiz->bCurrentOk = thiz->bFound = /*? assignment*/false;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void close_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_StringPartJc);
  mtbl->close(thiz, _thCxt);
}


/**Replaces up to 20 placeholder with a given content.*/
StringJc replace_StringPartJc(/*static*/ struct CharSequenceJc_t* src, CharSequenceJc_Y* placeholder, StringJc_Y* value, struct StringBuilderJc_t* dst, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("replace_StringPartJc");
  
  { 
    int32 len; 
    int32 ixPos = 0; 
    int32 nrofToken; 
    struct StringPartJc_t* spPattern = null; 
    int32 posPatternStart = 0; 
    int32 posPattern = 0; 
    
    ObjectJc *newObj1_1=null; /*J2C: temporary Objects for new operations
    */
    len = length_CharSequenceJc(src, _thCxt);
    ixPos = 0;
    nrofToken = placeholder->head.length;
    if(nrofToken != value->head.length) { throw_s0Jc(ident_IllegalArgumentExceptionJc, "token and value should have same size, lesser 20", 0, &_thCxt->stacktraceThreadContext, __LINE__); return null_StringJc; };
    if(dst == null) 
    { 
      ObjectJc *newObj2_1=null; /*J2C: temporary Objects for new operations
      */
      dst = ctorO_I_StringBuilderJc(/*static*/(newObj2_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), len + 100, _thCxt);
      activateGC_ObjectJc(newObj2_1, null, _thCxt);
    }/*calculate about 53 chars for identifier*/
    
    
    spPattern = ctorO_Cs_StringPartJc(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_StringPartJc_s, 0, _thCxt)), src, _thCxt);
    posPatternStart = 0;
    /*no initvalue*/
    do 
      { 
        int32_Y* type; 
        
        ObjectJc *newObj2_1=null; /*J2C: temporary Objects for new operations
        */
        
        type = (int32_Y*)ctorO_ObjectArrayJc((newObj2_1 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (1) * sizeof(int32), mIsLargeSize_objectIdentSize_ObjectJc, _thCxt)), 1, sizeof(int32),REFLECTION_int32, 0);
        posPattern = indexOfAnyString_StringPartJc(spPattern, placeholder, posPatternStart, length_StringPartJc(spPattern, _thCxt), type, null, _thCxt);
        if(posPattern >= 0) 
        { 
          int32 ixValue; 
          
          
          append_s_StringBuilderJc(dst, subSequence_CharSequenceJc(src, posPatternStart, posPattern, _thCxt), _thCxt);
          ixValue = type->data[0];
          append_s_StringBuilderJc(dst, value->data[ixValue], _thCxt);
          posPatternStart = posPattern + length_CharSequenceJc(placeholder->data[ixValue], _thCxt);
        }
        else 
        { /*:last pattern constant part:*/
          
          
          append_s_StringBuilderJc(dst, subSequence_CharSequenceJc(src, posPatternStart, len, _thCxt), _thCxt);
          posPatternStart = -1;/*mark end*/
          
        }
        activateGC_ObjectJc(newObj2_1, null, _thCxt);
      }while(posPatternStart >= 0);
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, PTR_StringJc(toString_StringBuilderJc(& ((* (dst)).base.object)/*J2cT1*/, _thCxt)), _thCxt);
      return toString_StringBuilderJc(& ((* (dst)).base.object)/*J2cT1*/, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


void finalize_StringPartJc_F(ObjectJc* othis, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)othis;  //upcasting to the real class.
 STACKTRC_TENTRY("finalize_StringPartJc_F");
  CLEAR_REFJc(thiz->content);
  finalize_ObjectJc_F(&thiz->base.object, _thCxt); //J2C: finalizing the superclass.
  STACKTRC_LEAVE;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_StringPartJc mtblStringPartJc = {
{ { sign_Mtbl_StringPartJc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((7 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, setParttoMax_StringPartJc_F //setParttoMax
, line_StringPartJc_F //line
, seek_S_StringPartJc_F //seek_S
, seekEnd_StringPartJc_F //seekEnd
, XXXgetLineCt_StringPartJc_F //XXXgetLineCt
, getLineAndColumn_StringPartJc_F //getLineAndColumn
, close_StringPartJc_F //close
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_StringPartJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_StringPartJc_F //toString
  }
  /**J2C: Mtbl-interfaces of StringPartJc: */
, { { sign_Mtbl_CharSequenceJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_StringPartJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_StringPartJc_F //toString
    }
  }
, { { sign_Mtbl_ComparableJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  }
, { { sign_Mtbl_CloseableJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern_C struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_StringPartJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_StringPartJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_StringPartJc, ObjectJc) }
   }
 };

 extern_C struct ClassJc_t const reflection_CharSequenceJc;
 extern_C struct ClassJc_t const reflection_ComparableJc;
 extern_C struct ClassJc_t const reflection_CloseableJc;
 static struct ifcClasses_StringPartJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[3];
 }interfaces_StringPartJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_CharSequenceJc, OFFSET_Mtbl(Mtbl_StringPartJc, CharSequenceJc) }
  , {&reflection_ComparableJc, OFFSET_Mtbl(Mtbl_StringPartJc, ComparableJc) }
  , {&reflection_CloseableJc, OFFSET_Mtbl(Mtbl_StringPartJc, CloseableJc) }
  }
};

extern_C struct ClassJc_t const reflection_StringPartJc_s;
extern_C struct ClassJc_t const reflection_CharSequenceJc;
extern_C struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_StringPartJc_s_t
{ ObjectArrayJc head; FieldJc data[20];
} reflection_Fields_StringPartJc_s =
{ CONST_ObjectArrayJc(FieldJc, 20, OBJTYPE_FieldJc, null, &reflection_Fields_StringPartJc_s)
, {
     { "begin"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->begin) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "end"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->end) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "begiMin"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->begiMin) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "endMax"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->endMax) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "content"
    , 0 //nrofArrayElements
    , &reflection_CharSequenceJc
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->content) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "bCurrentOk"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->bCurrentOk) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "bStartScan"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->bStartScan) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "beginLast"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->beginLast) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "endLast"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->endLast) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "bFound"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->bFound) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "bitMode"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->bitMode) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sFile"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->sFile) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sCommentStart"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->sCommentStart) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sCommentEnd"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->sCommentEnd) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sCommentToEol"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->sCommentToEol) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sVersion"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&sVersion_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&sVersion_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
   , { "seekToLeft"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&seekToLeft_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&seekToLeft_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
   , { "seekBack"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&seekBack_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&seekBack_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
   , { "cStartOfText"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&cStartOfText_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&cStartOfText_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
   , { "cEndOfText"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&cEndOfText_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&cEndOfText_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
} };
const ClassJc reflection_StringPartJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "StringPartJc_s"
, (int16)((int32)(&((StringPartJc_s*)(0x1000))->base.object) - (int32)(StringPartJc_s*)0x1000)
, sizeof(StringPartJc_s)
, (FieldJcArray const*)&reflection_Fields_StringPartJc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_StringPartJc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_StringPartJc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblStringPartJc.mtbl.head
};

/**This class presents a part of the parent CharSequence of this class.
The constructor is protected because instances of this class are only created in this class
or its derived, not by user.
The CharSequence methods get the characters from the parent CharSequence of the environment class
StringPartBase.
*/


const char sign_Mtbl_Part_StringPartJc[] = "Part_StringPartJc"; //to mark method tables of all implementations

typedef struct MtblDef_Part_StringPartJc_t { Mtbl_Part_StringPartJc mtbl; MtblHeadJc end; } MtblDef_Part_StringPartJc;
 extern MtblDef_Part_StringPartJc const mtblPart_StringPartJc;

/*Constructor */
struct Part_StringPartJc_t* ctorO_Part_StringPartJc(struct StringPartJc_t* outer, ObjectJc* othis, int32 from, int32 to, ThCxt* _thCxt)
{ Part_StringPartJc_s* thiz = (Part_StringPartJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_Part_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(Part_StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_Part_StringPartJc_s, sizeof(Part_StringPartJc_s));  
  thiz->outer = outer;
  //j2c: Initialize all class variables:
  {
  }
  { 
    
    ASSERT(/*static*/from >= 0 && from <= length_CharSequenceJc(REFJc(thiz->outer->content), _thCxt));
    ASSERT(/*static*/to >= 0 && to <= length_CharSequenceJc(REFJc(thiz->outer->content), _thCxt));
    ASSERT(/*static*/from <= to);
    thiz->b1 = from;
    thiz->e1 = to;
  }
  STACKTRC_LEAVE;
  return thiz;
}


char charAt_Part_StringPartJc(Part_StringPartJc_s* thiz, int32 index, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("charAt_Part_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return absCharAt_StringPartJc((thiz)->outer, thiz->b1 + index, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 length_Part_StringPartJc(Part_StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("length_Part_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->e1 - thiz->b1;
    }
  }
  STACKTRC_LEAVE;
}

struct CharSequenceJc_t* subSequence_Part_StringPartJc(Part_StringPartJc_s* thiz, int32 from, int32 end, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("subSequence_Part_StringPartJc");
  
  { 
    ObjectJc *newObj1_1=null; /*J2C: temporary Objects for new operations
    */
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, ctorO_Part_StringPartJc((thiz)->outer, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->b1 + from, thiz->b1 + thiz->outer->end, _thCxt), _thCxt);
      return & ((* (ctorO_Part_StringPartJc((thiz)->outer, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->b1 + from, thiz->b1 + thiz->outer->end, _thCxt))).base.CharSequenceJc);
    }
  }
  STACKTRC_LEAVE;
}

StringJc toString_Part_StringPartJc(ObjectJc* ithis, ThCxt* _thCxt)
{ Part_StringPartJc_s* thiz = (Part_StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("toString_Part_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return absSubString_StringPartJc((thiz)->outer, thiz->b1, thiz->e1, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Builds a new Part without leading and trailing white spaces.*/
struct Part_StringPartJc_t* trim_Part_StringPartJc(Part_StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("trim_Part_StringPartJc");
  
  { 
    int32 b2; 
    int32 e2; 
    struct Part_StringPartJc_t* ret = null; 
    
    ObjectJc *newObj1_1=null; /*J2C: temporary Objects for new operations
    */
    b2 = thiz->b1;
    e2 = thiz->e1;
    
    while(b2 < e2 && indexOf_C_StringJc(zI_StringJc(" \r\n\t",4), charAt_CharSequenceJc(REFJc(thiz->outer->content), b2, _thCxt)) >= 0)
      { 
        
        b2 += 1;
      }
    
    while(e2 > b2 && indexOf_C_StringJc(zI_StringJc(" \r\n",3), charAt_CharSequenceJc(REFJc(thiz->outer->content), e2 - 1, _thCxt)) >= 0)
      { 
        
        e2 -= 1;
      }
    
    ret = ctorO_Part_StringPartJc((thiz)->outer, (newObj1_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), b2, e2, _thCxt);
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj1_1, ret, _thCxt);
      return ret;
    }
  }
  STACKTRC_LEAVE;
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_Part_StringPartJc mtblPart_StringPartJc = {
{ { sign_Mtbl_Part_StringPartJc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_Part_StringPartJc //toString
  }
  /**J2C: Mtbl-interfaces of Part_StringPartJc: */
, { { sign_Mtbl_CharSequenceJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_Part_StringPartJc //toString
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern_C struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_Part_StringPartJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_Part_StringPartJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_Part_StringPartJc, ObjectJc) }
   }
 };

 extern_C struct ClassJc_t const reflection_CharSequenceJc;
 static struct ifcClasses_Part_StringPartJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }interfaces_Part_StringPartJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_CharSequenceJc, OFFSET_Mtbl(Mtbl_Part_StringPartJc, CharSequenceJc) }
  }
};

extern_C struct ClassJc_t const reflection_Part_StringPartJc_s;
extern_C struct ClassJc_t const reflection_CharSequenceJc;
extern_C struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_Part_StringPartJc_s_t
{ ObjectArrayJc head; FieldJc data[2];
} reflection_Fields_Part_StringPartJc_s =
{ CONST_ObjectArrayJc(FieldJc, 2, OBJTYPE_FieldJc, null, &reflection_Fields_Part_StringPartJc_s)
, {
     { "b1"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Part_StringPartJc_s*)(0x1000))->b1) - (int32)(Part_StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Part_StringPartJc_s
    }
   , { "e1"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Part_StringPartJc_s*)(0x1000))->e1) - (int32)(Part_StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Part_StringPartJc_s
    }
} };
const ClassJc reflection_Part_StringPartJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "Part_StringPartJc_s"
, (int16)((int32)(&((Part_StringPartJc_s*)(0x1000))->base.object) - (int32)(Part_StringPartJc_s*)0x1000)
, sizeof(Part_StringPartJc_s)
, (FieldJcArray const*)&reflection_Fields_Part_StringPartJc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_Part_StringPartJc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_Part_StringPartJc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblPart_StringPartJc.mtbl.head
};
