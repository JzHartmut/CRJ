/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "J1c/StringPartJc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "J1c/StringFunctionsJc.h"  //reference-association: StringFunctionsJc_s
#include "Jc/SystemJc.h"  //reference-association: SystemJc


/* J2C: Forward declaration of struct ***********************************************/

/**This is an alternative to the {@link java.lang.String} which uses a shared reference to the char sequence.
This class is able to use if String processing is done in a closed thread. This class must not be used
instead java.lang.String if the String would referenced persistently and used from more as one thread.
String with this class are not immutable.
@author Hartmut Schorrig

*/


const char sign_Mtbl_StringPartJc[] = "StringPartJc"; //to mark method tables of all implementations

typedef struct MtblDef_StringPartJc_t { Mtbl_StringPartJc mtbl; MtblHeadJc end; } MtblDef_StringPartJc;
 extern MtblDef_StringPartJc const mtblStringPartJc;
StringJc sVersion_StringPartJc = CONST_z_StringJc("2014-01-12");
const int32 seekToLeft_StringPartJc = mSeekToLeft__StringPartJc + mSeekBackward__StringPartJc;
const int32 seekBack_StringPartJc = 0x20 + mSeekBackward__StringPartJc;
const char cStartOfText_StringPartJc = (char)(0x2);
const char cEndOfText_StringPartJc = (char)(0x3);

/*Constructor */
struct StringPartJc_t* ctorO_StringPartJc(ObjectJc* othis, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringPartJc_s, sizeof(StringPartJc_s));  
  //j2c: Initialize all class variables:
  {
    thiz->bCurrentOk = true;
    thiz->bStartScan = true;
    thiz->bFound = true;
    thiz->bitMode = 0;
    set_StringJc(&(thiz->sCommentStart), z_StringJc("/*"));
    set_StringJc(&(thiz->sCommentEnd), z_StringJc("*/"));
    set_StringJc(&(thiz->sCommentToEol), z_StringJc("//"));
  }
  { 
    
    thiz->content = null_StringJc /*J2C: mem assignment*/;
    thiz->begiMin = thiz->begin = /*? assignment*/thiz->beginLast = /*? assignment*/0;
    thiz->endLast = thiz->endMax = /*? assignment*/thiz->end = /*? assignment*/0;
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct StringPartJc_t* ctorO_Cs_StringPartJc(ObjectJc* othis, CharSeqJc src, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringPartJc_s, sizeof(StringPartJc_s));  
  //j2c: Initialize all class variables:
  {
    thiz->bCurrentOk = true;
    thiz->bStartScan = true;
    thiz->bFound = true;
    thiz->bitMode = 0;
    set_StringJc(&(thiz->sCommentStart), z_StringJc("/*"));
    set_StringJc(&(thiz->sCommentEnd), z_StringJc("*/"));
    set_StringJc(&(thiz->sCommentToEol), z_StringJc("//"));
  }
  { 
    
    ctorO_Csii_StringPartJc(othis, src, 0, length_CharSeqJc(src/*J1cT2*/, _thCxt), _thCxt);
  }
  STACKTRC_LEAVE;
  return thiz;
}



/*Constructor */
struct StringPartJc_t* ctorO_Csii_StringPartJc(ObjectJc* othis, CharSeqJc src, int32 start, int32 end, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringPartJc_s, sizeof(StringPartJc_s));  
  //j2c: Initialize all class variables:
  {
    thiz->bCurrentOk = true;
    thiz->bStartScan = true;
    thiz->bFound = true;
    thiz->bitMode = 0;
    set_StringJc(&(thiz->sCommentStart), z_StringJc("/*"));
    set_StringJc(&(thiz->sCommentEnd), z_StringJc("*/"));
    set_StringJc(&(thiz->sCommentToEol), z_StringJc("//"));
  }
  { 
    
    thiz->begiMin = thiz->begin = /*? assignment*/start;
    thiz->endMax = thiz->end = /*? assignment*/end;
    thiz->content = src;
    ASSERT(/*J2C:static method call*/end <= length_CharSeqJc(thiz->content/*J1cT2*/, _thCxt));
  }
  STACKTRC_LEAVE;
  return thiz;
}



/**Sets the input file for information {@link #getInputfile()}*/
void setInputfile_StringPartJc(StringPartJc_s* thiz, StringJc file, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInputfile_StringPartJc");
  
  { 
    
    set_StringJc(&(thiz->sFile), file);
  }
  STACKTRC_LEAVE;
}


/**Sets the content to the given string, forgets the old content*/
struct StringPartJc_t* assign_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc ref, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assign_Cs_StringPartJc");
  
  { 
    
    thiz->content = ref;
    setParttoMax_StringPartJc(thiz);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the content to the given string, forgets the old content.*/
struct StringPartJc_t* assignReplaceEnv_StringPartJc(StringPartJc_s* thiz, struct StringBuilderJc_t* input, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assignReplaceEnv_StringPartJc");
  
  { 
    
    
    int32  pos1 = 0;
    
    int32  zInput = length_StringBuilderJc(input);
    
    while((pos1 = /*? assignment*/indexOf_zI_StringBuilderJc(input, "$", pos1, _thCxt)) >= 0)
      { 
        
        
        int32  posident;/*no initvalue*/
        
        int32  posidentend;/*no initvalue*/
        
        int32  pos9;/*no initvalue*/
        if(charAt_StringBuilderJc(input, pos1 + 1, _thCxt) == '(') 
        { 
          
          posident = pos1 + 2;
          posidentend = indexOf_zI_StringBuilderJc(input, ")", posident, _thCxt);
          pos9 = posidentend + 1;/*after )*/
          
        }
        else 
        { 
          
          posident = pos1 + 1;
          posidentend = pos9 = /*? assignment*/posAfterIdentifier_Csii_StringFunctionsJc(/*J2C:static method call*/from_StringBuilder_CharSeqJc(input), posident, zInput, _thCxt);
        }
        
        StringJc  sEnv = getenv_SystemJc(/*J2C:static method call*/substring_StringBuilderJc(input, posident, posidentend, _thCxt), _thCxt)/*J2C:non-persistent*/;
        if(sEnv.ref== null) 
        { 
          
          sEnv = z_StringJc("")/*J2C:non-persistent*/;
        }
        replace_StringBuilderJc(input, pos1, pos9, sEnv, _thCxt);
        zInput = length_StringBuilderJc(input);
      }
    thiz->content = from_StringBuilder_CharSeqJc(input);
    thiz->begiMin = thiz->beginLast = /*? assignment*/thiz->begin = /*? assignment*/0;
    thiz->endMax = thiz->end = /*? assignment*/thiz->endLast = /*? assignment*/length_CharSeqJc(thiz->content/*J1cT2*/, _thCxt);
    thiz->bStartScan = thiz->bCurrentOk = /*? assignment*/true;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the StringPart with the same String object as the given StringPart, forgets the old content.*/
struct StringPartJc_t* assign_XX_StringPartJc(StringPartJc_s* thiz, struct StringPartJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assign_XX_StringPartJc");
  
  { 
    
    if(src == thiz) 
    { /*:set from the own instance: the maxPart is the actual one.*/
      
      
      thiz->begiMin = thiz->beginLast = /*? assignment*/thiz->begin;
      thiz->endMax = thiz->endLast = /*? assignment*/thiz->end;
    }
    else 
    { /*:set from a other instance, inherit the content.*/
      
      
      thiz->content = src->content;
      thiz->begiMin = thiz->beginLast = /*? assignment*/thiz->begin = /*? assignment*/src->begin;
      thiz->endMax = thiz->end = /*? assignment*/thiz->endLast = /*? assignment*/src->end;
      ASSERT(/*J2C:static method call*/thiz->endMax <= length_CharSeqJc(thiz->content/*J1cT2*/, _thCxt));
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the content of the StringPart , forgets the old content*/
struct StringPartJc_t* assignFromEnd_StringPartJc(StringPartJc_s* thiz, struct StringPartJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assignFromEnd_StringPartJc");
  
  { 
    
    thiz->content = src->content;
    thiz->beginLast = thiz->begin;
    thiz->begiMin = thiz->begin = /*? assignment*/src->end;/*from actual end*/
    
    thiz->endLast = thiz->endMax = /*? assignment*/thiz->end = /*? assignment*/src->endMax;/*from maximal end*/
    
    ASSERT(/*J2C:static method call*/thiz->endMax <= length_CharSeqJc(thiz->content/*J1cT2*/, _thCxt));
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the mode of ignoring comments.*/
bool setIgnoreComment_b_StringPartJc(StringPartJc_s* thiz, bool bSet, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreComment_b_StringPartJc");
  
  { 
    
    
    bool  bRet = (thiz->bitMode & mSkipOverCommentInsideText_mode_StringPartJc) != 0;
    if(bSet) thiz->bitMode |= mSkipOverCommentInsideText_mode_StringPartJc;
    else thiz->bitMode &= ~mSkipOverCommentInsideText_mode_StringPartJc;
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the character string of inline commentmode of ignoring comments.*/
bool setIgnoreComment_SS_StringPartJc(StringPartJc_s* thiz, StringJc sStart, StringJc sEnd, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreComment_SS_StringPartJc");
  
  { 
    
    
    bool  bRet = (thiz->bitMode & mSkipOverCommentInsideText_mode_StringPartJc) != 0;
    thiz->bitMode |= mSkipOverCommentInsideText_mode_StringPartJc;
    set_StringJc(&(thiz->sCommentStart), sStart);
    set_StringJc(&(thiz->sCommentEnd), sEnd);
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the mode of ignoring comments to end of line.*/
bool setIgnoreEndlineComment_b_StringPartJc(StringPartJc_s* thiz, bool bSet, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreEndlineComment_b_StringPartJc");
  
  { 
    
    
    bool  bRet = (thiz->bitMode & mSkipOverCommentToEol_mode_StringPartJc) != 0;
    if(bSet) thiz->bitMode |= mSkipOverCommentToEol_mode_StringPartJc;
    else thiz->bitMode &= ~mSkipOverCommentToEol_mode_StringPartJc;
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the character string introducing the comments to end of line.*/
bool setIgnoreEndlineComment_S_StringPartJc(StringPartJc_s* thiz, StringJc sStart, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreEndlineComment_S_StringPartJc");
  
  { 
    
    
    bool  bRet = (thiz->bitMode & mSkipOverCommentToEol_mode_StringPartJc) != 0;
    thiz->bitMode |= mSkipOverCommentToEol_mode_StringPartJc;
    set_StringJc(&(thiz->sCommentToEol), sStart);
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Set the mode of ignoring whitespaces.*/
bool setIgnoreWhitespaces_StringPartJc(StringPartJc_s* thiz, bool bSet, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreWhitespaces_StringPartJc");
  
  { 
    
    
    bool  bRet = (thiz->bitMode & mSkipOverWhitespace_mode_StringPartJc) != 0;
    if(bSet) thiz->bitMode |= mSkipOverWhitespace_mode_StringPartJc;
    else thiz->bitMode &= ~mSkipOverWhitespace_mode_StringPartJc;
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the start of the maximal part to the actual start of the valid part.*/
struct StringPartJc_t* setBeginMaxPart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setBeginMaxPart_StringPartJc");
  
  { 
    
    thiz->begiMin = thiz->begin;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the start of the part to the exclusively end, set the end to the end of the content.*/
struct StringPartJc_t* fromEnd_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("fromEnd_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    thiz->endLast = thiz->end;
    thiz->begin = thiz->end;
    thiz->end = thiz->endMax;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**This method returns the characters of the current part.*/
char charAt_i_StringPartJc(ObjectJc* ithis, int32 index, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("charAt_i_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return absCharAt_StringPartJc(thiz, thiz->begin + index, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns a volatile CharSequence from the range inside the current part.*/
CharSeqJc subSequence_ii_StringPartJc(ObjectJc* ithis, int32 from, int32 to, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("subSequence_ii_StringPartJc");
  
  { 
    
    if(from < 0 || to > (thiz->end - thiz->begin)) 
    { 
      
      throwSubSeqFaulty_StringPartJc(thiz, from, to, _thCxt);
      { STACKTRC_LEAVE;
        return null_StringJc /*J2C: mem assignment*/;
      }/*It is used for Java2C without throw mechanism.*/
      
    }
    
    struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), _thCxt), thiz->begin + from, thiz->begin + to, _thCxt);
    { STACKTRC_LEAVE;
      return fromObjectJc_CharSeqJc(&(* (ret)).base.object);
    }
  }
  STACKTRC_LEAVE;
}

void throwSubSeqFaulty_StringPartJc(StringPartJc_s* thiz, int32 from, int32 to, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("throwSubSeqFaulty_StringPartJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    { throw_sJc(ident_IllegalArgumentExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "StringPartBase.subString - faulty;", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, from, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
  }
  STACKTRC_LEAVE;
}

int32 length_StringPartJc(ObjectJc* ithis, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("length_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->end - thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the lenght of the maximal part from current position*/
int32 lengthMaxPart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lengthMaxPart_StringPartJc");
  
  { 
    
    if(thiz->endMax > thiz->begin) { STACKTRC_LEAVE;
      return thiz->endMax - thiz->begin;
    }
    else { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the endposition of the part of string to the given chars after start.*/
struct StringPartJc_t* lento_i_StringPartJc(StringPartJc_s* thiz, int32 len, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lento_i_StringPartJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    thiz->endLast = thiz->end;
    
    int32  endNew = thiz->begin + len;
    if(endNew < thiz->begin) /***/
    throwIndexOutOfBoundsException_StringPartJc(thiz, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "lento(int) negative:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, (endNew - thiz->begin), _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), _thCxt);
    if(endNew > thiz->endMax) /***/
    throwIndexOutOfBoundsException_StringPartJc(thiz, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "lento(int) after endMax:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, (endNew - thiz->endMax), _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), _thCxt);
    thiz->end = endNew;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the end position of the part of string to exclusively the char cc.*/
struct StringPartJc_t* lento_c_StringPartJc(StringPartJc_s* thiz, char cc, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lento_c_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    thiz->end = thiz->begin - 1;
    
    while(++thiz->end < thiz->endLast)
      { 
        
        if(charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->end, _thCxt) == cc) 
        { 
          
          thiz->bFound = true;
          { STACKTRC_LEAVE;
          return thiz;
        }
        }
      }
    thiz->end = thiz->begin;/*not found*/
    
    thiz->bFound = false;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the endposition of the part of string to exclusively the given string.*/
struct StringPartJc_t* lento_S_StringPartJc(StringPartJc_s* thiz, StringJc ss, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lento_S_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lento_Csi_StringPartJc(thiz, ss, seekNormal_StringPartJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the endposition of the part of string to exclusively the given string.*/
struct StringPartJc_t* lento_Csi_StringPartJc(StringPartJc_s* thiz, CharSeqJc ss, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lento_Csi_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    
    int32  pos = indexOf_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, ss, _thCxt);
    thiz->bFound = (pos >= 0);
    if(pos >= 0) 
    { 
      
      thiz->end = pos;
      if((mode & seekEnd_StringPartJc) != 0) 
      { 
        
        thiz->end += length_CharSeqJc(ss/*J1cT2*/, _thCxt);
      }
    }
    else 
    { 
      
      thiz->end = thiz->begin;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the endposition of the part of string to the end of the identifier which is beginning on start.*/
struct StringPartJc_t* lentoIdentifier_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoIdentifier_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lentoIdentifier_SS_StringPartJc(thiz, null_StringJc /*J2C: mem assignment*/, null_StringJc /*J2C: mem assignment*/, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the endposition of the part of string to the end of the identifier which is beginning on start.*/
struct StringPartJc_t* lentoIdentifier_SS_StringPartJc(StringPartJc_s* thiz, StringJc additionalStartChars, StringJc additionalChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoIdentifier_SS_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    thiz->end = thiz->begin;
    if(thiz->end >= thiz->endMax) 
    { 
      
      thiz->bFound = false;
    }
    else 
    { /*:TODO use StringFunctions.lenIdentifier*/
      
      
      
      char  cc = charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->end, _thCxt);
      if(cc == '_' || (cc >= 'A' && cc <= 'Z') || (cc >= 'a' && cc <= 'z') || (additionalStartChars.ref!= null && indexOf_C_StringJc(additionalStartChars, cc) >= 0)) 
      { 
        
        thiz->end += 1;
        
        while(thiz->end < thiz->endMax && ((cc = /*? assignment*/charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->end, _thCxt)) == '_' || (cc >= '0' && cc <= '9') || (cc >= 'A' && cc <= 'Z') || (cc >= 'a' && cc <= 'z') || (additionalChars.ref!= null && indexOf_C_StringJc(additionalChars, cc) >= 0)))
          { 
            
            thiz->end += 1;
          }
      }
      thiz->bFound = (thiz->end > thiz->begin);
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the len to the first position of any given char, but not if the char is escaped.*/
struct StringPartJc_t* lentoAnyNonEscapedChar_StringPartJc(StringPartJc_s* thiz, StringJc sCharsEnd, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyNonEscapedChar_StringPartJc");
  
  { 
    
    if(thiz->bCurrentOk) 
    { 
      
      
      char  cEscape = '\\';
      thiz->endLast = thiz->end;
      
      int32  pos = indexOfAnyChar_Sii_StringPartJc(thiz, sCharsEnd, 0, maxToTest, _thCxt);
      
      while(pos > thiz->begin + 1 && charAt_CharSeqJc(thiz->content/*J1cT2*/, pos - 1, _thCxt) == cEscape)
        { /*:the escape char is before immediately. It means, the end char is not matched.*/
          
          
          pos = indexOfAnyChar_Sii_StringPartJc(thiz, sCharsEnd, pos + 1 - thiz->begin, maxToTest, _thCxt);
        }
      if(pos < 0) 
      { 
        
        thiz->end = thiz->begin;
        thiz->bFound = false;
      }
      else 
      { 
        
        thiz->end = thiz->begin + pos;
        thiz->bFound = true;
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the valid part to the first position of the given String,*/
struct StringPartJc_t* lentoNonEscapedString_StringPartJc(StringPartJc_s* thiz, StringJc sEnd, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoNonEscapedString_StringPartJc");
  
  { 
    
    if(thiz->bCurrentOk) 
    { 
      
      
      char  cEscape = '\\';
      thiz->endLast = thiz->end;
      
      int32  pos = indexOf_Csii_StringPartJc(thiz, sEnd, 0, maxToTest, _thCxt);
      
      while(pos > thiz->begin + 1 && charAt_CharSeqJc(thiz->content/*J1cT2*/, pos - 1, _thCxt) == cEscape)
        { /*:the escape char is before immediately. It means, the end char is not matched.*/
          
          
          pos = indexOf_Csii_StringPartJc(thiz, sEnd, pos + 1 - thiz->begin, maxToTest, _thCxt);
        }
      if(pos < 0) 
      { 
        
        thiz->end = thiz->begin;
        thiz->bFound = false;
      }
      else 
      { 
        
        thiz->end = thiz->begin + pos;
        thiz->bFound = true;
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the current Part from the current position to exactly one line.*/
struct StringPartJc_t* line_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("line_StringPartJc");
  
  { 
    
    
    int32  posStart = lastIndexOfAnyChar_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begiMin, thiz->begin, s0_StringJc("\r\n"), _thCxt);
    if(posStart < 0) 
    { 
      
      posStart = thiz->begiMin;
    }
    
    int32  posEnd = indexOfAnyChar_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->endMax, s0_StringJc("\r\n"), _thCxt);
    if(posEnd < 0) 
    { 
      
      posEnd = thiz->endMax;
    }
    thiz->begin = posStart;
    thiz->end = posEnd;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Displaces the start of the part for some chars to left or to right.*/
struct StringPartJc_t* seek_i_StringPartJc(StringPartJc_s* thiz, int32 nr, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seek_i_StringPartJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    thiz->beginLast = thiz->begin;
    thiz->begin += nr;
    if(thiz->begin > thiz->end) /***/
    throwIndexOutOfBoundsException_StringPartJc(thiz, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "seek=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, nr, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, " begin=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->begin - nr), _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, " end=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->end, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), _thCxt);
    else if(thiz->begin < thiz->begiMin) /***/
    throwIndexOutOfBoundsException_StringPartJc(thiz, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "seek=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, nr, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, " begin=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, (thiz->begin - nr), _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, " begin-min=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->begiMin, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), _thCxt);
    thiz->bFound = true;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Displaces the start of the part to the first char it is no whitespace.*/
struct StringPartJc_t* seekNoWhitespace_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekNoWhitespace_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    
    while(thiz->begin < thiz->end && indexOf_C_StringJc(zI_StringJc(" \t\r\n\f",5), charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->begin, _thCxt)) >= 0)
      { 
        
        thiz->begin += 1;
      }
    thiz->bFound = (thiz->begin > thiz->beginLast);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**skip over comment and whitespaces*/
struct StringPartJc_t* skipWhitespaceAndComment_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("skipWhitespaceAndComment_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return seekNoWhitespaceOrComments_StringPartJc(thiz, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Displaces the begin of the part to the first char it is no whitespace or comment.*/
struct StringPartJc_t* seekNoWhitespaceOrComments_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekNoWhitespaceOrComments_StringPartJc");
  
  { 
    
    
    int32  start00 = thiz->begin;
    
    int32  start0;/*no initvalue*/
    do 
      { 
        
        start0 = thiz->begin;
        if((thiz->bitMode & mSkipOverWhitespace_mode_StringPartJc) != 0) 
        { 
          
          seekNoWhitespace_StringPartJc(thiz, _thCxt);
        }
        if((thiz->bitMode & mSkipOverCommentInsideText_mode_StringPartJc) != 0) 
        { 
          
          if(compare_CsiCsii_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->sCommentStart, 0, length_StringJc(thiz->sCommentStart), _thCxt) == 0) 
          { 
            
            seek_Si_StringPartJc(thiz, thiz->sCommentEnd, seekEnd_StringPartJc, _thCxt);
          }
        }
        if((thiz->bitMode & mSkipOverCommentToEol_mode_StringPartJc) != 0) 
        { 
          
          if(compare_CsiCsii_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->sCommentToEol, 0, length_StringJc(thiz->sCommentToEol), _thCxt) == 0) 
          { 
            
            seek_ci_StringPartJc(thiz, '\n', seekEnd_StringPartJc, _thCxt);
          }
        }
      }while(thiz->begin != start0);/*:TRICKY: if something is done, repeat all conditions.*/
    
    thiz->bFound = (thiz->begin > start00);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns true, if the last called seek__(), lento__() or skipWhitespaceAndComment()*/
bool found_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("found_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->bFound;
    }
  }
  STACKTRC_LEAVE;
}


/**Displaces the begin of the part to the leftest possible begin.*/
struct StringPartJc_t* seekBegin_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekBegin_StringPartJc");
  
  { 
    
    thiz->begin = thiz->beginLast = /*? assignment*/thiz->begiMin;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Searchs the given String inside the valid part, posits the begin of the part to the begin of the searched string.*/
struct StringPartJc_t* seek_Si_StringPartJc(StringPartJc_s* thiz, StringJc sSeek, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seek_Si_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    
    int32  seekArea1;/*no initvalue*/
    
    int32  seekArea9;/*no initvalue*/
    
    int32  posNotFound;/*no initvalue*/
    if((mode & mSeekToLeft__StringPartJc) == mSeekToLeft__StringPartJc) 
    { 
      
      
      int32  posAreaEnd = thiz->begin + length_StringJc(sSeek) - 1;
      if(posAreaEnd > thiz->endMax) posAreaEnd = thiz->endMax;/*but not over the end.*/
      
      seekArea1 = thiz->begiMin;
      seekArea9 = posAreaEnd;/*sSeekArea = content.substring(startMin, posAreaEnd );*/
      
      posNotFound = thiz->begin;/*if not found, the rightest position of area*/
      
    }
    else 
    { 
      
      seekArea1 = thiz->begin;
      seekArea9 = thiz->end;/*sSeekArea = content.substring(begin, end );*/
      
      posNotFound = thiz->end;/*if not found, the rightest position of area*/
      
    }
    
    int32  pos;/*no initvalue*/
    if((mode & mSeekBackward__StringPartJc) == mSeekBackward__StringPartJc) 
    { 
      
      pos = lastIndexOf_CsiiS_StringFunctionsJc(/*J2C:static method call*/thiz->content, seekArea1, seekArea9, sSeek, _thCxt);/*sSeekArea.lastIndexOf(sSeek);*/
      
    }
    else 
    { 
      
      pos = indexOf_CsiiS_StringFunctionsJc(/*J2C:static method call*/thiz->content, seekArea1, seekArea9, sSeek, _thCxt);
    }
    if(pos < 0) 
    { 
      
      thiz->begin = posNotFound;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->bFound = true;
      thiz->begin = pos;
      if((mode & seekEnd_StringPartJc) == seekEnd_StringPartJc) 
      { 
        
        thiz->begin += length_StringJc(sSeek);
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Seeks back form the current end to the end of the given String starting from the end of the current part.*/
struct StringPartJc_t* seekBackward_StringPartJc(StringPartJc_s* thiz, StringJc sSeek, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekBackward_StringPartJc");
  
  { 
    
    
    int32  pos = lastIndexOf_CsiiS_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, sSeek, _thCxt);
    if(pos < 0) thiz->bFound = false;
    else 
    { 
      
      thiz->begin = pos + length_StringJc(sSeek);
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Seeks back from the current end to one of the characters contained in chars, starting from the end of the current part.*/
struct StringPartJc_t* seekBackToAnyChar_StringPartJc(StringPartJc_s* thiz, StringJc chars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekBackToAnyChar_StringPartJc");
  
  { 
    
    
    int32  pos = lastIndexOfAnyChar_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, chars, _thCxt);
    if(pos < 0) thiz->bFound = false;
    else 
    { 
      
      thiz->begin = pos;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Searchs the given String inside the valid part, posits the begin of the part to the begin of the searched string.*/
struct StringPartJc_t* seekAnyString_StringPartJc(StringPartJc_s* thiz, StringJc_Y* strings, int32* nrofFoundString, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekAnyString_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    
    int32  pos;/*no initvalue*/
    pos = indexOfAnyString_StringPartJc(thiz, ((struct CharSeqJc_Y_t*)strings), 0, MAX_VALUE_IntegerJc, nrofFoundString, null, _thCxt);
    if(pos < 0) 
    { 
      
      thiz->bFound = false;
      thiz->begin = thiz->end;
    }
    else 
    { 
      
      thiz->bFound = true;
      thiz->begin = thiz->begin + pos;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Searchs the given character inside the valid part, posits the begin of the part to the begin of the searched char.*/
struct StringPartJc_t* seek_ci_StringPartJc(StringPartJc_s* thiz, char cSeek, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seek_ci_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    
    int32  seekArea1;/*no initvalue*/
    
    int32  seekArea9;/*no initvalue*/
    
    int32  posNotFound;/*no initvalue*/
    if((mode & mSeekToLeft__StringPartJc) == mSeekToLeft__StringPartJc) 
    { 
      
      
      int32  posAreaEnd = thiz->begin;
      if(posAreaEnd > thiz->endMax) posAreaEnd = thiz->endMax;/*but not over the end.*/
      
      seekArea1 = thiz->begiMin;
      seekArea9 = posAreaEnd;/*sSeekArea = content.substring(startMin, posAreaEnd );*/
      
      posNotFound = thiz->begin;/*if not found, the rightest position of area*/
      
    }
    else 
    { 
      
      seekArea1 = thiz->begin;
      seekArea9 = thiz->end;/*sSeekArea = content.substring(begin, end );*/
      
      posNotFound = thiz->end;/*if not found, the rightest position of area*/
      
    }
    
    int32  pos;/*no initvalue*/
    if((mode & mSeekBackward__StringPartJc) == mSeekBackward__StringPartJc) 
    { 
      
      pos = lastIndexOf_Csiic_StringFunctionsJc(/*J2C:static method call*/thiz->content, seekArea1, seekArea9, cSeek, _thCxt);
    }
    else 
    { 
      
      pos = indexOf_Csiic_StringFunctionsJc(/*J2C:static method call*/thiz->content, seekArea1, seekArea9, cSeek, _thCxt);
    }
    if(pos < 0) 
    { 
      
      thiz->begin = posNotFound;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->bFound = true;
      thiz->begin = pos;
      if((mode & seekEnd_StringPartJc) == seekEnd_StringPartJc) 
      { 
        
        thiz->begin += 1;
      }
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Posits the start of the part after all of the chars given in the parameter string.*/
struct StringPartJc_t* seekNoChar_StringPartJc(StringPartJc_s* thiz, StringJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekNoChar_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    
    while(thiz->begin < thiz->end && indexOf_C_StringJc(sChars, charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->begin, _thCxt)) >= 0)thiz->begin += 1;
    if(thiz->begin < thiz->end) thiz->bFound = true;
    else thiz->bFound = false;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Searches any char contained in sChars in the current part*/
int32 indexOfAnyChar_Sii_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyChar_Sii_StringPartJc");
  
  { 
    
    
    int32  pos = thiz->begin + fromWhere;
    
    int32  max = (thiz->end - pos) < maxToTest ? thiz->end : pos + maxToTest;
    
    int32  found = indexOfAnyChar_StringFunctionsJc(/*J2C:static method call*/thiz->content, pos, max, sChars, _thCxt);
    if(found < 0) { STACKTRC_LEAVE;
      return found;
    }
    else { STACKTRC_LEAVE;
      return found - thiz->begin;
    }/**/
    
  }
  STACKTRC_LEAVE;
}


/**Returns the position of one of the chars in sChars within the part, started inside the part with fromIndex,*/
int32 indexOfAnyChar_Siiccc_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 fromWhere, int32 maxToTest, char transcriptChar, char quotationStartChar, char quotationEndChar, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyChar_Siiccc_StringPartJc");
  
  { 
    
    
    int32  pos = thiz->begin + fromWhere;
    
    int32  max = (thiz->end - pos) < maxToTest ? thiz->end : thiz->begin + maxToTest;
    
    bool  bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        
        
        char  cc = charAt_CharSeqJc(thiz->content/*J1cT2*/, pos, _thCxt);
        if(cc == quotationStartChar && cc != 0) 
        { 
          
          
          int32  endQuotion = indexEndOfQuotation_StringPartJc(thiz, quotationEndChar, transcriptChar, pos - thiz->begin, max - thiz->begin, _thCxt);
          if(endQuotion < 0) 
          { 
            
            pos = max;
          }
          else 
          { 
            
            pos = endQuotion + thiz->begin;
          }
        }
        else if(cc == transcriptChar && cc != 0 && pos < (max - 1)) 
        { 
          
          pos += 2;
        }
        else 
        { 
          
          if(indexOf_C_StringJc(sChars, cc) >= 0) 
          { 
            
            bNotFound = false;
          }
          else 
          { 
            
            pos += 1;
          }
        }
      }
    if(bNotFound) 
    { 
      
      if(indexOf_C_StringJc(sChars, cEndOfText_StringPartJc) >= 0) { STACKTRC_LEAVE;
        return pos - thiz->begin;
      }/* it is found because cEndOfText is searched too.*/
      
      else { STACKTRC_LEAVE;
        return -1;
      }
    }
    else { STACKTRC_LEAVE;
      return (pos - thiz->begin);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the last position of one of the chars in sChars*/
int32 lastIndexOfAnyChar_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lastIndexOfAnyChar_StringPartJc");
  
  { 
    
    
    int32  pos = (thiz->end - thiz->begin) < maxToTest ? thiz->end - 1 : thiz->begin + maxToTest - 1;
    
    int32  min = thiz->begin + fromWhere;
    
    while(pos >= min && indexOf_C_StringJc(sChars, charAt_CharSeqJc(thiz->content/*J1cT2*/, pos, _thCxt)) < 0)
      { 
        
        pos -= 1;
      }
    
    int32  index = pos >= min ? pos - thiz->begin : -1;
    { STACKTRC_LEAVE;
      return index;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of one of the chars in sChars within the part, started inside the part with fromIndex,*/
int32 indexOfAnyString_StringPartJc(StringPartJc_s* thiz, CharSeqJc_Y* listStrings, int32 fromWhere, int32 maxToTest, int32* nrofFoundString, StringJc* foundString, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyString_StringPartJc");
  
  { 
    
    
    int32  start = thiz->begin + fromWhere;
    
    int32  max = (thiz->end - start) < maxToTest ? thiz->end : start + maxToTest;
    
    int32  pos = indexOfAnyString_StringFunctionsJc(/*J2C:static method call*/thiz->content, start, max, listStrings, nrofFoundString, foundString, _thCxt);
    if(pos >= 0) 
    { 
      
      pos += fromWhere;
    }/*found, but it has start after begin.*/
    
    { STACKTRC_LEAVE;
      return pos;
    }
  }
  STACKTRC_LEAVE;
}


/**Searches any char contained in sChars in the current part*/
int32 indexOfAnyCharOutsideQuotion_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyCharOutsideQuotion_StringPartJc");
  
  { 
    
    
    int32  pos = thiz->begin + fromWhere;
    
    int32  max = (thiz->end - pos) < maxToTest ? thiz->end : thiz->begin + maxToTest;
    
    bool  bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        
        
        char  cc = charAt_CharSeqJc(thiz->content/*J1cT2*/, pos, _thCxt);
        if(cc == '\"') 
        { 
          
          
          int32  endQuotion = indexEndOfQuotion_StringPartJc(thiz, '\"', pos - thiz->begin, max - thiz->begin, _thCxt);
          if(endQuotion < 0) 
          { 
            
            pos = max;
          }
          else 
          { 
            
            pos = endQuotion + thiz->begin;
          }
        }
        else 
        { 
          
          if(indexOf_C_StringJc(sChars, cc) >= 0) 
          { 
            
            bNotFound = false;
          }
          else 
          { 
            
            pos += 1;
          }
        }
      }
    { STACKTRC_LEAVE;
      return (bNotFound) ? -1 : (pos - thiz->begin);
    }
  }
  STACKTRC_LEAVE;
}


/**Searches the end of a quoted string*/
int32 indexEndOfQuotion_StringPartJc(StringPartJc_s* thiz, char cEndQuotion, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexEndOfQuotion_StringPartJc");
  
  { 
    
    
    int32  pos = thiz->begin + fromWhere + 1;
    
    int32  max = (thiz->end - pos) < maxToTest ? thiz->end : pos + maxToTest;
    
    bool  bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        
        
        char  cc = charAt_CharSeqJc(thiz->content/*J1cT2*/, pos++, _thCxt);
        if(cc == '\\' && (pos + 1) < max) 
        { 
          
          pos += 1;/*on \ overread the next char, test char after them!*/
          
        }
        else if(cc == cEndQuotion) 
        { 
          
          bNotFound = false;
        }
      }
    { STACKTRC_LEAVE;
      return (bNotFound ? -1 : (pos - thiz->begin));
    }
  }
  STACKTRC_LEAVE;
}


/**Searches the end of a quoted string*/
int32 indexEndOfQuotation_StringPartJc(StringPartJc_s* thiz, char cEndQuotion, char transcriptChar, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexEndOfQuotation_StringPartJc");
  
  { 
    
    
    int32  pos = thiz->begin + fromWhere + 1;
    
    int32  max = (thiz->end - pos) < maxToTest ? thiz->end : pos + maxToTest;
    
    bool  bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        
        
        char  cc = charAt_CharSeqJc(thiz->content/*J1cT2*/, pos++, _thCxt);
        if(cc == transcriptChar && cc != 0 && (pos + 1) < max) 
        { 
          
          pos += 1;/*on \ overread the next char, test char after them!*/
          
        }
        else if(cc == cEndQuotion) 
        { 
          
          bNotFound = false;
        }
      }
    { STACKTRC_LEAVE;
      return (bNotFound ? -1 : (pos - thiz->begin));
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of one of the chars in sChars within the part,*/
int32 indexOfAnyChar_S_StringPartJc(StringPartJc_s* thiz, StringJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyChar_S_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return indexOfAnyChar_Sii_StringPartJc(thiz, sChars, 0, MAX_VALUE_IntegerJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the first char other than the chars in sChars within the part, started inside the part with fromIndex,*/
int32 indexOfNoChar_Si_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 fromWhere, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfNoChar_Si_StringPartJc");
  
  { 
    
    
    int32  pos = thiz->begin + fromWhere;
    
    while(pos < thiz->end && indexOf_C_StringJc(sChars, charAt_CharSeqJc(thiz->content/*J1cT2*/, pos, _thCxt)) >= 0)pos += 1;
    { STACKTRC_LEAVE;
      return (pos >= thiz->end) ? -1 : (pos - thiz->begin);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the first char other than the chars in sChars within the part,*/
int32 indexOfNoChar_S_StringPartJc(StringPartJc_s* thiz, StringJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfNoChar_S_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return indexOfNoChar_Si_StringPartJc(thiz, sChars, 0, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any char content in sChars (terminate chars).*/
struct StringPartJc_t* lentoAnyChar_Si_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyChar_Si_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lentoAnyChar_Sii_StringPartJc(thiz, sChars, maxToTest, seekNormal_StringPartJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any char content in sChars (terminate chars).*/
struct StringPartJc_t* lentoAnyChar_Sii_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 maxToTest, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyChar_Sii_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    
    int32  pos;/*no initvalue*/
    if((mode & mSeekBackward__StringPartJc) != 0) 
    { 
      
      pos = lastIndexOfAnyChar_StringPartJc(thiz, sChars, 0, maxToTest, _thCxt);
    }
    else 
    { 
      
      pos = indexOfAnyChar_Sii_StringPartJc(thiz, sChars, 0, maxToTest, _thCxt);
    }
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->end = thiz->begin + pos;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any terminate string given in sString.*/
struct StringPartJc_t* lentoAnyString_SYi_StringPartJc(StringPartJc_s* thiz, StringJc_Y* strings, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyString_SYi_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lentoAnyString_SYii_StringPartJc(thiz, strings, maxToTest, seekNormal_StringPartJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any terminate string given in sString.*/
struct StringPartJc_t* lentoAnyString_SYii_StringPartJc(StringPartJc_s* thiz, StringJc_Y* strings, int32 maxToTest, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyString_SYii_StringPartJc");
  
  { 
    ObjectJc *newObj2_1=null; /*J2C: temporary Objects for new operations
    */
    thiz->endLast = thiz->end;
    
    StringJc*  foundString; /*J2C:modeAccess=P: simple VariableRef*/
    
    int32  pos = indexOfAnyString_StringPartJc(thiz, ((struct CharSeqJc_Y_t*)strings), 0, maxToTest, null, foundString, _thCxt);
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      if((mode & seekEnd_StringPartJc) != 0) 
      { 
        
        pos += length_StringJc(foundString[0]);
      }
      thiz->end = thiz->begin + pos;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj2_1, null, _thCxt);
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any terminate string given in sString.*/
void lentoAnyStringWithIndent_StringPartJc(StringPartJc_s* thiz, StringJc_Y* strings, StringJc sIndentChars, int32 maxToTest, struct StringBuilderJc_t* buffer, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyStringWithIndent_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;/*String sRet; sRet = "";*/
    
    setLength_StringBuilderJc(buffer, 0, _thCxt);
    
    int32  indentColumn = getCurrentColumn_StringPartJc(thiz, _thCxt);
    
    int32  startLine = thiz->begin;
    
    bool  bAlsoWhiteSpaces = (charAt_StringJc(sIndentChars, length_StringJc(sIndentChars) - 1) == ' ');
    
    int32  pos = indexOfAnyString_StringPartJc(thiz, ((struct CharSeqJc_Y_t*)strings), 0, maxToTest, null, null, _thCxt);
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->bFound = true;
      thiz->end = thiz->begin + pos;
      
      bool  bFinish = false;
      
      while(!bFinish)
        { 
          
          pos = indexOf_Csci_StringFunctionsJc(/*J2C:static method call*/thiz->content, '\n', startLine, _thCxt);
          if(pos < 0) pos = thiz->end;
          if(pos > thiz->end) 
          { /*:next newline after terminated string, that is the last line.*/
            
            
            pos = thiz->end;
            bFinish = true;
          }
          else 
          { 
            
            pos += 1;
          }/* '\n' including*/
          /*append the line to output string:*/
          
          append_c_StringBuilderJc(buffer, subSequence_CharSeqJc(thiz->content/*J1cT2*/, startLine, pos, _thCxt), _thCxt);
          if(!bFinish) 
          { /*:skip over indent.*/
            
            
            startLine = pos;
            
            int32  posIndent = startLine + indentColumn;
            if(posIndent > thiz->end) posIndent = thiz->end;
            
            while(startLine < posIndent && indexOf_C_StringJc(sIndentChars, charAt_CharSeqJc(thiz->content/*J1cT2*/, startLine, _thCxt)) >= 0)
              { 
                
                startLine += 1;
              }
            if(bAlsoWhiteSpaces) 
            { 
              
              
              while(indexOf_C_StringJc(zI_StringJc(" \t",2), charAt_CharSeqJc(thiz->content/*J1cT2*/, startLine, _thCxt)) >= 0)
                { 
                  
                  startLine += 1;
                }
            }
          }
        }
    }
    { STACKTRC_LEAVE;
      return;
    }/*buffer.toString();*/
    
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any char content in sChars (terminate chars),*/
struct StringPartJc_t* lentoAnyCharOutsideQuotion_StringPartJc(StringPartJc_s* thiz, StringJc sChars, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyCharOutsideQuotion_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    
    int32  pos = indexOfAnyCharOutsideQuotion_StringPartJc(thiz, sChars, 0, maxToTest, _thCxt);
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->end = thiz->begin + pos;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to the end of the quotion*/
struct StringPartJc_t* lentoQuotionEnd_StringPartJc(StringPartJc_s* thiz, char sEndQuotion, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoQuotionEnd_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    
    int32  pos = indexEndOfQuotion_StringPartJc(thiz, sEndQuotion, 0, maxToTest, _thCxt);
    if(pos < 0) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;
    }
    else 
    { 
      
      thiz->end = thiz->begin + pos;
      thiz->bFound = true;
    }
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to the end of the current line.*/
struct StringPartJc_t* lentoLineEnd_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoLineEnd_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return lentoAnyChar_S_StringPartJc(thiz, s0_StringJc("\n\r\f"), _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Increments the begin of the current part over maybe found whitespaces*/
struct StringPartJc_t* trimWhiteSpaces_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("trimWhiteSpaces_StringPartJc");
  
  { 
    
    seekNoWhitespace_StringPartJc(thiz, _thCxt);
    lenBacktoNoChar_StringPartJc(thiz, s0_StringJc(" \t\r\n\f"), _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current part to any char content in sChars (terminate chars).*/
struct StringPartJc_t* lentoAnyChar_S_StringPartJc(StringPartJc_s* thiz, StringJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoAnyChar_S_StringPartJc");
  
  { 
    
    lentoAnyChar_Si_StringPartJc(thiz, sChars, MAX_VALUE_IntegerJc, _thCxt);
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length to the end of the maximal part if the length is 0*/
struct StringPartJc_t* len0end_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("len0end_StringPartJc");
  
  { 
    
    if(thiz->end <= thiz->begin) thiz->end = thiz->endMax;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length to the end of the maximal part.*/
struct StringPartJc_t* setLengthMax_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setLengthMax_StringPartJc");
  
  { 
    
    thiz->end = thiz->endMax;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Posits the end of the part before all of the chars given in the parameter string.*/
struct StringPartJc_t* lenBacktoNoChar_StringPartJc(StringPartJc_s* thiz, StringJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lenBacktoNoChar_StringPartJc");
  
  { 
    
    thiz->endLast = thiz->end;
    
    while(thiz->end > thiz->begin && indexOf_C_StringJc(sChars, charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->end - 1, _thCxt)) >= 0)
      { 
        
        thiz->end = thiz->end - 1;
      }
    if(thiz->end <= thiz->begin) 
    { 
      
      thiz->end = thiz->begin;
      thiz->bFound = false;/*all chars skipped to left.*/
      
    }
    else thiz->bFound = true;
    { STACKTRC_LEAVE;
      return thiz;
    }
  }
  STACKTRC_LEAVE;
}


/**Trims all leading and trailing whitespaces within the part.*/
struct StringPartJc_t* trim_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("trim_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return 
      ( seekNoChar_StringPartJc(thiz, s0_StringJc(" \t\n\r"), _thCxt)
      , lenBacktoNoChar_StringPartJc(thiz, s0_StringJc(" \t\n\r"), _thCxt)
      );
    }/*end position decreased*/
    
  }
  STACKTRC_LEAVE;
}


/**Trims a java- or C-style line-comment from end of part and all leading and trailing whitespaces.*/
struct StringPartJc_t* trimComment_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("trimComment_StringPartJc");
  
  { 
    
    thiz->beginLast = thiz->begin;
    thiz->endLast = thiz->end;
    
    int32  posComment = indexOf_S_StringPartJc(thiz, s0_StringJc("//"), _thCxt);
    if(posComment >= 0) thiz->end = thiz->begin + posComment;
    thiz->bFound = (thiz->begin > thiz->beginLast);
    { STACKTRC_LEAVE;
      return trim_StringPartJc(thiz, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 compareTo_StringPartJc(StringPartJc_s* thiz, CharSeqJc str2, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("compareTo_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return compare_CsiCsii_StringFunctionsJc(/*J2C:static method call*/fromObjectJc_CharSeqJc(&(* (thiz)).base.object), 0, str2, 0, MAX_VALUE_IntegerJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the char within the part,*/
int32 indexOf_c_StringPartJc(StringPartJc_s* thiz, char ch, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_c_StringPartJc");
  
  { 
    
    
    int32  pos = indexOf_Csiic_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, ch, _thCxt);
    
    ;
    if(pos < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else { STACKTRC_LEAVE;
      return pos - thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the char within the part, started inside the part with fromIndex,*/
int32 indexOf_ci_StringPartJc(StringPartJc_s* thiz, char ch, int32 fromIndex, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_ci_StringPartJc");
  
  { 
    
    if(fromIndex >= (thiz->end - thiz->begin) || fromIndex < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else 
    { 
      
      
      int32  pos = indexOf_Csiic_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin + fromIndex, thiz->end, ch, _thCxt);
      
      ;
      if(pos < 0) { STACKTRC_LEAVE;
        return -1;
      }
      else { STACKTRC_LEAVE;
        return pos - thiz->begin + fromIndex;
      }
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the string within the part*/
int32 indexOf_S_StringPartJc(StringPartJc_s* thiz, StringJc sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_S_StringPartJc");
  
  { 
    
    
    int32  pos = indexOf_CsiiS_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, sCmp, _thCxt);
    if(pos < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else { STACKTRC_LEAVE;
      return pos - thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the string within the part*/
int32 indexOf_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_Cs_StringPartJc");
  
  { 
    
    
    int32  pos = indexOf_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, sCmp, _thCxt);
    if(pos < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else { STACKTRC_LEAVE;
      return pos - thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the string within the part*/
int32 indexOf_Csii_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, int32 fromIndex, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_Csii_StringPartJc");
  
  { 
    
    
    int32  max = (thiz->end - thiz->begin) < maxToTest ? thiz->end : thiz->begin + maxToTest;
    if(fromIndex >= (max - thiz->begin) || fromIndex < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else 
    { 
      
      
      int32  pos = indexOf_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin + fromIndex, max, sCmp, _thCxt);
      if(pos < 0) { STACKTRC_LEAVE;
        return -1;
      }
      else { STACKTRC_LEAVE;
        return pos - thiz->begin + fromIndex;
      }
    }
  }
  STACKTRC_LEAVE;
}


/**Compares the Part of string with the given string*/
bool equals_Cs_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("equals_Cs_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return equals_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, sCmp, _thCxt);
    }/*content.substring(start, end).equals(sCmp);*/
    
  }
  STACKTRC_LEAVE;
}


/**compares the Part of string with the given string.*/
bool startsWith_StringPartJc(StringPartJc_s* thiz, CharSeqJc sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("startsWith_StringPartJc");
  
  { 
    
    
    int32  pos_cEndOfText = indexOf_Csci_StringFunctionsJc(/*J2C:static method call*/sCmp, cEndOfText_StringPartJc, 0, _thCxt);
    if(pos_cEndOfText >= 0) 
    { 
      
      if(pos_cEndOfText == 0) 
      { 
        
        { STACKTRC_LEAVE;
          return thiz->begin == thiz->end;
        }
      }
      else 
      { 
        
        { STACKTRC_LEAVE;
          return equals_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, sCmp, _thCxt);
        }/*content.substring(start, end).equals(sCmp);*/
        
      }
    }
    else 
    { 
      
      { STACKTRC_LEAVE;
        return startsWith_CsiiCs_StringFunctionsJc(/*J2C:static method call*/thiz->content, thiz->begin, thiz->end, sCmp, _thCxt);
      }/*content.substring(start, end).startsWith(sCmp);*/
      
    }
  }
  STACKTRC_LEAVE;
}


/**Gets the current position, useable for rewind*/
int64 getCurrentPosition_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentPosition_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->begin;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the current position at a fix position inside the maxPart.*/
void setCurrentPosition_StringPartJc(StringPartJc_s* thiz, int64 pos, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setCurrentPosition_StringPartJc");
  
  { 
    
    thiz->begin = (int32)pos;
  }
  STACKTRC_LEAVE;
}


/**Gets a substring inside the maximal part*/
struct Part_StringPartJc_t* substring_StringPartJc(StringPartJc_s* thiz, int32 pos, int32 posendP, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("substring_StringPartJc");
  
  { 
    
    
    int32  posend;/*no initvalue*/
    if(posendP <= 0) 
    { 
      
      posend = thiz->endMax - posendP;/*if posendP is fault, an exception is thrown.*/
      
    }
    else 
    { 
      
      posend = posendP;
    }
    
    struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), _thCxt), pos + thiz->begiMin, posend, _thCxt);
    { STACKTRC_LEAVE;
      return ret;
    }
  }
  STACKTRC_LEAVE;
}


/**Gets the next chars from current Position.*/
CharSeqJc getCurrent_StringPartJc(StringPartJc_s* thiz, int32 nChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrent_StringPartJc");
  
  { 
    ObjectJc *newObj2_1=null; /*J2C: temporary Objects for new operations
    */
    
    int32  nChars1 = (thiz->endMax - thiz->begin) < nChars ? thiz->endMax - thiz->begin : nChars;
    if(nChars1 == 0) { STACKTRC_LEAVE;
      return s0_StringJc("");
    }
    else { STACKTRC_LEAVE;
      activateGC_ObjectJc(newObj2_1, (ctorO_Part_StringPartJc(thiz, (newObj2_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin, thiz->begin + nChars1, _thCxt)), _thCxt);
      return fromObjectJc_CharSeqJc(&(* ((ctorO_Part_StringPartJc(thiz, (newObj2_1 = alloc_ObjectJc(sizeof_Part_StringPartJc_s, 0, _thCxt)), thiz->begin, thiz->begin + nChars1, _thCxt)))).base.object);
    }
  }
  STACKTRC_LEAVE;
}


/**Gets the next char at current Position.*/
char getCurrentChar_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentChar_StringPartJc");
  
  { 
    
    if(thiz->begin < thiz->endMax) 
    { 
      
      { STACKTRC_LEAVE;
        return charAt_CharSeqJc(thiz->content/*J1cT2*/, thiz->begin, _thCxt);
      }
    }
    else { STACKTRC_LEAVE;
      return '\0';
    }
  }
  STACKTRC_LEAVE;
}


/**Get the Line number and the column of the begin position.*/
int32 getLineAndColumn_StringPartJc_F(StringPartJc_s* thiz, int32_Y* column, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLineAndColumn_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 getLineAndColumn_StringPartJc(StringPartJc_s* thiz, int32_Y* column, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getLineAndColumn(thiz, column, _thCxt);
}


/**Gets the current position in line (column of the text).*/
int32 getCurrentColumn_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentColumn_StringPartJc");
  
  { /*:if((bitMode & mGetColumn_mode)==0){ return -1; }*/
    /*:else {*/
    
    
    
    int32  pos = lastIndexOf_Csiic_StringFunctionsJc(/*J2C:static method call*/thiz->content, 0, thiz->begin, '\n', _thCxt);
    if(pos < 0) { STACKTRC_LEAVE;
      return thiz->begin;
    }/*first line, no \n before*/
    
    else { STACKTRC_LEAVE;
      return thiz->begin - pos - 1;
    }/*}*/
    
  }
  STACKTRC_LEAVE;
}


/**This method may be overridden to return the file which is used to build this Stringpart.*/
StringJc getInputfile_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInputfile_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->sFile;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the actual part of the string.*/
struct Part_StringPartJc_t* getCurrentPart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentPart_StringPartJc");
  
  { 
    
    
    struct Part_StringPartJc_t*  ret_1;/*no initvalue*/
    if(thiz->end > thiz->begin) ret_1 = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), _thCxt), thiz->begin, thiz->end, _thCxt);
    else ret_1 = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), _thCxt), thiz->begin, thiz->begin, _thCxt);
    { STACKTRC_LEAVE;
      return ret_1;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the last part of the string before any seek or scan operation.*/
CharSeqJc getLastPart_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLastPart_StringPartJc");
  
  { 
    
    if(thiz->begin > thiz->beginLast) 
    { 
      
      
      struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), _thCxt), thiz->beginLast, thiz->begin, _thCxt);
      { STACKTRC_LEAVE;
        return fromObjectJc_CharSeqJc(&(* (ret)).base.object);
      }
    }
    else { STACKTRC_LEAVE;
      return s0_StringJc("");
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the actual part of the string.*/
CharSeqJc getCurrentPart_i_StringPartJc(StringPartJc_s* thiz, int32 maxLength, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentPart_i_StringPartJc");
  
  { 
    
    
    int32  max = (thiz->end - thiz->begin) < maxLength ? thiz->end : thiz->begin + maxLength;
    if(thiz->end > thiz->begin) 
    { 
      
      
      struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), _thCxt), thiz->begin, max, _thCxt);
      { STACKTRC_LEAVE;
        return fromObjectJc_CharSeqJc(&(* (ret)).base.object);
      }
    }
    else { STACKTRC_LEAVE;
      return s0_StringJc("");
    }
  }
  STACKTRC_LEAVE;
}


/**Retrurn the part from start to end independent of the current positions.*/
struct Part_StringPartJc_t* getPart_StringPartJc(StringPartJc_s* thiz, int32 fromPos, int32 nrofChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getPart_StringPartJc");
  
  { 
    
    
    int32  nChars1 = (thiz->endMax - fromPos) < nrofChars ? thiz->endMax - fromPos : nrofChars;
    
    struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc(thiz, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), _thCxt), fromPos, fromPos + nChars1, _thCxt);
    { STACKTRC_LEAVE;
      return ret;
    }
  }
  STACKTRC_LEAVE;
}

char absCharAt_StringPartJc(StringPartJc_s* thiz, int32 index, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("absCharAt_StringPartJc");
  
  { 
    
    
    int32  pos = index;
    if(pos >= 0 && pos < thiz->endMax) { STACKTRC_LEAVE;
      return charAt_CharSeqJc(thiz->content/*J1cT2*/, pos, _thCxt);
    }
    else 
    { 
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      { throw_sJc(ident_IllegalArgumentExceptionJc, 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "StringPartBase.charAt - faulty; ", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, index, _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    }
  }
  STACKTRC_LEAVE;
}


/**Returns a String from absolute range.*/
StringJc absSubString_StringPartJc(StringPartJc_s* thiz, int32 from, int32 to, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("absSubString_StringPartJc");
  
  { 
    
    
    int32  pos = from;
    
    int32  len = to - from;
    
    int32  end1 = pos + len;
    if(thiz->content.ref== null) 
    { 
      
      { STACKTRC_LEAVE;
        return s0_StringJc(" ??null?? ");
      }
    }
    if(pos >= 0 && end1 <= thiz->endMax) 
    { /*:@Java4C.ReturnNew*/
      
      
      
      CharSeqJc  cs1 = subSequence_CharSeqJc(thiz->content/*J1cT2*/, pos, pos + len, _thCxt);
      { STACKTRC_LEAVE;
        return toString_CharSeqJc(cs1/*J1cT2*/);
      }
    }
    else 
    { 
      StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
      
      { throw_sJc(ident_IllegalArgumentExceptionJc, 
        ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
        , append_z_StringBuilderJc(_stringBuilderThCxt, "StringPartBase.subSequence - faulty; ", _thCxt)
        , append_I_StringBuilderJc(_stringBuilderThCxt, from, _thCxt)
        , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return null_StringJc; };
    }
  }
  STACKTRC_LEAVE;
}

StringJc toString_StringPartJc_F(ObjectJc* ithis, ThCxt* _thCxt)
{ StringPartJc_s* thiz = (StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("toString_StringPartJc_F");
  
  { 
    
    
    CharSeqJc  currentPart = fromObjectJc_CharSeqJc(&(* (getCurrentPart_StringPartJc(thiz, _thCxt)/*J2C:returnInThreadCxt*/)).base.object);
    
    StringJc  ret = toString_CharSeqJc(currentPart/*J1cT2*/)/*J2C:non-persistent*/;
    { STACKTRC_LEAVE;
      releaseUserBuffer_ThreadContextFw(PTR_StringJc(currentPart), _thCxt);
      return ret;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc toString_StringPartJc(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_ObjectJc const* mtbl = (Mtbl_ObjectJc const*)getMtbl_ObjectJc(ithis, sign_Mtbl_ObjectJc);
  return mtbl->toString(ithis, _thCxt);
}


/**Returns a debug information of the content of the StringPart*/
StringJc debugString_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("debugString_StringPartJc");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    
    int32  len = thiz->endMax;
    
    StringJc  ret = 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_s_StringBuilderJc(_stringBuilderThCxt, subSequence_CharSeqJc(thiz->content/*J1cT2*/, 0, len > 20 ? 20 : len, _thCxt), _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "<<<", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->begin, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, ",", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, thiz->end, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, ">>>", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    if(thiz->begin < len) 
    { 
      
      /***/
      ret = 
        ( append_s_StringBuilderJc(_stringBuilderThCxt, subSequence_CharSeqJc(thiz->content/*J1cT2*/, thiz->begin, len > (thiz->begin + 20) ? thiz->begin + 20 : len, _thCxt), _thCxt)
        , toStringNonPersist_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
    }
    /***/
    ret = 
      ( append_z_StringBuilderJc(_stringBuilderThCxt, "<<<", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    { STACKTRC_LEAVE;
      return ret;
    }/*java2c: buffer in threadContext*/
    
  }
  STACKTRC_LEAVE;
}


/**Central mehtod to invoke excpetion, usefull to set a breakpoint in debug*/
void throwIndexOutOfBoundsException_StringPartJc(StringPartJc_s* thiz, StringJc sMsg, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("throwIndexOutOfBoundsException_StringPartJc");
  
  { 
    
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, sMsg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
  }
  STACKTRC_LEAVE;
}


/**Closes the work*/
void close_StringPartJc_F(StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("close_StringPartJc_F");
  
  { 
    
    thiz->content = null_StringJc /*J2C: mem assignment*/;
    thiz->begiMin = thiz->beginLast = /*? assignment*/thiz->begin = /*? assignment*/0;
    thiz->endMax = thiz->end = /*? assignment*/thiz->endLast = /*? assignment*/0;
    thiz->bCurrentOk = thiz->bFound = /*? assignment*/false;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void close_StringPartJc(StringPartJc_s* thiz, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&thiz->base.object, sign_Mtbl_StringPartJc);
  mtbl->close(thiz, _thCxt);
}


/**Replaces up to 20 placeholder with a given content.*/
StringJc replace_StringPartJc(/*J2C:static method*/ CharSeqJc src, CharSeqJc_Y* placeholder, StringJc_Y* value, struct StringBuilderJc_t* dst, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("replace_StringPartJc");
  
  { 
    
    
    int32  len = length_CharSeqJc(src/*J1cT2*/, _thCxt);
    
    int32  ixPos = 0;
    
    int32  nrofToken = placeholder->head.length;
    if(nrofToken != value->head.length) 
    { 
      
      { throw_s0Jc(ident_IllegalArgumentExceptionJc, "token and value should have same size, lesser 20", 0, &_thCxt->stacktraceThreadContext, __LINE__); return null_StringJc; };
    }
    if(dst == null) 
    { 
      ObjectJc *newObj3_1=null; /*J2C: temporary Objects for new operations
      */
      dst = ctorO_I_StringBuilderJc(/*J2C:static method call*/(newObj3_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), len + 100, _thCxt);
      activateGC_ObjectJc(newObj3_1, null, _thCxt);
    }/*calculate about 53 chars for identifier*/
    /*@Java4C.StackInstance final StringPart spPattern = new StringPart(src);*/
    
    
    int32  posPatternStart = 0;
    
    int32  posPattern;/*no initvalue*/
    do 
      { 
        ObjectJc *newObj3_1=null; /*J2C: temporary Objects for new operations
        */
        
        int32*  type; /*J2C:modeAccess=P: simple VariableRef*/
        posPattern = indexOfAnyString_StringFunctionsJc(/*J2C:static method call*/src, posPatternStart, length_CharSeqJc(src/*J1cT2*/, _thCxt), placeholder, type, null, _thCxt);
        if(posPattern >= 0) 
        { 
          
          append_c_StringBuilderJc(dst, subSequence_CharSeqJc(src/*J1cT2*/, posPatternStart, posPattern, _thCxt), _thCxt);
          
          int32  ixValue = type[0];
          append_s_StringBuilderJc(dst, value->data[ixValue], _thCxt);
          posPatternStart = posPattern + length_CharSeqJc(placeholder->data[ixValue]/*J1cT2*/, _thCxt);
        }
        else 
        { /*:last pattern constant part:*/
          
          
          append_c_StringBuilderJc(dst, subSequence_CharSeqJc(src/*J1cT2*/, posPatternStart, len, _thCxt), _thCxt);
          posPatternStart = -1;/*mark end*/
          
        }
        activateGC_ObjectJc(newObj3_1, null, _thCxt);
      }while(posPatternStart >= 0);
    { STACKTRC_LEAVE;
      return toString_StringBuilderJc(& ((* (dst)).base/*J2C_super:*/.object)/*J2cT1*/, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_StringPartJc mtblStringPartJc = {
{ { sign_Mtbl_StringPartJc //J2C: Head of methodtable of StringPartJc
  , (struct Size_Mtbl_t*)((2 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
  }
  //J2C: Dynamic methods of the class :StringPartJc:
, getLineAndColumn_StringPartJc_F //getLineAndColumn
, close_StringPartJc_F //close
  //J2C: The superclass's methodtable: 
, { { sign_Mtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :ObjectJc:
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_StringPartJc_F //toString
  }
  //J2C: The interface's methodtable: 
  //J2C: Mtbl-interfaces of :StringPartJc: */
, { { sign_Mtbl_CharSeqJc //J2C: Head of methodtable of CharSeqJc
    , (struct Size_Mtbl_t*)((3 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :CharSeqJc:
  , length_StringPartJc //length
  , charAt_i_StringPartJc //charAt
  , subSequence_ii_StringPartJc //subSequence
  }
, { { sign_Mtbl_ComparableJc //J2C: Head of methodtable of ComparableJc
    , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
  }
, { { sign_Mtbl_CloseableJc //J2C: Head of methodtable of CloseableJc
    , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern_C struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_StringPartJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_StringPartJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_StringPartJc, ObjectJc) }
   }
 };

 extern_C struct ClassJc_t const reflection_CharSeqJc;
 extern_C struct ClassJc_t const reflection_ComparableJc;
 extern_C struct ClassJc_t const reflection_CloseableJc;
 static struct ifcClasses_StringPartJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[3];
 }interfaces_StringPartJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_CharSeqJc, OFFSET_Mtbl(Mtbl_StringPartJc, CharSeqJc) }
  , {&reflection_ComparableJc, OFFSET_Mtbl(Mtbl_StringPartJc, ComparableJc) }
  , {&reflection_CloseableJc, OFFSET_Mtbl(Mtbl_StringPartJc, CloseableJc) }
  }
};

extern_C struct ClassJc_t const reflection_StringPartJc_s;
extern_C struct ClassJc_t const reflection_CharSeqJc;
extern_C struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_StringPartJc_s_t
{ ObjectArrayJc head; FieldJc data[20];
} reflection_Fields_StringPartJc_s =
{ CONST_ObjectArrayJc(FieldJc, 20, OBJTYPE_FieldJc, null, &reflection_Fields_StringPartJc_s)
, {
     { "begin"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->begin) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "end"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->end) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "begiMin"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->begiMin) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "endMax"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->endMax) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "content"
    , 0 //nrofArrayElements
    , &reflection_CharSeqJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->content) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "bCurrentOk"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->bCurrentOk) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "bStartScan"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->bStartScan) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "beginLast"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->beginLast) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "endLast"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->endLast) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "bFound"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->bFound) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "bitMode"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->bitMode) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sFile"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->sFile) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sCommentStart"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->sCommentStart) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sCommentEnd"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->sCommentEnd) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sCommentToEol"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->sCommentToEol) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sVersion"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&sVersion_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&sVersion_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
   , { "seekToLeft"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&seekToLeft_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&seekToLeft_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
   , { "seekBack"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&seekBack_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&seekBack_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
   , { "cStartOfText"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&cStartOfText_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&cStartOfText_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
   , { "cEndOfText"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&cEndOfText_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&cEndOfText_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
} };
const ClassJc reflection_StringPartJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "StringPartJc_s"
, (int16)((int32)(&((StringPartJc_s*)(0x1000))->base.object) - (int32)(StringPartJc_s*)0x1000)
, sizeof(StringPartJc_s)
, (FieldJcArray const*)&reflection_Fields_StringPartJc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_StringPartJc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_StringPartJc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblStringPartJc.mtbl.head
};

/**This class presents a part of the parent CharSequence of this class.
The constructor is protected because instances of this class are only created in this class
or its derived, not by user.
The CharSequence methods get the characters from the parent CharSequence of the environment class
StringPartBase.
*/


const char sign_Mtbl_Part_StringPartJc[] = "Part_StringPartJc"; //to mark method tables of all implementations

typedef struct MtblDef_Part_StringPartJc_t { Mtbl_Part_StringPartJc mtbl; MtblHeadJc end; } MtblDef_Part_StringPartJc;
 extern MtblDef_Part_StringPartJc const mtblPart_StringPartJc;

/*Constructor */
struct Part_StringPartJc_t* ctorO_Part_StringPartJc(struct StringPartJc_t* outer, ObjectJc* othis, int32 from, int32 to, ThCxt* _thCxt)
{ Part_StringPartJc_s* thiz = (Part_StringPartJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_Part_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(Part_StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_Part_StringPartJc_s, sizeof(Part_StringPartJc_s));  
  thiz->outer = outer;
  //j2c: Initialize all class variables:
  {
  }
  { 
    
    ASSERT(/*J2C:static method call*/from >= 0 && from <= thiz->outer->endMax);
    ASSERT(/*J2C:static method call*/to >= 0 && to <= thiz->outer->endMax);
    ASSERT(/*J2C:static method call*/from <= to);
    thiz->b1 = from;
    thiz->e1 = to;
  }
  STACKTRC_LEAVE;
  return thiz;
}


char charAt_i_Part_StringPartJc(ObjectJc* ithis, int32 index, ThCxt* _thCxt)
{ Part_StringPartJc_s* thiz = (Part_StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("charAt_i_Part_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return absCharAt_StringPartJc((struct StringPartJc_t * /*J2C chg access*/)(thiz)->outer, thiz->b1 + index, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 length_Part_StringPartJc(ObjectJc* ithis, ThCxt* _thCxt)
{ Part_StringPartJc_s* thiz = (Part_StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("length_Part_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return thiz->e1 - thiz->b1;
    }
  }
  STACKTRC_LEAVE;
}

CharSeqJc subSequence_ii_Part_StringPartJc(ObjectJc* ithis, int32 from, int32 end, ThCxt* _thCxt)
{ Part_StringPartJc_s* thiz = (Part_StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("subSequence_ii_Part_StringPartJc");
  
  { 
    
    
    struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc((struct StringPartJc_t * /*J2C chg access*/)(thiz)->outer, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), _thCxt), thiz->b1 + from, thiz->b1 + thiz->outer->end, _thCxt);
    { STACKTRC_LEAVE;
      return fromObjectJc_CharSeqJc(&(* (ret)).base.object);
    }
  }
  STACKTRC_LEAVE;
}

StringJc toString_Part_StringPartJc(ObjectJc* ithis, ThCxt* _thCxt)
{ Part_StringPartJc_s* thiz = (Part_StringPartJc_s*)ithis;
  
  STACKTRC_TENTRY("toString_Part_StringPartJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return absSubString_StringPartJc((struct StringPartJc_t * /*J2C chg access*/)(thiz)->outer, thiz->b1, thiz->e1, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Builds a new Part without leading and trailing white spaces.*/
struct Part_StringPartJc_t* trim_Part_StringPartJc(Part_StringPartJc_s* thiz, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("trim_Part_StringPartJc");
  
  { 
    
    
    int32  b2 = thiz->b1;
    
    int32  e2 = thiz->e1;
    
    while(b2 < e2 && indexOf_C_StringJc(zI_StringJc(" \r\n\t",4), charAt_CharSeqJc(thiz->outer->content/*J1cT2*/, b2, _thCxt)) >= 0)
      { 
        
        b2 += 1;
      }
    
    while(e2 > b2 && indexOf_C_StringJc(zI_StringJc(" \r\n",3), charAt_CharSeqJc(thiz->outer->content/*J1cT2*/, e2 - 1, _thCxt)) >= 0)
      { 
        
        e2 -= 1;
      }
    
    struct Part_StringPartJc_t*  ret = ctorO_Part_StringPartJc((struct StringPartJc_t * /*J2C chg access*/)(thiz)->outer, allocInThreadCxt_ObjectJc(sizeof(Part_StringPartJc_s), _thCxt), b2, e2, _thCxt);
    { STACKTRC_LEAVE;
      return ret;
    }
  }
  STACKTRC_LEAVE;
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_Part_StringPartJc mtblPart_StringPartJc = {
{ { sign_Mtbl_Part_StringPartJc //J2C: Head of methodtable of Part_StringPartJc
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
  }
  //J2C: The superclass's methodtable: 
, { { sign_Mtbl_ObjectJc //J2C: Head of methodtable of ObjectJc
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :ObjectJc:
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_Part_StringPartJc //toString
  }
  //J2C: The interface's methodtable: 
  //J2C: Mtbl-interfaces of :Part_StringPartJc: */
, { { sign_Mtbl_CharSeqJc //J2C: Head of methodtable of CharSeqJc
    , (struct Size_Mtbl_t*)((3 +2) * sizeof(void*)) //J2C:size. NOTE: all elements has the size of void*.
    }
    //J2C: Dynamic methods of the class :CharSeqJc:
  , length_Part_StringPartJc //length
  , charAt_i_Part_StringPartJc //charAt
  , subSequence_ii_Part_StringPartJc //subSequence
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern_C struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_Part_StringPartJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_Part_StringPartJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_Part_StringPartJc, ObjectJc) }
   }
 };

 extern_C struct ClassJc_t const reflection_CharSeqJc;
 static struct ifcClasses_Part_StringPartJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }interfaces_Part_StringPartJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_CharSeqJc, OFFSET_Mtbl(Mtbl_Part_StringPartJc, CharSeqJc) }
  }
};

extern_C struct ClassJc_t const reflection_Part_StringPartJc_s;
extern_C struct ClassJc_t const reflection_CharSeqJc;
extern_C struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_Part_StringPartJc_s_t
{ ObjectArrayJc head; FieldJc data[2];
} reflection_Fields_Part_StringPartJc_s =
{ CONST_ObjectArrayJc(FieldJc, 2, OBJTYPE_FieldJc, null, &reflection_Fields_Part_StringPartJc_s)
, {
     { "b1"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Part_StringPartJc_s*)(0x1000))->b1) - (int32)(Part_StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Part_StringPartJc_s
    }
   , { "e1"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Part_StringPartJc_s*)(0x1000))->e1) - (int32)(Part_StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Part_StringPartJc_s
    }
} };
const ClassJc reflection_Part_StringPartJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "Part_StringPartJc_s"
, (int16)((int32)(&((Part_StringPartJc_s*)(0x1000))->base.object) - (int32)(Part_StringPartJc_s*)0x1000)
, sizeof(Part_StringPartJc_s)
, (FieldJcArray const*)&reflection_Fields_Part_StringPartJc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_Part_StringPartJc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_Part_StringPartJc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblPart_StringPartJc.mtbl.head
};
